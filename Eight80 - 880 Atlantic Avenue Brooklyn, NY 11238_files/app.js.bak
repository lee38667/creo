/*! For license information please see app.js.LICENSE.txt */
!function () { var t, e, i, n = { 37: function (t, e, i) { var n = { "./amenity-swiper/amenity-swiper.js": [465, 660, 106], "./contact-scroller/contact-scroller.js": [728, 192], "./cta-banner/cta-banner.js": [859, 228], "./header/header.js": [755, 88], "./headlines/headlines.js": [747, 340], "./hero/hero.js": [737, 790], "./hgroup-media/hgroup-media.js": [25, 660, 414], "./map-interactive/map-interactive.js": [827, 770, 992], "./modal-media-form/modal-media-form.js": [627, 4], "./montage-reveal/montage-reveal.js": [275, 712], "./text-img-scatter/text-img-scatter.js": [105, 2], "./text-marquee/text-marquee.js": [757, 138], "./unit-list/unit-list.js": [243, 20] }; function s(t) { if (!i.o(n, t)) return Promise.resolve().then((function () { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e })); var e = n[t], s = e[0]; return Promise.all(e.slice(1).map(i.e)).then((function () { return i(s) })) } s.keys = function () { return Object.keys(n) }, s.id = 37, t.exports = s }, 66: function (t, e, i) { "use strict"; i.d(e, { u: function () { return ci }, o: function () { return n.os } }); var n = i(996); function s(t, e) { for (var i = 0; i < e.length; i++) { var n = e[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } var r, o, a, l, c, h, u, d, p, f, m, g, v, w = function () { return r || "undefined" != typeof window && (r = window.gsap) && r.registerPlugin && r }, y = 1, _ = [], b = [], S = [], k = Date.now, x = function (t, e) { return e }, E = function (t, e) { return ~S.indexOf(t) && S[S.indexOf(t) + 1][e] }, T = function (t) { return !!~f.indexOf(t) }, A = function (t, e, i, n, s) { return t.addEventListener(e, i, { passive: !1 !== n, capture: !!s }) }, C = function (t, e, i, n) { return t.removeEventListener(e, i, !!n) }, P = "scrollLeft", O = "scrollTop", L = function () { return m && m.isPressed || b.cache++ }, M = function (t, e) { var i = function i(n) { if (n || 0 === n) { y && (a.history.scrollRestoration = "manual"); var s = m && m.isPressed; n = i.v = Math.round(n) || (m && m.iOS ? 1 : 0), t(n), i.cacheID = b.cache, s && x("ss", n) } else (e || b.cache !== i.cacheID || x("ref")) && (i.cacheID = b.cache, i.v = t()); return i.v + i.offset }; return i.offset = 0, t && i }, D = { s: P, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: M((function (t) { return arguments.length ? a.scrollTo(t, R.sc()) : a.pageXOffset || l[P] || c[P] || h[P] || 0 })) }, R = { s: O, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: D, sc: M((function (t) { return arguments.length ? a.scrollTo(D.sc(), t) : a.pageYOffset || l[O] || c[O] || h[O] || 0 })) }, z = function (t, e) { return (e && e._ctx && e._ctx.selector || r.utils.toArray)(t)[0] || ("string" == typeof t && !1 !== r.config().nullTargetWarn ? console.warn("Element not found:", t) : null) }, N = function (t, e) { var i = e.s, n = e.sc; T(t) && (t = l.scrollingElement || c); var s = b.indexOf(t), o = n === R.sc ? 1 : 2; !~s && (s = b.push(t) - 1), b[s + o] || A(t, "scroll", L); var a = b[s + o], h = a || (b[s + o] = M(E(t, i), !0) || (T(t) ? n : M((function (e) { return arguments.length ? t[i] = e : t[i] })))); return h.target = t, a || (h.smooth = "smooth" === r.getProperty(t, "scrollBehavior")), h }, F = function (t, e, i) { var n = t, s = t, r = k(), o = r, a = e || 50, l = Math.max(500, 3 * a), c = function (t, e) { var l = k(); e || l - r > a ? (s = n, n = t, o = r, r = l) : i ? n += t : n = s + (t - s) / (l - o) * (r - o) }; return { update: c, reset: function () { s = n = i ? 0 : n, o = r = 0 }, getVelocity: function (t) { var e = o, a = s, h = k(); return (t || 0 === t) && t !== n && c(t), r === o || h - o > l ? 0 : (n + (i ? a : -a)) / ((i ? h : r) - e) * 1e3 } } }, H = function (t, e) { return e && !t._gsapAllow && t.preventDefault(), t.changedTouches ? t.changedTouches[0] : t }, B = function (t) { var e = Math.max.apply(Math, t), i = Math.min.apply(Math, t); return Math.abs(e) >= Math.abs(i) ? e : i }, I = function () { var t, e, i, n; (p = r.core.globals().ScrollTrigger) && p.core && (t = p.core, e = t.bridge || {}, i = t._scrollers, n = t._proxies, i.push.apply(i, b), n.push.apply(n, S), b = i, S = n, x = function (t, i) { return e[t](i) }) }, Y = function (t) { return r = t || w(), !o && r && "undefined" != typeof document && document.body && (a = window, l = document, c = l.documentElement, h = l.body, f = [a, l, c, h], r.utils.clamp, v = r.core.context || function () { }, d = "onpointerenter" in h ? "pointer" : "mouse", u = j.isTouch = a.matchMedia && a.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in a || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, g = j.eventTypes = ("ontouchstart" in c ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in c ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout((function () { return y = 0 }), 500), I(), o = 1), o }; D.op = R, b.cache = 0; var j = function () { function t(t) { this.init(t) } var e, i, n; return t.prototype.init = function (t) { o || Y(r) || console.warn("Please gsap.registerPlugin(Observer)"), p || I(); var e = t.tolerance, i = t.dragMinimum, n = t.type, s = t.target, f = t.lineHeight, w = t.debounce, y = t.preventDefault, b = t.onStop, S = t.onStopDelay, x = t.ignore, E = t.wheelSpeed, P = t.event, O = t.onDragStart, M = t.onDragEnd, j = t.onDrag, q = t.onPress, U = t.onRelease, W = t.onRight, V = t.onLeft, $ = t.onUp, X = t.onDown, G = t.onChangeX, J = t.onChangeY, K = t.onChange, Z = t.onToggleX, Q = t.onToggleY, tt = t.onHover, et = t.onHoverEnd, it = t.onMove, nt = t.ignoreCheck, st = t.isNormalizer, rt = t.onGestureStart, ot = t.onGestureEnd, at = t.onWheel, lt = t.onEnable, ct = t.onDisable, ht = t.onClick, ut = t.scrollSpeed, dt = t.capture, pt = t.allowClicks, ft = t.lockAxis, mt = t.onLockAxis; this.target = s = z(s) || c, this.vars = t, x && (x = r.utils.toArray(x)), e = e || 1e-9, i = i || 0, E = E || 1, ut = ut || 1, n = n || "wheel,touch,pointer", w = !1 !== w, f || (f = parseFloat(a.getComputedStyle(h).lineHeight) || 22); var gt, vt, wt, yt, _t, bt, St, kt = this, xt = 0, Et = 0, Tt = t.passive || !y && !1 !== t.passive, At = N(s, D), Ct = N(s, R), Pt = At(), Ot = Ct(), Lt = ~n.indexOf("touch") && !~n.indexOf("pointer") && "pointerdown" === g[0], Mt = T(s), Dt = s.ownerDocument || l, Rt = [0, 0, 0], zt = [0, 0, 0], Nt = 0, Ft = function () { return Nt = k() }, Ht = function (t, e) { return (kt.event = t) && x && function (t, e) { for (var i = e.length; i--;)if (e[i] === t || e[i].contains(t)) return !0; return !1 }(t.target, x) || e && Lt && "touch" !== t.pointerType || nt && nt(t, e) }, Bt = function () { var t = kt.deltaX = B(Rt), i = kt.deltaY = B(zt), n = Math.abs(t) >= e, s = Math.abs(i) >= e; K && (n || s) && K(kt, t, i, Rt, zt), n && (W && kt.deltaX > 0 && W(kt), V && kt.deltaX < 0 && V(kt), G && G(kt), Z && kt.deltaX < 0 != xt < 0 && Z(kt), xt = kt.deltaX, Rt[0] = Rt[1] = Rt[2] = 0), s && (X && kt.deltaY > 0 && X(kt), $ && kt.deltaY < 0 && $(kt), J && J(kt), Q && kt.deltaY < 0 != Et < 0 && Q(kt), Et = kt.deltaY, zt[0] = zt[1] = zt[2] = 0), (yt || wt) && (it && it(kt), wt && (O && 1 === wt && O(kt), j && j(kt), wt = 0), yt = !1), bt && !(bt = !1) && mt && mt(kt), _t && (at(kt), _t = !1), gt = 0 }, It = function (t, e, i) { Rt[i] += t, zt[i] += e, kt._vx.update(t), kt._vy.update(e), w ? gt || (gt = requestAnimationFrame(Bt)) : Bt() }, Yt = function (t, e) { ft && !St && (kt.axis = St = Math.abs(t) > Math.abs(e) ? "x" : "y", bt = !0), "y" !== St && (Rt[2] += t, kt._vx.update(t, !0)), "x" !== St && (zt[2] += e, kt._vy.update(e, !0)), w ? gt || (gt = requestAnimationFrame(Bt)) : Bt() }, jt = function (t) { if (!Ht(t, 1)) { var e = (t = H(t, y)).clientX, n = t.clientY, s = e - kt.x, r = n - kt.y, o = kt.isDragging; kt.x = e, kt.y = n, (o || (s || r) && (Math.abs(kt.startX - e) >= i || Math.abs(kt.startY - n) >= i)) && (wt = o ? 2 : 1, o || (kt.isDragging = !0), Yt(s, r)) } }, qt = kt.onPress = function (t) { Ht(t, 1) || t && t.button || (kt.axis = St = null, vt.pause(), kt.isPressed = !0, t = H(t), xt = Et = 0, kt.startX = kt.x = t.clientX, kt.startY = kt.y = t.clientY, kt._vx.reset(), kt._vy.reset(), A(st ? s : Dt, g[1], jt, Tt, !0), kt.deltaX = kt.deltaY = 0, q && q(kt)) }, Ut = kt.onRelease = function (t) { if (!Ht(t, 1)) { C(st ? s : Dt, g[1], jt, !0); var e = !isNaN(kt.y - kt.startY), i = kt.isDragging, n = i && (Math.abs(kt.x - kt.startX) > 3 || Math.abs(kt.y - kt.startY) > 3), o = H(t); !n && e && (kt._vx.reset(), kt._vy.reset(), y && pt && r.delayedCall(.08, (function () { if (k() - Nt > 300 && !t.defaultPrevented) if (t.target.click) t.target.click(); else if (Dt.createEvent) { var e = Dt.createEvent("MouseEvents"); e.initMouseEvent("click", !0, !0, a, 1, o.screenX, o.screenY, o.clientX, o.clientY, !1, !1, !1, !1, 0, null), t.target.dispatchEvent(e) } }))), kt.isDragging = kt.isGesturing = kt.isPressed = !1, b && i && !st && vt.restart(!0), wt && Bt(), M && i && M(kt), U && U(kt, n) } }, Wt = function (t) { return t.touches && t.touches.length > 1 && (kt.isGesturing = !0) && rt(t, kt.isDragging) }, Vt = function () { return (kt.isGesturing = !1) || ot(kt) }, $t = function (t) { if (!Ht(t)) { var e = At(), i = Ct(); It((e - Pt) * ut, (i - Ot) * ut, 1), Pt = e, Ot = i, b && vt.restart(!0) } }, Xt = function (t) { if (!Ht(t)) { t = H(t, y), at && (_t = !0); var e = (1 === t.deltaMode ? f : 2 === t.deltaMode ? a.innerHeight : 1) * E; It(t.deltaX * e, t.deltaY * e, 0), b && !st && vt.restart(!0) } }, Gt = function (t) { if (!Ht(t)) { var e = t.clientX, i = t.clientY, n = e - kt.x, s = i - kt.y; kt.x = e, kt.y = i, yt = !0, b && vt.restart(!0), (n || s) && Yt(n, s) } }, Jt = function (t) { kt.event = t, tt(kt) }, Kt = function (t) { kt.event = t, et(kt) }, Zt = function (t) { return Ht(t) || H(t, y) && ht(kt) }; vt = kt._dc = r.delayedCall(S || .25, (function () { kt._vx.reset(), kt._vy.reset(), vt.pause(), b && b(kt) })).pause(), kt.deltaX = kt.deltaY = 0, kt._vx = F(0, 50, !0), kt._vy = F(0, 50, !0), kt.scrollX = At, kt.scrollY = Ct, kt.isDragging = kt.isGesturing = kt.isPressed = !1, v(this), kt.enable = function (t) { return kt.isEnabled || (A(Mt ? Dt : s, "scroll", L), n.indexOf("scroll") >= 0 && A(Mt ? Dt : s, "scroll", $t, Tt, dt), n.indexOf("wheel") >= 0 && A(s, "wheel", Xt, Tt, dt), (n.indexOf("touch") >= 0 && u || n.indexOf("pointer") >= 0) && (A(s, g[0], qt, Tt, dt), A(Dt, g[2], Ut), A(Dt, g[3], Ut), pt && A(s, "click", Ft, !0, !0), ht && A(s, "click", Zt), rt && A(Dt, "gesturestart", Wt), ot && A(Dt, "gestureend", Vt), tt && A(s, d + "enter", Jt), et && A(s, d + "leave", Kt), it && A(s, d + "move", Gt)), kt.isEnabled = !0, kt.isDragging = kt.isGesturing = kt.isPressed = yt = wt = !1, kt._vx.reset(), kt._vy.reset(), Pt = At(), Ot = Ct(), t && t.type && qt(t), lt && lt(kt)), kt }, kt.disable = function () { kt.isEnabled && (_.filter((function (t) { return t !== kt && T(t.target) })).length || C(Mt ? Dt : s, "scroll", L), kt.isPressed && (kt._vx.reset(), kt._vy.reset(), C(st ? s : Dt, g[1], jt, !0)), C(Mt ? Dt : s, "scroll", $t, dt), C(s, "wheel", Xt, dt), C(s, g[0], qt, dt), C(Dt, g[2], Ut), C(Dt, g[3], Ut), C(s, "click", Ft, !0), C(s, "click", Zt), C(Dt, "gesturestart", Wt), C(Dt, "gestureend", Vt), C(s, d + "enter", Jt), C(s, d + "leave", Kt), C(s, d + "move", Gt), kt.isEnabled = kt.isPressed = kt.isDragging = !1, ct && ct(kt)) }, kt.kill = kt.revert = function () { kt.disable(); var t = _.indexOf(kt); t >= 0 && _.splice(t, 1), m === kt && (m = 0) }, _.push(kt), st && T(s) && (m = kt), kt.enable(P) }, e = t, (i = [{ key: "velocityX", get: function () { return this._vx.getVelocity() } }, { key: "velocityY", get: function () { return this._vy.getVelocity() } }]) && s(e.prototype, i), n && s(e, n), t }(); j.version = "3.13.0", j.create = function (t) { return new j(t) }, j.register = Y, j.getAll = function () { return _.slice() }, j.getById = function (t) { return _.filter((function (e) { return e.vars.id === t }))[0] }, w() && r.registerPlugin(j); var q, U, W, V, $, X, G, J, K, Z, Q, tt, et, it, nt, st, rt, ot, at, lt, ct, ht, ut, dt, pt, ft, mt, gt, vt, wt, yt, _t, bt, St, kt, xt, Et, Tt, At = 1, Ct = Date.now, Pt = Ct(), Ot = 0, Lt = 0, Mt = function (t, e, i) { var n = Vt(t) && ("clamp(" === t.substr(0, 6) || t.indexOf("max") > -1); return i["_" + e + "Clamp"] = n, n ? t.substr(6, t.length - 7) : t }, Dt = function (t, e) { return !e || Vt(t) && "clamp(" === t.substr(0, 6) ? t : "clamp(" + t + ")" }, Rt = function t() { return Lt && requestAnimationFrame(t) }, zt = function () { return it = 1 }, Nt = function () { return it = 0 }, Ft = function (t) { return t }, Ht = function (t) { return Math.round(1e5 * t) / 1e5 || 0 }, Bt = function () { return "undefined" != typeof window }, It = function () { return q || Bt() && (q = window.gsap) && q.registerPlugin && q }, Yt = function (t) { return !!~G.indexOf(t) }, jt = function (t) { return ("Height" === t ? yt : W["inner" + t]) || $["client" + t] || X["client" + t] }, qt = function (t) { return E(t, "getBoundingClientRect") || (Yt(t) ? function () { return ii.width = W.innerWidth, ii.height = yt, ii } : function () { return me(t) }) }, Ut = function (t, e) { var i = e.s, n = e.d2, s = e.d, r = e.a; return Math.max(0, (i = "scroll" + n) && (r = E(t, i)) ? r() - qt(t)()[s] : Yt(t) ? ($[i] || X[i]) - jt(n) : t[i] - t["offset" + n]) }, Wt = function (t, e) { for (var i = 0; i < at.length; i += 3)(!e || ~e.indexOf(at[i + 1])) && t(at[i], at[i + 1], at[i + 2]) }, Vt = function (t) { return "string" == typeof t }, $t = function (t) { return "function" == typeof t }, Xt = function (t) { return "number" == typeof t }, Gt = function (t) { return "object" == typeof t }, Jt = function (t, e, i) { return t && t.progress(e ? 0 : 1) && i && t.pause() }, Kt = function (t, e) { if (t.enabled) { var i = t._ctx ? t._ctx.add((function () { return e(t) })) : e(t); i && i.totalTime && (t.callbackAnimation = i) } }, Zt = Math.abs, Qt = "left", te = "right", ee = "bottom", ie = "width", ne = "height", se = "Right", re = "Left", oe = "Top", ae = "Bottom", le = "padding", ce = "margin", he = "Width", ue = "Height", de = "px", pe = function (t) { return W.getComputedStyle(t) }, fe = function (t, e) { for (var i in e) i in t || (t[i] = e[i]); return t }, me = function (t, e) { var i = e && "matrix(1, 0, 0, 1, 0, 0)" !== pe(t)[nt] && q.to(t, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), n = t.getBoundingClientRect(); return i && i.progress(0).kill(), n }, ge = function (t, e) { var i = e.d2; return t["offset" + i] || t["client" + i] || 0 }, ve = function (t) { var e, i = [], n = t.labels, s = t.duration(); for (e in n) i.push(n[e] / s); return i }, we = function (t) { var e = q.utils.snap(t), i = Array.isArray(t) && t.slice(0).sort((function (t, e) { return t - e })); return i ? function (t, n, s) { var r; if (void 0 === s && (s = .001), !n) return e(t); if (n > 0) { for (t -= s, r = 0; r < i.length; r++)if (i[r] >= t) return i[r]; return i[r - 1] } for (r = i.length, t += s; r--;)if (i[r] <= t) return i[r]; return i[0] } : function (i, n, s) { void 0 === s && (s = .001); var r = e(i); return !n || Math.abs(r - i) < s || r - i < 0 == n < 0 ? r : e(n < 0 ? i - t : i + t) } }, ye = function (t, e, i, n) { return i.split(",").forEach((function (i) { return t(e, i, n) })) }, _e = function (t, e, i, n, s) { return t.addEventListener(e, i, { passive: !n, capture: !!s }) }, be = function (t, e, i, n) { return t.removeEventListener(e, i, !!n) }, Se = function (t, e, i) { (i = i && i.wheelHandler) && (t(e, "wheel", i), t(e, "touchmove", i)) }, ke = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, xe = { toggleActions: "play", anticipatePin: 0 }, Ee = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, Te = function (t, e) { if (Vt(t)) { var i = t.indexOf("="), n = ~i ? +(t.charAt(i - 1) + 1) * parseFloat(t.substr(i + 1)) : 0; ~i && (t.indexOf("%") > i && (n *= e / 100), t = t.substr(0, i - 1)), t = n + (t in Ee ? Ee[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0) } return t }, Ae = function (t, e, i, n, s, r, o, a) { var l = s.startColor, c = s.endColor, h = s.fontSize, u = s.indent, d = s.fontWeight, p = V.createElement("div"), f = Yt(i) || "fixed" === E(i, "pinType"), m = -1 !== t.indexOf("scroller"), g = f ? X : i, v = -1 !== t.indexOf("start"), w = v ? l : c, y = "border-color:" + w + ";font-size:" + h + ";color:" + w + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return y += "position:" + ((m || a) && f ? "fixed;" : "absolute;"), (m || a || !f) && (y += (n === R ? te : ee) + ":" + (r + parseFloat(u)) + "px;"), o && (y += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"), p._isStart = v, p.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")), p.style.cssText = y, p.innerText = e || 0 === e ? t + "-" + e : t, g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p), p._offset = p["offset" + n.op.d2], Ce(p, 0, n, v), p }, Ce = function (t, e, i, n) { var s = { display: "block" }, r = i[n ? "os2" : "p2"], o = i[n ? "p2" : "os2"]; t._isFlipped = n, s[i.a + "Percent"] = n ? -100 : 0, s[i.a] = n ? "1px" : 0, s["border" + r + he] = 1, s["border" + o + he] = 0, s[i.p] = e + "px", q.set(t, s) }, Pe = [], Oe = {}, Le = function () { return Ct() - Ot > 34 && (kt || (kt = requestAnimationFrame(Ge))) }, Me = function () { (!ut || !ut.isPressed || ut.startX > X.clientWidth) && (b.cache++, ut ? kt || (kt = requestAnimationFrame(Ge)) : Ge(), Ot || He("scrollStart"), Ot = Ct()) }, De = function () { ft = W.innerWidth, pt = W.innerHeight }, Re = function (t) { b.cache++, (!0 === t || !et && !ht && !V.fullscreenElement && !V.webkitFullscreenElement && (!dt || ft !== W.innerWidth || Math.abs(W.innerHeight - pt) > .25 * W.innerHeight)) && J.restart(!0) }, ze = {}, Ne = [], Fe = function t() { return be(ci, "scrollEnd", t) || Ve(!0) }, He = function (t) { return ze[t] && ze[t].map((function (t) { return t() })) || Ne }, Be = [], Ie = function (t) { for (var e = 0; e < Be.length; e += 5)(!t || Be[e + 4] && Be[e + 4].query === t) && (Be[e].style.cssText = Be[e + 1], Be[e].getBBox && Be[e].setAttribute("transform", Be[e + 2] || ""), Be[e + 3].uncache = 1) }, Ye = function (t, e) { var i; for (st = 0; st < Pe.length; st++)!(i = Pe[st]) || e && i._ctx !== e || (t ? i.kill(1) : i.revert(!0, !0)); _t = !0, e && Ie(e), e || He("revert") }, je = function (t, e) { b.cache++, (e || !xt) && b.forEach((function (t) { return $t(t) && t.cacheID++ && (t.rec = 0) })), Vt(t) && (W.history.scrollRestoration = vt = t) }, qe = 0, Ue = function () { X.appendChild(wt), yt = !ut && wt.offsetHeight || W.innerHeight, X.removeChild(wt) }, We = function (t) { return K(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach((function (e) { return e.style.display = t ? "none" : "block" })) }, Ve = function (t, e) { if ($ = V.documentElement, X = V.body, G = [W, V, $, X], !Ot || t || _t) { Ue(), xt = ci.isRefreshing = !0, b.forEach((function (t) { return $t(t) && ++t.cacheID && (t.rec = t()) })); var i = He("refreshInit"); lt && ci.sort(), e || Ye(), b.forEach((function (t) { $t(t) && (t.smooth && (t.target.style.scrollBehavior = "auto"), t(0)) })), Pe.slice(0).forEach((function (t) { return t.refresh() })), _t = !1, Pe.forEach((function (t) { if (t._subPinOffset && t.pin) { var e = t.vars.horizontal ? "offsetWidth" : "offsetHeight", i = t.pin[e]; t.revert(!0, 1), t.adjustPinSpacing(t.pin[e] - i), t.refresh() } })), bt = 1, We(!0), Pe.forEach((function (t) { var e = Ut(t.scroller, t._dir), i = "max" === t.vars.end || t._endClamp && t.end > e, n = t._startClamp && t.start >= e; (i || n) && t.setPositions(n ? e - 1 : t.start, i ? Math.max(n ? e : t.start + 1, e) : t.end, !0) })), We(!1), bt = 0, i.forEach((function (t) { return t && t.render && t.render(-1) })), b.forEach((function (t) { $t(t) && (t.smooth && requestAnimationFrame((function () { return t.target.style.scrollBehavior = "smooth" })), t.rec && t(t.rec)) })), je(vt, 1), J.pause(), qe++, xt = 2, Ge(2), Pe.forEach((function (t) { return $t(t.vars.onRefresh) && t.vars.onRefresh(t) })), xt = ci.isRefreshing = !1, He("refresh") } else _e(ci, "scrollEnd", Fe) }, $e = 0, Xe = 1, Ge = function (t) { if (2 === t || !xt && !_t) { ci.isUpdating = !0, Tt && Tt.update(0); var e = Pe.length, i = Ct(), n = i - Pt >= 50, s = e && Pe[0].scroll(); if (Xe = $e > s ? -1 : 1, xt || ($e = s), n && (Ot && !it && i - Ot > 200 && (Ot = 0, He("scrollEnd")), Q = Pt, Pt = i), Xe < 0) { for (st = e; st-- > 0;)Pe[st] && Pe[st].update(0, n); Xe = 1 } else for (st = 0; st < e; st++)Pe[st] && Pe[st].update(0, n); ci.isUpdating = !1 } kt = 0 }, Je = [Qt, "top", ee, te, ce + ae, ce + se, ce + oe, ce + re, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], Ke = Je.concat([ie, ne, "boxSizing", "max" + he, "max" + ue, "position", ce, le, le + oe, le + se, le + ae, le + re]), Ze = function (t, e, i, n) { if (!t._gsap.swappedIn) { for (var s, r = Je.length, o = e.style, a = t.style; r--;)o[s = Je[r]] = i[s]; o.position = "absolute" === i.position ? "absolute" : "relative", "inline" === i.display && (o.display = "inline-block"), a[ee] = a[te] = "auto", o.flexBasis = i.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[ie] = ge(t, D) + de, o[ne] = ge(t, R) + de, o[le] = a[ce] = a.top = a[Qt] = "0", ti(n), a[ie] = a["max" + he] = i[ie], a[ne] = a["max" + ue] = i[ne], a[le] = i[le], t.parentNode !== e && (t.parentNode.insertBefore(e, t), e.appendChild(t)), t._gsap.swappedIn = !0 } }, Qe = /([A-Z])/g, ti = function (t) { if (t) { var e, i, n = t.t.style, s = t.length, r = 0; for ((t.t._gsap || q.core.getCache(t.t)).uncache = 1; r < s; r += 2)i = t[r + 1], e = t[r], i ? n[e] = i : n[e] && n.removeProperty(e.replace(Qe, "-$1").toLowerCase()) } }, ei = function (t) { for (var e = Ke.length, i = t.style, n = [], s = 0; s < e; s++)n.push(Ke[s], i[Ke[s]]); return n.t = t, n }, ii = { left: 0, top: 0 }, ni = function (t, e, i, n, s, r, o, a, l, c, h, u, d, p) { $t(t) && (t = t(a)), Vt(t) && "max" === t.substr(0, 3) && (t = u + ("=" === t.charAt(4) ? Te("0" + t.substr(3), i) : 0)); var f, m, g, v = d ? d.time() : 0; if (d && d.seek(0), isNaN(t) || (t = +t), Xt(t)) d && (t = q.utils.mapRange(d.scrollTrigger.start, d.scrollTrigger.end, 0, u, t)), o && Ce(o, i, n, !0); else { $t(e) && (e = e(a)); var w, y, _, b, S = (t || "0").split(" "); g = z(e, a) || X, (w = me(g) || {}) && (w.left || w.top) || "none" !== pe(g).display || (b = g.style.display, g.style.display = "block", w = me(g), b ? g.style.display = b : g.style.removeProperty("display")), y = Te(S[0], w[n.d]), _ = Te(S[1] || "0", i), t = w[n.p] - l[n.p] - c + y + s - _, o && Ce(o, _, n, i - _ < 20 || o._isStart && _ > 20), i -= i - _ } if (p && (a[p] = t || -.001, t < 0 && (t = 0)), r) { var k = t + i, x = r._isStart; f = "scroll" + n.d2, Ce(r, k, n, x && k > 20 || !x && (h ? Math.max(X[f], $[f]) : r.parentNode[f]) <= k + 1), h && (l = me(o), h && (r.style[n.op.p] = l[n.op.p] - n.op.m - r._offset + de)) } return d && g && (f = me(g), d.seek(u), m = me(g), d._caScrollDist = f[n.p] - m[n.p], t = t / d._caScrollDist * u), d && d.seek(v), d ? t : Math.round(t) }, si = /(webkit|moz|length|cssText|inset)/i, ri = function (t, e, i, n) { if (t.parentNode !== e) { var s, r, o = t.style; if (e === X) { for (s in t._stOrig = o.cssText, r = pe(t)) +s || si.test(s) || !r[s] || "string" != typeof o[s] || "0" === s || (o[s] = r[s]); o.top = i, o.left = n } else o.cssText = t._stOrig; q.core.getCache(t).uncache = 1, e.appendChild(t) } }, oi = function (t, e, i) { var n = e, s = n; return function (e) { var r = Math.round(t()); return r !== n && r !== s && Math.abs(r - n) > 3 && Math.abs(r - s) > 3 && (e = r, i && i()), s = n, n = Math.round(e) } }, ai = function (t, e, i) { var n = {}; n[e.p] = "+=" + i, q.set(t, n) }, li = function (t, e) { var i = N(t, e), n = "_scroll" + e.p2, s = function e(s, r, o, a, l) { var c = e.tween, h = r.onComplete, u = {}; o = o || i(); var d = oi(i, o, (function () { c.kill(), e.tween = 0 })); return l = a && l || 0, a = a || s - o, c && c.kill(), r[n] = s, r.inherit = !1, r.modifiers = u, u[n] = function () { return d(o + a * c.ratio + l * c.ratio * c.ratio) }, r.onUpdate = function () { b.cache++, e.tween && Ge() }, r.onComplete = function () { e.tween = 0, h && h.call(c) }, c = e.tween = q.to(t, r) }; return t[n] = i, i.wheelHandler = function () { return s.tween && s.tween.kill() && (s.tween = 0) }, _e(t, "wheel", i.wheelHandler), ci.isTouch && _e(t, "touchmove", i.wheelHandler), s }, ci = function () { function t(e, i) { U || t.register(q) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), gt(this), this.init(e, i) } return t.prototype.init = function (e, i) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), Lt) { var n, s, r, o, a, l, c, h, u, d, p, f, m, g, v, w, y, _, k, x, T, A, C, P, O, L, M, F, H, B, I, Y, j, U, G, J, tt, nt, rt, ot, at, ht, ut = e = fe(Vt(e) || Xt(e) || e.nodeType ? { trigger: e } : e, xe), dt = ut.onUpdate, pt = ut.toggleClass, ft = ut.id, mt = ut.onToggle, gt = ut.onRefresh, vt = ut.scrub, wt = ut.trigger, yt = ut.pin, _t = ut.pinSpacing, kt = ut.invalidateOnRefresh, Pt = ut.anticipatePin, Rt = ut.onScrubComplete, zt = ut.onSnapComplete, Nt = ut.once, Bt = ut.snap, It = ut.pinReparent, Wt = ut.pinSpacer, Qt = ut.containerAnimation, te = ut.fastScrollEnd, ee = ut.preventOverlaps, ye = e.horizontal || e.containerAnimation && !1 !== e.horizontal ? D : R, Se = !vt && 0 !== vt, Ee = z(e.scroller || W), Ce = q.core.getCache(Ee), Le = Yt(Ee), De = "fixed" === ("pinType" in e ? e.pinType : E(Ee, "pinType") || Le && "fixed"), ze = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack], Ne = Se && e.toggleActions.split(" "), He = "markers" in e ? e.markers : xe.markers, Be = Le ? 0 : parseFloat(pe(Ee)["border" + ye.p2 + he]) || 0, Ie = this, Ye = e.onRefreshInit && function () { return e.onRefreshInit(Ie) }, je = function (t, e, i) { var n = i.d, s = i.d2, r = i.a; return (r = E(t, "getBoundingClientRect")) ? function () { return r()[n] } : function () { return (e ? jt(s) : t["client" + s]) || 0 } }(Ee, Le, ye), Ue = function (t, e) { return !e || ~S.indexOf(t) ? qt(t) : function () { return ii } }(Ee, Le), We = 0, $e = 0, Ge = 0, Je = N(Ee, ye); if (Ie._startClamp = Ie._endClamp = !1, Ie._dir = ye, Pt *= 45, Ie.scroller = Ee, Ie.scroll = Qt ? Qt.time.bind(Qt) : Je, o = Je(), Ie.vars = e, i = i || e.animation, "refreshPriority" in e && (lt = 1, -9999 === e.refreshPriority && (Tt = Ie)), Ce.tweenScroll = Ce.tweenScroll || { top: li(Ee, R), left: li(Ee, D) }, Ie.tweenTo = n = Ce.tweenScroll[ye.p], Ie.scrubDuration = function (t) { (j = Xt(t) && t) ? Y ? Y.duration(t) : Y = q.to(i, { ease: "expo", totalProgress: "+=0", inherit: !1, duration: j, paused: !0, onComplete: function () { return Rt && Rt(Ie) } }) : (Y && Y.progress(1).kill(), Y = 0) }, i && (i.vars.lazy = !1, i._initted && !Ie.isReverted || !1 !== i.vars.immediateRender && !1 !== e.immediateRender && i.duration() && i.render(0, !0, !0), Ie.animation = i.pause(), i.scrollTrigger = Ie, Ie.scrubDuration(vt), B = 0, ft || (ft = i.vars.id)), Bt && (Gt(Bt) && !Bt.push || (Bt = { snapTo: Bt }), "scrollBehavior" in X.style && q.set(Le ? [X, $] : Ee, { scrollBehavior: "auto" }), b.forEach((function (t) { return $t(t) && t.target === (Le ? V.scrollingElement || $ : Ee) && (t.smooth = !1) })), r = $t(Bt.snapTo) ? Bt.snapTo : "labels" === Bt.snapTo ? function (t) { return function (e) { return q.utils.snap(ve(t), e) } }(i) : "labelsDirectional" === Bt.snapTo ? (ot = i, function (t, e) { return we(ve(ot))(t, e.direction) }) : !1 !== Bt.directional ? function (t, e) { return we(Bt.snapTo)(t, Ct() - $e < 500 ? 0 : e.direction) } : q.utils.snap(Bt.snapTo), U = Bt.duration || { min: .1, max: 2 }, U = Gt(U) ? Z(U.min, U.max) : Z(U, U), G = q.delayedCall(Bt.delay || j / 2 || .1, (function () { var t = Je(), e = Ct() - $e < 500, s = n.tween; if (!(e || Math.abs(Ie.getVelocity()) < 10) || s || it || We === t) Ie.isActive && We !== t && G.restart(!0); else { var o, a, h = (t - l) / g, u = i && !Se ? i.totalProgress() : h, d = e ? 0 : (u - I) / (Ct() - Q) * 1e3 || 0, p = q.utils.clamp(-h, 1 - h, Zt(d / 2) * d / .185), f = h + (!1 === Bt.inertia ? 0 : p), m = Bt, v = m.onStart, w = m.onInterrupt, y = m.onComplete; if (o = r(f, Ie), Xt(o) || (o = f), a = Math.max(0, Math.round(l + o * g)), t <= c && t >= l && a !== t) { if (s && !s._initted && s.data <= Zt(a - t)) return; !1 === Bt.inertia && (p = o - h), n(a, { duration: U(Zt(.185 * Math.max(Zt(f - u), Zt(o - u)) / d / .05 || 0)), ease: Bt.ease || "power3", data: Zt(a - t), onInterrupt: function () { return G.restart(!0) && w && w(Ie) }, onComplete: function () { Ie.update(), We = Je(), i && !Se && (Y ? Y.resetTo("totalProgress", o, i._tTime / i._tDur) : i.progress(o)), B = I = i && !Se ? i.totalProgress() : Ie.progress, zt && zt(Ie), y && y(Ie) } }, t, p * g, a - t - p * g), v && v(Ie, n.tween) } } })).pause()), ft && (Oe[ft] = Ie), (rt = (wt = Ie.trigger = z(wt || !0 !== yt && yt)) && wt._gsap && wt._gsap.stRevert) && (rt = rt(Ie)), yt = !0 === yt ? wt : z(yt), Vt(pt) && (pt = { targets: wt, className: pt }), yt && (!1 === _t || _t === ce || (_t = !(!_t && yt.parentNode && yt.parentNode.style && "flex" === pe(yt.parentNode).display) && le), Ie.pin = yt, (s = q.core.getCache(yt)).spacer ? v = s.pinState : (Wt && ((Wt = z(Wt)) && !Wt.nodeType && (Wt = Wt.current || Wt.nativeElement), s.spacerIsNative = !!Wt, Wt && (s.spacerState = ei(Wt))), s.spacer = _ = Wt || V.createElement("div"), _.classList.add("pin-spacer"), ft && _.classList.add("pin-spacer-" + ft), s.pinState = v = ei(yt)), !1 !== e.force3D && q.set(yt, { force3D: !0 }), Ie.spacer = _ = s.spacer, H = pe(yt), P = H[_t + ye.os2], x = q.getProperty(yt), T = q.quickSetter(yt, ye.a, de), Ze(yt, _, H), y = ei(yt)), He) { f = Gt(He) ? fe(He, ke) : ke, d = Ae("scroller-start", ft, Ee, ye, f, 0), p = Ae("scroller-end", ft, Ee, ye, f, 0, d), k = d["offset" + ye.op.d2]; var Ke = z(E(Ee, "content") || Ee); h = this.markerStart = Ae("start", ft, Ke, ye, f, k, 0, Qt), u = this.markerEnd = Ae("end", ft, Ke, ye, f, k, 0, Qt), Qt && (nt = q.quickSetter([h, u], ye.a, de)), De || S.length && !0 === E(Ee, "fixedMarkers") || (ht = pe(at = Le ? X : Ee).position, at.style.position = "absolute" === ht || "fixed" === ht ? ht : "relative", q.set([d, p], { force3D: !0 }), L = q.quickSetter(d, ye.a, de), F = q.quickSetter(p, ye.a, de)) } if (Qt) { var Qe = Qt.vars.onUpdate, si = Qt.vars.onUpdateParams; Qt.eventCallback("onUpdate", (function () { Ie.update(0, 0, 1), Qe && Qe.apply(Qt, si || []) })) } if (Ie.previous = function () { return Pe[Pe.indexOf(Ie) - 1] }, Ie.next = function () { return Pe[Pe.indexOf(Ie) + 1] }, Ie.revert = function (t, e) { if (!e) return Ie.kill(!0); var n = !1 !== t || !Ie.enabled, s = et; n !== Ie.isReverted && (n && (J = Math.max(Je(), Ie.scroll.rec || 0), Ge = Ie.progress, tt = i && i.progress()), h && [h, u, d, p].forEach((function (t) { return t.style.display = n ? "none" : "block" })), n && (et = Ie, Ie.update(n)), !yt || It && Ie.isActive || (n ? function (t, e, i) { ti(i); var n = t._gsap; if (n.spacerIsNative) ti(n.spacerState); else if (t._gsap.swappedIn) { var s = e.parentNode; s && (s.insertBefore(t, e), s.removeChild(e)) } t._gsap.swappedIn = !1 }(yt, _, v) : Ze(yt, _, pe(yt), O)), n || Ie.update(n), et = s, Ie.isReverted = n) }, Ie.refresh = function (s, r, f, b) { if (!et && Ie.enabled || r) if (yt && s && Ot) _e(t, "scrollEnd", Fe); else { !xt && Ye && Ye(Ie), et = Ie, n.tween && !f && (n.tween.kill(), n.tween = 0), Y && Y.pause(), kt && i && (i.revert({ kill: !1 }).invalidate(), i.getChildren && i.getChildren(!0, !0, !1).forEach((function (t) { return t.vars.immediateRender && t.render(0, !0, !0) }))), Ie.isReverted || Ie.revert(!0, !0), Ie._subPinOffset = !1; var S, k, E, T, P, L, F, H, B, I, j, U, W, K = je(), Z = Ue(), Q = Qt ? Qt.duration() : Ut(Ee, ye), it = g <= .01 || !g, nt = 0, st = b || 0, rt = Gt(f) ? f.end : e.end, ot = e.endTrigger || wt, at = Gt(f) ? f.start : e.start || (0 !== e.start && wt ? yt ? "0 0" : "0 100%" : 0), lt = Ie.pinnedContainer = e.pinnedContainer && z(e.pinnedContainer, Ie), ht = wt && Math.max(0, Pe.indexOf(Ie)) || 0, ut = ht; for (He && Gt(f) && (U = q.getProperty(d, ye.p), W = q.getProperty(p, ye.p)); ut-- > 0;)(L = Pe[ut]).end || L.refresh(0, 1) || (et = Ie), !(F = L.pin) || F !== wt && F !== yt && F !== lt || L.isReverted || (I || (I = []), I.unshift(L), L.revert(!0, !0)), L !== Pe[ut] && (ht--, ut--); for ($t(at) && (at = at(Ie)), at = Mt(at, "start", Ie), l = ni(at, wt, K, ye, Je(), h, d, Ie, Z, Be, De, Q, Qt, Ie._startClamp && "_startClamp") || (yt ? -.001 : 0), $t(rt) && (rt = rt(Ie)), Vt(rt) && !rt.indexOf("+=") && (~rt.indexOf(" ") ? rt = (Vt(at) ? at.split(" ")[0] : "") + rt : (nt = Te(rt.substr(2), K), rt = Vt(at) ? at : (Qt ? q.utils.mapRange(0, Qt.duration(), Qt.scrollTrigger.start, Qt.scrollTrigger.end, l) : l) + nt, ot = wt)), rt = Mt(rt, "end", Ie), c = Math.max(l, ni(rt || (ot ? "100% 0" : Q), ot, K, ye, Je() + nt, u, p, Ie, Z, Be, De, Q, Qt, Ie._endClamp && "_endClamp")) || -.001, nt = 0, ut = ht; ut--;)(F = (L = Pe[ut]).pin) && L.start - L._pinPush <= l && !Qt && L.end > 0 && (S = L.end - (Ie._startClamp ? Math.max(0, L.start) : L.start), (F === wt && L.start - L._pinPush < l || F === lt) && isNaN(at) && (nt += S * (1 - L.progress)), F === yt && (st += S)); if (l += nt, c += nt, Ie._startClamp && (Ie._startClamp += nt), Ie._endClamp && !xt && (Ie._endClamp = c || -.001, c = Math.min(c, Ut(Ee, ye))), g = c - l || (l -= .01) && .001, it && (Ge = q.utils.clamp(0, 1, q.utils.normalize(l, c, J))), Ie._pinPush = st, h && nt && ((S = {})[ye.a] = "+=" + nt, lt && (S[ye.p] = "-=" + Je()), q.set([h, u], S)), !yt || bt && Ie.end >= Ut(Ee, ye)) { if (wt && Je() && !Qt) for (k = wt.parentNode; k && k !== X;)k._pinOffset && (l -= k._pinOffset, c -= k._pinOffset), k = k.parentNode } else S = pe(yt), T = ye === R, E = Je(), A = parseFloat(x(ye.a)) + st, !Q && c > 1 && (j = { style: j = (Le ? V.scrollingElement || $ : Ee).style, value: j["overflow" + ye.a.toUpperCase()] }, Le && "scroll" !== pe(X)["overflow" + ye.a.toUpperCase()] && (j.style["overflow" + ye.a.toUpperCase()] = "scroll")), Ze(yt, _, S), y = ei(yt), k = me(yt, !0), H = De && N(Ee, T ? D : R)(), _t ? ((O = [_t + ye.os2, g + st + de]).t = _, (ut = _t === le ? ge(yt, ye) + g + st : 0) && (O.push(ye.d, ut + de), "auto" !== _.style.flexBasis && (_.style.flexBasis = ut + de)), ti(O), lt && Pe.forEach((function (t) { t.pin === lt && !1 !== t.vars.pinSpacing && (t._subPinOffset = !0) })), De && Je(J)) : (ut = ge(yt, ye)) && "auto" !== _.style.flexBasis && (_.style.flexBasis = ut + de), De && ((P = { top: k.top + (T ? E - l : H) + de, left: k.left + (T ? H : E - l) + de, boxSizing: "border-box", position: "fixed" })[ie] = P["max" + he] = Math.ceil(k.width) + de, P[ne] = P["max" + ue] = Math.ceil(k.height) + de, P[ce] = P[ce + oe] = P[ce + se] = P[ce + ae] = P[ce + re] = "0", P[le] = S[le], P[le + oe] = S[le + oe], P[le + se] = S[le + se], P[le + ae] = S[le + ae], P[le + re] = S[le + re], w = function (t, e, i) { for (var n, s = [], r = t.length, o = i ? 8 : 0; o < r; o += 2)n = t[o], s.push(n, n in e ? e[n] : t[o + 1]); return s.t = t.t, s }(v, P, It), xt && Je(0)), i ? (B = i._initted, ct(1), i.render(i.duration(), !0, !0), C = x(ye.a) - A + g + st, M = Math.abs(g - C) > 1, De && M && w.splice(w.length - 2, 2), i.render(0, !0, !0), B || i.invalidate(!0), i.parent || i.totalTime(i.totalTime()), ct(0)) : C = g, j && (j.value ? j.style["overflow" + ye.a.toUpperCase()] = j.value : j.style.removeProperty("overflow-" + ye.a)); I && I.forEach((function (t) { return t.revert(!1, !0) })), Ie.start = l, Ie.end = c, o = a = xt ? J : Je(), Qt || xt || (o < J && Je(J), Ie.scroll.rec = 0), Ie.revert(!1, !0), $e = Ct(), G && (We = -1, G.restart(!0)), et = 0, i && Se && (i._initted || tt) && i.progress() !== tt && i.progress(tt || 0, !0).render(i.time(), !0, !0), (it || Ge !== Ie.progress || Qt || kt || i && !i._initted) && (i && !Se && (i._initted || Ge || !1 !== i.vars.immediateRender) && i.totalProgress(Qt && l < -.001 && !Ge ? q.utils.normalize(l, c, 0) : Ge, !0), Ie.progress = it || (o - l) / g === Ge ? 0 : Ge), yt && _t && (_._pinOffset = Math.round(Ie.progress * C)), Y && Y.invalidate(), isNaN(U) || (U -= q.getProperty(d, ye.p), W -= q.getProperty(p, ye.p), ai(d, ye, U), ai(h, ye, U - (b || 0)), ai(p, ye, W), ai(u, ye, W - (b || 0))), it && !xt && Ie.update(), !gt || xt || m || (m = !0, gt(Ie), m = !1) } }, Ie.getVelocity = function () { return (Je() - a) / (Ct() - Q) * 1e3 || 0 }, Ie.endAnimation = function () { Jt(Ie.callbackAnimation), i && (Y ? Y.progress(1) : i.paused() ? Se || Jt(i, Ie.direction < 0, 1) : Jt(i, i.reversed())) }, Ie.labelToScroll = function (t) { return i && i.labels && (l || Ie.refresh() || l) + i.labels[t] / i.duration() * g || 0 }, Ie.getTrailing = function (t) { var e = Pe.indexOf(Ie), i = Ie.direction > 0 ? Pe.slice(0, e).reverse() : Pe.slice(e + 1); return (Vt(t) ? i.filter((function (e) { return e.vars.preventOverlaps === t })) : i).filter((function (t) { return Ie.direction > 0 ? t.end <= l : t.start >= c })) }, Ie.update = function (t, e, s) { if (!Qt || s || t) { var r, h, u, p, f, m, v, b = !0 === xt ? J : Ie.scroll(), S = t ? 0 : (b - l) / g, k = S < 0 ? 0 : S > 1 ? 1 : S || 0, x = Ie.progress; if (e && (a = o, o = Qt ? Je() : b, Bt && (I = B, B = i && !Se ? i.totalProgress() : k)), Pt && yt && !et && !At && Ot && (!k && l < b + (b - a) / (Ct() - Q) * Pt ? k = 1e-4 : 1 === k && c > b + (b - a) / (Ct() - Q) * Pt && (k = .9999)), k !== x && Ie.enabled) { if (p = (f = (r = Ie.isActive = !!k && k < 1) !== (!!x && x < 1)) || !!k != !!x, Ie.direction = k > x ? 1 : -1, Ie.progress = k, p && !et && (h = k && !x ? 0 : 1 === k ? 1 : 1 === x ? 2 : 3, Se && (u = !f && "none" !== Ne[h + 1] && Ne[h + 1] || Ne[h], v = i && ("complete" === u || "reset" === u || u in i))), ee && (f || v) && (v || vt || !i) && ($t(ee) ? ee(Ie) : Ie.getTrailing(ee).forEach((function (t) { return t.endAnimation() }))), Se || (!Y || et || At ? i && i.totalProgress(k, !(!et || !$e && !t)) : (Y._dp._time - Y._start !== Y._time && Y.render(Y._dp._time - Y._start), Y.resetTo ? Y.resetTo("totalProgress", k, i._tTime / i._tDur) : (Y.vars.totalProgress = k, Y.invalidate().restart()))), yt) if (t && _t && (_.style[_t + ye.os2] = P), De) { if (p) { if (m = !t && k > x && c + 1 > b && b + 1 >= Ut(Ee, ye), It) if (t || !r && !m) ri(yt, _); else { var E = me(yt, !0), O = b - l; ri(yt, X, E.top + (ye === R ? O : 0) + de, E.left + (ye === R ? 0 : O) + de) } ti(r || m ? w : y), M && k < 1 && r || T(A + (1 !== k || m ? 0 : C)) } } else T(Ht(A + C * k)); Bt && !n.tween && !et && !At && G.restart(!0), pt && (f || Nt && k && (k < 1 || !St)) && K(pt.targets).forEach((function (t) { return t.classList[r || Nt ? "add" : "remove"](pt.className) })), dt && !Se && !t && dt(Ie), p && !et ? (Se && (v && ("complete" === u ? i.pause().totalProgress(1) : "reset" === u ? i.restart(!0).pause() : "restart" === u ? i.restart(!0) : i[u]()), dt && dt(Ie)), !f && St || (mt && f && Kt(Ie, mt), ze[h] && Kt(Ie, ze[h]), Nt && (1 === k ? Ie.kill(!1, 1) : ze[h] = 0), f || ze[h = 1 === k ? 1 : 3] && Kt(Ie, ze[h])), te && !r && Math.abs(Ie.getVelocity()) > (Xt(te) ? te : 2500) && (Jt(Ie.callbackAnimation), Y ? Y.progress(1) : Jt(i, "reverse" === u ? 1 : !k, 1))) : Se && dt && !et && dt(Ie) } if (F) { var D = Qt ? b / Qt.duration() * (Qt._caScrollDist || 0) : b; L(D + (d._isFlipped ? 1 : 0)), F(D) } nt && nt(-b / Qt.duration() * (Qt._caScrollDist || 0)) } }, Ie.enable = function (e, i) { Ie.enabled || (Ie.enabled = !0, _e(Ee, "resize", Re), Le || _e(Ee, "scroll", Me), Ye && _e(t, "refreshInit", Ye), !1 !== e && (Ie.progress = Ge = 0, o = a = We = Je()), !1 !== i && Ie.refresh()) }, Ie.getTween = function (t) { return t && n ? n.tween : Y }, Ie.setPositions = function (t, e, i, n) { if (Qt) { var s = Qt.scrollTrigger, r = Qt.duration(), o = s.end - s.start; t = s.start + o * t / r, e = s.start + o * e / r } Ie.refresh(!1, !1, { start: Dt(t, i && !!Ie._startClamp), end: Dt(e, i && !!Ie._endClamp) }, n), Ie.update() }, Ie.adjustPinSpacing = function (t) { if (O && t) { var e = O.indexOf(ye.d) + 1; O[e] = parseFloat(O[e]) + t + de, O[1] = parseFloat(O[1]) + t + de, ti(O) } }, Ie.disable = function (e, i) { if (Ie.enabled && (!1 !== e && Ie.revert(!0, !0), Ie.enabled = Ie.isActive = !1, i || Y && Y.pause(), J = 0, s && (s.uncache = 1), Ye && be(t, "refreshInit", Ye), G && (G.pause(), n.tween && n.tween.kill() && (n.tween = 0)), !Le)) { for (var r = Pe.length; r--;)if (Pe[r].scroller === Ee && Pe[r] !== Ie) return; be(Ee, "resize", Re), Le || be(Ee, "scroll", Me) } }, Ie.kill = function (t, n) { Ie.disable(t, n), Y && !n && Y.kill(), ft && delete Oe[ft]; var r = Pe.indexOf(Ie); r >= 0 && Pe.splice(r, 1), r === st && Xe > 0 && st--, r = 0, Pe.forEach((function (t) { return t.scroller === Ie.scroller && (r = 1) })), r || xt || (Ie.scroll.rec = 0), i && (i.scrollTrigger = null, t && i.revert({ kill: !1 }), n || i.kill()), h && [h, u, d, p].forEach((function (t) { return t.parentNode && t.parentNode.removeChild(t) })), Tt === Ie && (Tt = 0), yt && (s && (s.uncache = 1), r = 0, Pe.forEach((function (t) { return t.pin === yt && r++ })), r || (s.spacer = 0)), e.onKill && e.onKill(Ie) }, Pe.push(Ie), Ie.enable(!1, !1), rt && rt(Ie), i && i.add && !g) { var oi = Ie.update; Ie.update = function () { Ie.update = oi, b.cache++, l || c || Ie.refresh() }, q.delayedCall(.01, Ie.update), g = .01, l = c = 0 } else Ie.refresh(); yt && function () { if (Et !== qe) { var t = Et = qe; requestAnimationFrame((function () { return t === qe && Ve(!0) })) } }() } else this.update = this.refresh = this.kill = Ft }, t.register = function (e) { return U || (q = e || It(), Bt() && window.document && t.enable(), U = Lt), U }, t.defaults = function (t) { if (t) for (var e in t) xe[e] = t[e]; return xe }, t.disable = function (t, e) { Lt = 0, Pe.forEach((function (i) { return i[e ? "kill" : "disable"](t) })), be(W, "wheel", Me), be(V, "scroll", Me), clearInterval(tt), be(V, "touchcancel", Ft), be(X, "touchstart", Ft), ye(be, V, "pointerdown,touchstart,mousedown", zt), ye(be, V, "pointerup,touchend,mouseup", Nt), J.kill(), Wt(be); for (var i = 0; i < b.length; i += 3)Se(be, b[i], b[i + 1]), Se(be, b[i], b[i + 2]) }, t.enable = function () { if (W = window, V = document, $ = V.documentElement, X = V.body, q && (K = q.utils.toArray, Z = q.utils.clamp, gt = q.core.context || Ft, ct = q.core.suppressOverwrites || Ft, vt = W.history.scrollRestoration || "auto", $e = W.pageYOffset || 0, q.core.globals("ScrollTrigger", t), X)) { Lt = 1, (wt = document.createElement("div")).style.height = "100vh", wt.style.position = "absolute", Ue(), Rt(), j.register(q), t.isTouch = j.isTouch, mt = j.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), dt = 1 === j.isTouch, _e(W, "wheel", Me), G = [W, V, $, X], q.matchMedia ? (t.matchMedia = function (t) { var e, i = q.matchMedia(); for (e in t) i.add(e, t[e]); return i }, q.addEventListener("matchMediaInit", (function () { return Ye() })), q.addEventListener("matchMediaRevert", (function () { return Ie() })), q.addEventListener("matchMedia", (function () { Ve(0, 1), He("matchMedia") })), q.matchMedia().add("(orientation: portrait)", (function () { return De(), De }))) : console.warn("Requires GSAP 3.11.0 or later"), De(), _e(V, "scroll", Me); var e, i, n = X.hasAttribute("style"), s = X.style, r = s.borderTopStyle, o = q.core.Animation.prototype; for (o.revert || Object.defineProperty(o, "revert", { value: function () { return this.time(-.01, !0) } }), s.borderTopStyle = "solid", e = me(X), R.m = Math.round(e.top + R.sc()) || 0, D.m = Math.round(e.left + D.sc()) || 0, r ? s.borderTopStyle = r : s.removeProperty("border-top-style"), n || (X.setAttribute("style", ""), X.removeAttribute("style")), tt = setInterval(Le, 250), q.delayedCall(.5, (function () { return At = 0 })), _e(V, "touchcancel", Ft), _e(X, "touchstart", Ft), ye(_e, V, "pointerdown,touchstart,mousedown", zt), ye(_e, V, "pointerup,touchend,mouseup", Nt), nt = q.utils.checkPrefix("transform"), Ke.push(nt), U = Ct(), J = q.delayedCall(.2, Ve).pause(), at = [V, "visibilitychange", function () { var t = W.innerWidth, e = W.innerHeight; V.hidden ? (rt = t, ot = e) : rt === t && ot === e || Re() }, V, "DOMContentLoaded", Ve, W, "load", Ve, W, "resize", Re], Wt(_e), Pe.forEach((function (t) { return t.enable(0, 1) })), i = 0; i < b.length; i += 3)Se(be, b[i], b[i + 1]), Se(be, b[i], b[i + 2]) } }, t.config = function (e) { "limitCallbacks" in e && (St = !!e.limitCallbacks); var i = e.syncInterval; i && clearInterval(tt) || (tt = i) && setInterval(Le, i), "ignoreMobileResize" in e && (dt = 1 === t.isTouch && e.ignoreMobileResize), "autoRefreshEvents" in e && (Wt(be) || Wt(_e, e.autoRefreshEvents || "none"), ht = -1 === (e.autoRefreshEvents + "").indexOf("resize")) }, t.scrollerProxy = function (t, e) { var i = z(t), n = b.indexOf(i), s = Yt(i); ~n && b.splice(n, s ? 6 : 2), e && (s ? S.unshift(W, e, X, e, $, e) : S.unshift(i, e)) }, t.clearMatchMedia = function (t) { Pe.forEach((function (e) { return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0) })) }, t.isInViewport = function (t, e, i) { var n = (Vt(t) ? z(t) : t).getBoundingClientRect(), s = n[i ? ie : ne] * e || 0; return i ? n.right - s > 0 && n.left + s < W.innerWidth : n.bottom - s > 0 && n.top + s < W.innerHeight }, t.positionInViewport = function (t, e, i) { Vt(t) && (t = z(t)); var n = t.getBoundingClientRect(), s = n[i ? ie : ne], r = null == e ? s / 2 : e in Ee ? Ee[e] * s : ~e.indexOf("%") ? parseFloat(e) * s / 100 : parseFloat(e) || 0; return i ? (n.left + r) / W.innerWidth : (n.top + r) / W.innerHeight }, t.killAll = function (t) { if (Pe.slice(0).forEach((function (t) { return "ScrollSmoother" !== t.vars.id && t.kill() })), !0 !== t) { var e = ze.killAll || []; ze = {}, e.forEach((function (t) { return t() })) } }, t }(); ci.version = "3.13.0", ci.saveStyles = function (t) { return t ? K(t).forEach((function (t) { if (t && t.style) { var e = Be.indexOf(t); e >= 0 && Be.splice(e, 5), Be.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), q.core.getCache(t), gt()) } })) : Be }, ci.revert = function (t, e) { return Ye(!t, e) }, ci.create = function (t, e) { return new ci(t, e) }, ci.refresh = function (t) { return t ? Re(!0) : (U || ci.register()) && Ve(!0) }, ci.update = function (t) { return ++b.cache && Ge(!0 === t ? 2 : 0) }, ci.clearScrollMemory = je, ci.maxScroll = function (t, e) { return Ut(t, e ? D : R) }, ci.getScrollFunc = function (t, e) { return N(z(t), e ? D : R) }, ci.getById = function (t) { return Oe[t] }, ci.getAll = function () { return Pe.filter((function (t) { return "ScrollSmoother" !== t.vars.id })) }, ci.isScrolling = function () { return !!Ot }, ci.snapDirectional = we, ci.addEventListener = function (t, e) { var i = ze[t] || (ze[t] = []); ~i.indexOf(e) || i.push(e) }, ci.removeEventListener = function (t, e) { var i = ze[t], n = i && i.indexOf(e); n >= 0 && i.splice(n, 1) }, ci.batch = function (t, e) { var i, n = [], s = {}, r = e.interval || .016, o = e.batchMax || 1e9, a = function (t, e) { var i = [], n = [], s = q.delayedCall(r, (function () { e(i, n), i = [], n = [] })).pause(); return function (t) { i.length || s.restart(!0), i.push(t.trigger), n.push(t), o <= i.length && s.progress(1) } }; for (i in e) s[i] = "on" === i.substr(0, 2) && $t(e[i]) && "onRefreshInit" !== i ? a(0, e[i]) : e[i]; return $t(o) && (o = o(), _e(ci, "refresh", (function () { return o = e.batchMax() }))), K(t).forEach((function (t) { var e = {}; for (i in s) e[i] = s[i]; e.trigger = t, n.push(ci.create(e)) })), n }; var hi, ui = function (t, e, i, n) { return e > n ? t(n) : e < 0 && t(0), i > n ? (n - e) / (i - e) : i < 0 ? e / (e - i) : 1 }, di = function t(e, i) { !0 === i ? e.style.removeProperty("touch-action") : e.style.touchAction = !0 === i ? "auto" : i ? "pan-" + i + (j.isTouch ? " pinch-zoom" : "") : "none", e === $ && t(X, i) }, pi = { auto: 1, scroll: 1 }, fi = function (t) { var e, i = t.event, n = t.target, s = t.axis, r = (i.changedTouches ? i.changedTouches[0] : i).target, o = r._gsap || q.core.getCache(r), a = Ct(); if (!o._isScrollT || a - o._isScrollT > 2e3) { for (; r && r !== X && (r.scrollHeight <= r.clientHeight && r.scrollWidth <= r.clientWidth || !pi[(e = pe(r)).overflowY] && !pi[e.overflowX]);)r = r.parentNode; o._isScroll = r && r !== n && !Yt(r) && (pi[(e = pe(r)).overflowY] || pi[e.overflowX]), o._isScrollT = a } (o._isScroll || "x" === s) && (i.stopPropagation(), i._gsapAllow = !0) }, mi = function (t, e, i, n) { return j.create({ target: t, capture: !0, debounce: !1, lockAxis: !0, type: e, onWheel: n = n && fi, onPress: n, onDrag: n, onScroll: n, onEnable: function () { return i && _e(V, j.eventTypes[0], vi, !1, !0) }, onDisable: function () { return be(V, j.eventTypes[0], vi, !0) } }) }, gi = /(input|label|select|textarea)/i, vi = function (t) { var e = gi.test(t.target.tagName); (e || hi) && (t._gsapAllow = !0, hi = e) }, wi = function (t) { Gt(t) || (t = {}), t.preventDefault = t.isNormalizer = t.allowClicks = !0, t.type || (t.type = "wheel,touch"), t.debounce = !!t.debounce, t.id = t.id || "normalizer"; var e, i, n, s, r, o, a, l, c = t, h = c.normalizeScrollX, u = c.momentum, d = c.allowNestedScroll, p = c.onRelease, f = z(t.target) || $, m = q.core.globals().ScrollSmoother, g = m && m.get(), v = mt && (t.content && z(t.content) || g && !1 !== t.content && !g.smooth() && g.content()), w = N(f, R), y = N(f, D), _ = 1, S = (j.isTouch && W.visualViewport ? W.visualViewport.scale * W.visualViewport.width : W.outerWidth) / W.innerWidth, k = 0, x = $t(u) ? function () { return u(e) } : function () { return u || 2.8 }, E = mi(f, t.type, !0, d), T = function () { return s = !1 }, A = Ft, C = Ft, P = function () { i = Ut(f, R), C = Z(mt ? 1 : 0, i), h && (A = Z(0, Ut(f, D))), n = qe }, O = function () { v._gsap.y = Ht(parseFloat(v._gsap.y) + w.offset) + "px", v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)", w.offset = w.cacheID = 0 }, L = function () { P(), r.isActive() && r.vars.scrollY > i && (w() > i ? r.progress(1) && w(i) : r.resetTo("scrollY", i)) }; return v && q.set(v, { y: "+=0" }), t.ignoreCheck = function (t) { return mt && "touchmove" === t.type && function () { if (s) { requestAnimationFrame(T); var t = Ht(e.deltaY / 2), i = C(w.v - t); if (v && i !== w.v + w.offset) { w.offset = i - w.v; var n = Ht((parseFloat(v && v._gsap.y) || 0) - w.offset); v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + n + ", 0, 1)", v._gsap.y = n + "px", w.cacheID = b.cache, Ge() } return !0 } w.offset && O(), s = !0 }() || _ > 1.05 && "touchstart" !== t.type || e.isGesturing || t.touches && t.touches.length > 1 }, t.onPress = function () { s = !1; var t = _; _ = Ht((W.visualViewport && W.visualViewport.scale || 1) / S), r.pause(), t !== _ && di(f, _ > 1.01 || !h && "x"), o = y(), a = w(), P(), n = qe }, t.onRelease = t.onGestureStart = function (t, e) { if (w.offset && O(), e) { b.cache++; var n, s, o = x(); h && (s = (n = y()) + .05 * o * -t.velocityX / .227, o *= ui(y, n, s, Ut(f, D)), r.vars.scrollX = A(s)), s = (n = w()) + .05 * o * -t.velocityY / .227, o *= ui(w, n, s, Ut(f, R)), r.vars.scrollY = C(s), r.invalidate().duration(o).play(.01), (mt && r.vars.scrollY >= i || n >= i - 1) && q.to({}, { onUpdate: L, duration: o }) } else l.restart(!0); p && p(t) }, t.onWheel = function () { r._ts && r.pause(), Ct() - k > 1e3 && (n = 0, k = Ct()) }, t.onChange = function (t, e, i, s, r) { if (qe !== n && P(), e && h && y(A(s[2] === e ? o + (t.startX - t.x) : y() + e - s[1])), i) { w.offset && O(); var l = r[2] === i, c = l ? a + t.startY - t.y : w() + i - r[1], u = C(c); l && c !== u && (a += u - c), w(u) } (i || e) && Ge() }, t.onEnable = function () { di(f, !h && "x"), ci.addEventListener("refresh", L), _e(W, "resize", L), w.smooth && (w.target.style.scrollBehavior = "auto", w.smooth = y.smooth = !1), E.enable() }, t.onDisable = function () { di(f, !0), be(W, "resize", L), ci.removeEventListener("refresh", L), E.kill() }, t.lockAxis = !1 !== t.lockAxis, (e = new j(t)).iOS = mt, mt && !w() && w(1), mt && q.ticker.add(Ft), l = e._dc, r = q.to(e, { ease: "power4", paused: !0, inherit: !1, scrollX: h ? "+=0.1" : "+=0", scrollY: "+=0.1", modifiers: { scrollY: oi(w, w(), (function () { return r.pause() })) }, onUpdate: Ge, onComplete: l.vars.onComplete }), e }; ci.sort = function (t) { if ($t(t)) return Pe.sort(t); var e = W.pageYOffset || 0; return ci.getAll().forEach((function (t) { return t._sortY = t.trigger ? e + t.trigger.getBoundingClientRect().top : t.start + W.innerHeight })), Pe.sort(t || function (t, e) { return -1e6 * (t.vars.refreshPriority || 0) + (t.vars.containerAnimation ? 1e6 : t._sortY) - ((e.vars.containerAnimation ? 1e6 : e._sortY) + -1e6 * (e.vars.refreshPriority || 0)) }) }, ci.observe = function (t) { return new j(t) }, ci.normalizeScroll = function (t) { if (void 0 === t) return ut; if (!0 === t && ut) return ut.enable(); if (!1 === t) return ut && ut.kill(), void (ut = t); var e = t instanceof j ? t : wi(t); return ut && ut.target === e.target && ut.kill(), Yt(e.target) && (ut = e), e }, ci.core = { _getVelocityProp: F, _inputObserver: mi, _scrollers: b, _proxies: S, bridge: { ss: function () { Ot || He("scrollStart"), Ot = Ct() }, ref: function () { return et } } }, It() && q.registerPlugin(ci), n.os.registerPlugin(ci) }, 397: function (t, e, i) { var n = { "./amenity-swiper/amenity-swiper.css": [943, 972], "./center-text/center-text.css": [385, 814], "./contact-scroller/contact-scroller.css": [305, 82], "./cta-banner/cta-banner.css": [241, 678], "./footer/footer.css": [157, 702], "./header/header.css": [561, 978], "./headlines/headlines.css": [441, 70], "./hero/hero.css": [879, 976], "./hgroup-media/hgroup-media.css": [967, 480], "./map-interactive/map-interactive.css": [193, 794], "./modal-media-form/modal-media-form.css": [289, 542], "./montage-reveal/montage-reveal.css": [225, 578], "./password/password.css": [785, 26], "./text-img-scatter/text-img-scatter.css": [383, 676], "./text-marquee/text-marquee.css": [208, 996], "./unit-list/unit-list.css": [329, 726] }; function s(t) { if (!i.o(n, t)) return Promise.resolve().then((function () { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e })); var e = n[t], s = e[0]; return i.e(e[1]).then((function () { return i(s) })) } s.keys = function () { return Object.keys(n) }, s.id = 397, t.exports = s }, 996: function (t, e, i) { "use strict"; function n(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function s(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e } i.d(e, { Ay: function () { return Kn }, os: function () { return Kn } }); var r, o, a, l, c, h, u, d, p, f, m, g, v, w, y, _, b, S = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, k = { duration: .5, overwrite: !1, delay: 0 }, x = 1e8, E = 1e-8, T = 2 * Math.PI, A = T / 4, C = 0, P = Math.sqrt, O = Math.cos, L = Math.sin, M = function (t) { return "string" == typeof t }, D = function (t) { return "function" == typeof t }, R = function (t) { return "number" == typeof t }, z = function (t) { return void 0 === t }, N = function (t) { return "object" == typeof t }, F = function (t) { return !1 !== t }, H = function () { return "undefined" != typeof window }, B = function (t) { return D(t) || M(t) }, I = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { }, Y = Array.isArray, j = /(?:-?\.?\d|\.)+/gi, q = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, U = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, W = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, V = /[+-]=-?[.\d]+/, $ = /[^,'"\[\]\s]+/gi, X = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, G = {}, J = {}, K = function (t) { return (J = At(t, G)) && Ci }, Z = function (t, e) { return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()") }, Q = function (t, e) { return !e && console.warn(t) }, tt = function (t, e) { return t && (G[t] = e) && J && (J[t] = e) || G }, et = function () { return 0 }, it = { suppressEvents: !0, isStart: !0, kill: !1 }, nt = { suppressEvents: !0, kill: !1 }, st = { suppressEvents: !0 }, rt = {}, ot = [], at = {}, lt = {}, ct = {}, ht = 30, ut = [], dt = "", pt = function (t) { var e, i, n = t[0]; if (N(n) || D(n) || (t = [t]), !(e = (n._gsap || {}).harness)) { for (i = ut.length; i-- && !ut[i].targetTest(n);); e = ut[i] } for (i = t.length; i--;)t[i] && (t[i]._gsap || (t[i]._gsap = new je(t[i], e))) || t.splice(i, 1); return t }, ft = function (t) { return t._gsap || pt(re(t))[0]._gsap }, mt = function (t, e, i) { return (i = t[e]) && D(i) ? t[e]() : z(i) && t.getAttribute && t.getAttribute(e) || i }, gt = function (t, e) { return (t = t.split(",")).forEach(e) || t }, vt = function (t) { return Math.round(1e5 * t) / 1e5 || 0 }, wt = function (t) { return Math.round(1e7 * t) / 1e7 || 0 }, yt = function (t, e) { var i = e.charAt(0), n = parseFloat(e.substr(2)); return t = parseFloat(t), "+" === i ? t + n : "-" === i ? t - n : "*" === i ? t * n : t / n }, _t = function (t, e) { for (var i = e.length, n = 0; t.indexOf(e[n]) < 0 && ++n < i;); return n < i }, bt = function () { var t, e, i = ot.length, n = ot.slice(0); for (at = {}, ot.length = 0, t = 0; t < i; t++)(e = n[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0) }, St = function (t) { return !!(t._initted || t._startAt || t.add) }, kt = function (t, e, i, n) { ot.length && !o && bt(), t.render(e, i, n || !!(o && e < 0 && St(t))), ot.length && !o && bt() }, xt = function (t) { var e = parseFloat(t); return (e || 0 === e) && (t + "").match($).length < 2 ? e : M(t) ? t.trim() : t }, Et = function (t) { return t }, Tt = function (t, e) { for (var i in e) i in t || (t[i] = e[i]); return t }, At = function (t, e) { for (var i in e) t[i] = e[i]; return t }, Ct = function t(e, i) { for (var n in i) "__proto__" !== n && "constructor" !== n && "prototype" !== n && (e[n] = N(i[n]) ? t(e[n] || (e[n] = {}), i[n]) : i[n]); return e }, Pt = function (t, e) { var i, n = {}; for (i in t) i in e || (n[i] = t[i]); return n }, Ot = function (t) { var e, i = t.parent || l, n = t.keyframes ? (e = Y(t.keyframes), function (t, i) { for (var n in i) n in t || "duration" === n && e || "ease" === n || (t[n] = i[n]) }) : Tt; if (F(t.inherit)) for (; i;)n(t, i.vars.defaults), i = i.parent || i._dp; return t }, Lt = function (t, e, i, n, s) { void 0 === i && (i = "_first"), void 0 === n && (n = "_last"); var r, o = t[n]; if (s) for (r = e[s]; o && o[s] > r;)o = o._prev; return o ? (e._next = o._next, o._next = e) : (e._next = t[i], t[i] = e), e._next ? e._next._prev = e : t[n] = e, e._prev = o, e.parent = e._dp = t, e }, Mt = function (t, e, i, n) { void 0 === i && (i = "_first"), void 0 === n && (n = "_last"); var s = e._prev, r = e._next; s ? s._next = r : t[i] === e && (t[i] = r), r ? r._prev = s : t[n] === e && (t[n] = s), e._next = e._prev = e.parent = null }, Dt = function (t, e) { t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t), t._act = 0 }, Rt = function (t, e) { if (t && (!e || e._end > t._dur || e._start < 0)) for (var i = t; i;)i._dirty = 1, i = i.parent; return t }, zt = function (t, e, i, n) { return t._startAt && (o ? t._startAt.revert(nt) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, n)) }, Nt = function t(e) { return !e || e._ts && t(e.parent) }, Ft = function (t) { return t._repeat ? Ht(t._tTime, t = t.duration() + t._rDelay) * t : 0 }, Ht = function (t, e) { var i = Math.floor(t = wt(t / e)); return t && i === t ? i - 1 : i }, Bt = function (t, e) { return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur) }, It = function (t) { return t._end = wt(t._start + (t._tDur / Math.abs(t._ts || t._rts || E) || 0)) }, Yt = function (t, e) { var i = t._dp; return i && i.smoothChildTiming && t._ts && (t._start = wt(i._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), It(t), i._dirty || Rt(i, t)), t }, jt = function (t, e) { var i; if ((e._time || !e._dur && e._initted || e._start < t._time && (e._dur || !e.add)) && (i = Bt(t.rawTime(), e), (!e._dur || te(0, e.totalDuration(), i) - e._tTime > E) && e.render(i, !0)), Rt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) { if (t._dur < t.duration()) for (i = t; i._dp;)i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp; t._zTime = -1e-8 } }, qt = function (t, e, i, n) { return e.parent && Dt(e), e._start = wt((R(i) ? i : i || t !== l ? Kt(t, i, e) : t._time) + e._delay), e._end = wt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), Lt(t, e, "_first", "_last", t._sort ? "_start" : 0), $t(e) || (t._recent = e), n || jt(t, e), t._ts < 0 && Yt(t, t._tTime), t }, Ut = function (t, e) { return (G.ScrollTrigger || Z("scrollTrigger", e)) && G.ScrollTrigger.create(e, t) }, Wt = function (t, e, i, n, s) { return Je(t, e, s), t._initted ? !i && t._pt && !o && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && p !== Pe.frame ? (ot.push(t), t._lazy = [s, n], 1) : void 0 : 1 }, Vt = function t(e) { var i = e.parent; return i && i._ts && i._initted && !i._lock && (i.rawTime() < 0 || t(i)) }, $t = function (t) { var e = t.data; return "isFromStart" === e || "isStart" === e }, Xt = function (t, e, i, n) { var s = t._repeat, r = wt(e) || 0, o = t._tTime / t._tDur; return o && !n && (t._time *= r / t._dur), t._dur = r, t._tDur = s ? s < 0 ? 1e10 : wt(r * (s + 1) + t._rDelay * s) : r, o > 0 && !n && Yt(t, t._tTime = t._tDur * o), t.parent && It(t), i || Rt(t.parent, t), t }, Gt = function (t) { return t instanceof Ue ? Rt(t) : Xt(t, t._dur) }, Jt = { _start: 0, endTime: et, totalDuration: et }, Kt = function t(e, i, n) { var s, r, o, a = e.labels, l = e._recent || Jt, c = e.duration() >= x ? l.endTime(!1) : e._dur; return M(i) && (isNaN(i) || i in a) ? (r = i.charAt(0), o = "%" === i.substr(-1), s = i.indexOf("="), "<" === r || ">" === r ? (s >= 0 && (i = i.replace(/=/, "")), ("<" === r ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(i.substr(1)) || 0) * (o ? (s < 0 ? l : n).totalDuration() / 100 : 1)) : s < 0 ? (i in a || (a[i] = c), a[i]) : (r = parseFloat(i.charAt(s - 1) + i.substr(s + 1)), o && n && (r = r / 100 * (Y(n) ? n[0] : n).totalDuration()), s > 1 ? t(e, i.substr(0, s - 1), n) + r : c + r)) : null == i ? c : +i }, Zt = function (t, e, i) { var n, s, r = R(e[1]), o = (r ? 2 : 1) + (t < 2 ? 0 : 1), a = e[o]; if (r && (a.duration = e[1]), a.parent = i, t) { for (n = a, s = i; s && !("immediateRender" in n);)n = s.vars.defaults || {}, s = F(s.vars.inherit) && s.parent; a.immediateRender = F(n.immediateRender), t < 2 ? a.runBackwards = 1 : a.startAt = e[o - 1] } return new ei(e[0], a, e[o + 1]) }, Qt = function (t, e) { return t || 0 === t ? e(t) : e }, te = function (t, e, i) { return i < t ? t : i > e ? e : i }, ee = function (t, e) { return M(t) && (e = X.exec(t)) ? e[1] : "" }, ie = [].slice, ne = function (t, e) { return t && N(t) && "length" in t && (!e && !t.length || t.length - 1 in t && N(t[0])) && !t.nodeType && t !== c }, se = function (t, e, i) { return void 0 === i && (i = []), t.forEach((function (t) { var n; return M(t) && !e || ne(t, 1) ? (n = i).push.apply(n, re(t)) : i.push(t) })) || i }, re = function (t, e, i) { return a && !e && a.selector ? a.selector(t) : !M(t) || i || !h && Oe() ? Y(t) ? se(t, i) : ne(t) ? ie.call(t, 0) : t ? [t] : [] : ie.call((e || u).querySelectorAll(t), 0) }, oe = function (t) { return t = re(t)[0] || Q("Invalid scope") || {}, function (e) { var i = t.current || t.nativeElement || t; return re(e, i.querySelectorAll ? i : i === t ? Q("Invalid scope") || u.createElement("div") : t) } }, ae = function (t) { return t.sort((function () { return .5 - Math.random() })) }, le = function (t) { if (D(t)) return t; var e = N(t) ? t : { each: t }, i = Fe(e.ease), n = e.from || 0, s = parseFloat(e.base) || 0, r = {}, o = n > 0 && n < 1, a = isNaN(n) || o, l = e.axis, c = n, h = n; return M(n) ? c = h = { center: .5, edges: .5, end: 1 }[n] || 0 : !o && a && (c = n[0], h = n[1]), function (t, o, u) { var d, p, f, m, g, v, w, y, _, b = (u || e).length, S = r[b]; if (!S) { if (!(_ = "auto" === e.grid ? 0 : (e.grid || [1, x])[1])) { for (w = -x; w < (w = u[_++].getBoundingClientRect().left) && _ < b;); _ < b && _-- } for (S = r[b] = [], d = a ? Math.min(_, b) * c - .5 : n % _, p = _ === x ? 0 : a ? b * h / _ - .5 : n / _ | 0, w = 0, y = x, v = 0; v < b; v++)f = v % _ - d, m = p - (v / _ | 0), S[v] = g = l ? Math.abs("y" === l ? m : f) : P(f * f + m * m), g > w && (w = g), g < y && (y = g); "random" === n && ae(S), S.max = w - y, S.min = y, S.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (_ > b ? b - 1 : l ? "y" === l ? b / _ : _ : Math.max(_, b / _)) || 0) * ("edges" === n ? -1 : 1), S.b = b < 0 ? s - b : s, S.u = ee(e.amount || e.each) || 0, i = i && b < 0 ? ze(i) : i } return b = (S[t] - S.min) / S.max || 0, wt(S.b + (i ? i(b) : b) * S.v) + S.u } }, ce = function (t) { var e = Math.pow(10, ((t + "").split(".")[1] || "").length); return function (i) { var n = wt(Math.round(parseFloat(i) / t) * t * e); return (n - n % 1) / e + (R(i) ? 0 : ee(i)) } }, he = function (t, e) { var i, n, s = Y(t); return !s && N(t) && (i = s = t.radius || x, t.values ? (t = re(t.values), (n = !R(t[0])) && (i *= i)) : t = ce(t.increment)), Qt(e, s ? D(t) ? function (e) { return n = t(e), Math.abs(n - e) <= i ? n : e } : function (e) { for (var s, r, o = parseFloat(n ? e.x : e), a = parseFloat(n ? e.y : 0), l = x, c = 0, h = t.length; h--;)(s = n ? (s = t[h].x - o) * s + (r = t[h].y - a) * r : Math.abs(t[h] - o)) < l && (l = s, c = h); return c = !i || l <= i ? t[c] : e, n || c === e || R(e) ? c : c + ee(e) } : ce(t)) }, ue = function (t, e, i, n) { return Qt(Y(t) ? !e : !0 === i ? !!(i = 0) : !n, (function () { return Y(t) ? t[~~(Math.random() * t.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((t - i / 2 + Math.random() * (e - t + .99 * i)) / i) * i * n) / n })) }, de = function (t, e, i) { return Qt(i, (function (i) { return t[~~e(i)] })) }, pe = function (t) { for (var e, i, n, s, r = 0, o = ""; ~(e = t.indexOf("random(", r));)n = t.indexOf(")", e), s = "[" === t.charAt(e + 7), i = t.substr(e + 7, n - e - 7).match(s ? $ : j), o += t.substr(r, e - r) + ue(s ? i : +i[0], s ? 0 : +i[1], +i[2] || 1e-5), r = n + 1; return o + t.substr(r, t.length - r) }, fe = function (t, e, i, n, s) { var r = e - t, o = n - i; return Qt(s, (function (e) { return i + ((e - t) / r * o || 0) })) }, me = function (t, e, i) { var n, s, r, o = t.labels, a = x; for (n in o) (s = o[n] - e) < 0 == !!i && s && a > (s = Math.abs(s)) && (r = n, a = s); return r }, ge = function (t, e, i) { var n, s, r, o = t.vars, l = o[e], c = a, h = t._ctx; if (l) return n = o[e + "Params"], s = o.callbackScope || t, i && ot.length && bt(), h && (a = h), r = n ? l.apply(s, n) : l.call(s), a = c, r }, ve = function (t) { return Dt(t), t.scrollTrigger && t.scrollTrigger.kill(!!o), t.progress() < 1 && ge(t, "onInterrupt"), t }, we = [], ye = function (t) { if (t) if (t = !t.name && t.default || t, H() || t.headless) { var e = t.name, i = D(t), n = e && !i && t.init ? function () { this._props = [] } : t, s = { init: et, render: hi, add: Xe, kill: di, modifier: ui, rawVars: 0 }, r = { targetTest: 0, get: 0, getSetter: oi, aliases: {}, register: 0 }; if (Oe(), t !== n) { if (lt[e]) return; Tt(n, Tt(Pt(t, s), r)), At(n.prototype, At(s, Pt(t, r))), lt[n.prop = e] = n, t.targetTest && (ut.push(n), rt[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin" } tt(e, n), t.register && t.register(Ci, n, mi) } else we.push(t) }, _e = 255, be = { aqua: [0, _e, _e], lime: [0, _e, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, _e], navy: [0, 0, 128], white: [_e, _e, _e], olive: [128, 128, 0], yellow: [_e, _e, 0], orange: [_e, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [_e, 0, 0], pink: [_e, 192, 203], cyan: [0, _e, _e], transparent: [_e, _e, _e, 0] }, Se = function (t, e, i) { return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) * _e + .5 | 0 }, ke = function (t, e, i) { var n, s, r, o, a, l, c, h, u, d, p = t ? R(t) ? [t >> 16, t >> 8 & _e, t & _e] : 0 : be.black; if (!p) { if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), be[t]) p = be[t]; else if ("#" === t.charAt(0)) { if (t.length < 6 && (n = t.charAt(1), s = t.charAt(2), r = t.charAt(3), t = "#" + n + n + s + s + r + r + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & _e, p & _e, parseInt(t.substr(7), 16) / 255]; p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & _e, t & _e] } else if ("hsl" === t.substr(0, 3)) if (p = d = t.match(j), e) { if (~t.indexOf("=")) return p = t.match(q), i && p.length < 4 && (p[3] = 1), p } else o = +p[0] % 360 / 360, a = +p[1] / 100, n = 2 * (l = +p[2] / 100) - (s = l <= .5 ? l * (a + 1) : l + a - l * a), p.length > 3 && (p[3] *= 1), p[0] = Se(o + 1 / 3, n, s), p[1] = Se(o, n, s), p[2] = Se(o - 1 / 3, n, s); else p = t.match(j) || be.transparent; p = p.map(Number) } return e && !d && (n = p[0] / _e, s = p[1] / _e, r = p[2] / _e, l = ((c = Math.max(n, s, r)) + (h = Math.min(n, s, r))) / 2, c === h ? o = a = 0 : (u = c - h, a = l > .5 ? u / (2 - c - h) : u / (c + h), o = c === n ? (s - r) / u + (s < r ? 6 : 0) : c === s ? (r - n) / u + 2 : (n - s) / u + 4, o *= 60), p[0] = ~~(o + .5), p[1] = ~~(100 * a + .5), p[2] = ~~(100 * l + .5)), i && p.length < 4 && (p[3] = 1), p }, xe = function (t) { var e = [], i = [], n = -1; return t.split(Te).forEach((function (t) { var s = t.match(U) || []; e.push.apply(e, s), i.push(n += s.length + 1) })), e.c = i, e }, Ee = function (t, e, i) { var n, s, r, o, a = "", l = (t + a).match(Te), c = e ? "hsla(" : "rgba(", h = 0; if (!l) return t; if (l = l.map((function (t) { return (t = ke(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")" })), i && (r = xe(t), (n = i.c).join(a) !== r.c.join(a))) for (o = (s = t.replace(Te, "1").split(U)).length - 1; h < o; h++)a += s[h] + (~n.indexOf(h) ? l.shift() || c + "0,0,0,0)" : (r.length ? r : l.length ? l : i).shift()); if (!s) for (o = (s = t.split(Te)).length - 1; h < o; h++)a += s[h] + l[h]; return a + s[o] }, Te = function () { var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b"; for (t in be) e += "|" + t + "\\b"; return new RegExp(e + ")", "gi") }(), Ae = /hsl[a]?\(/, Ce = function (t) { var e, i = t.join(" "); if (Te.lastIndex = 0, Te.test(i)) return e = Ae.test(i), t[1] = Ee(t[1], e), t[0] = Ee(t[0], e, xe(t[1])), !0 }, Pe = function () { var t, e, i, n, s, r, o = Date.now, a = 500, l = 33, p = o(), f = p, g = 1e3 / 240, v = g, w = [], y = function i(c) { var h, u, d, m, y = o() - f, _ = !0 === c; if ((y > a || y < 0) && (p += y - l), ((h = (d = (f += y) - p) - v) > 0 || _) && (m = ++n.frame, s = d - 1e3 * n.time, n.time = d /= 1e3, v += h + (h >= g ? 4 : g - h), u = 1), _ || (t = e(i)), u) for (r = 0; r < w.length; r++)w[r](d, s, m, c) }; return n = { time: 0, frame: 0, tick: function () { y(!0) }, deltaRatio: function (t) { return s / (1e3 / (t || 60)) }, wake: function () { d && (!h && H() && (c = h = window, u = c.document || {}, G.gsap = Ci, (c.gsapVersions || (c.gsapVersions = [])).push(Ci.version), K(J || c.GreenSockGlobals || !c.gsap && c || {}), we.forEach(ye)), i = "undefined" != typeof requestAnimationFrame && requestAnimationFrame, t && n.sleep(), e = i || function (t) { return setTimeout(t, v - 1e3 * n.time + 1 | 0) }, m = 1, y(2)) }, sleep: function () { (i ? cancelAnimationFrame : clearTimeout)(t), m = 0, e = et }, lagSmoothing: function (t, e) { a = t || 1 / 0, l = Math.min(e || 33, a) }, fps: function (t) { g = 1e3 / (t || 240), v = 1e3 * n.time + g }, add: function (t, e, i) { var s = e ? function (e, i, r, o) { t(e, i, r, o), n.remove(s) } : t; return n.remove(t), w[i ? "unshift" : "push"](s), Oe(), s }, remove: function (t, e) { ~(e = w.indexOf(t)) && w.splice(e, 1) && r >= e && r-- }, _listeners: w } }(), Oe = function () { return !m && Pe.wake() }, Le = {}, Me = /^[\d.\-M][\d.\-,\s]/, De = /["']/g, Re = function (t) { for (var e, i, n, s = {}, r = t.substr(1, t.length - 3).split(":"), o = r[0], a = 1, l = r.length; a < l; a++)i = r[a], e = a !== l - 1 ? i.lastIndexOf(",") : i.length, n = i.substr(0, e), s[o] = isNaN(n) ? n.replace(De, "").trim() : +n, o = i.substr(e + 1).trim(); return s }, ze = function (t) { return function (e) { return 1 - t(1 - e) } }, Ne = function t(e, i) { for (var n, s = e._first; s;)s instanceof Ue ? t(s, i) : !s.vars.yoyoEase || s._yoyo && s._repeat || s._yoyo === i || (s.timeline ? t(s.timeline, i) : (n = s._ease, s._ease = s._yEase, s._yEase = n, s._yoyo = i)), s = s._next }, Fe = function (t, e) { return t && (D(t) ? t : Le[t] || function (t) { var e, i, n, s, r = (t + "").split("("), o = Le[r[0]]; return o && r.length > 1 && o.config ? o.config.apply(null, ~t.indexOf("{") ? [Re(r[1])] : (e = t, i = e.indexOf("(") + 1, n = e.indexOf(")"), s = e.indexOf("(", i), e.substring(i, ~s && s < n ? e.indexOf(")", n + 1) : n)).split(",").map(xt)) : Le._CE && Me.test(t) ? Le._CE("", t) : o }(t)) || e }, He = function (t, e, i, n) { void 0 === i && (i = function (t) { return 1 - e(1 - t) }), void 0 === n && (n = function (t) { return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2 }); var s, r = { easeIn: e, easeOut: i, easeInOut: n }; return gt(t, (function (t) { for (var e in Le[t] = G[t] = r, Le[s = t.toLowerCase()] = i, r) Le[s + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Le[t + "." + e] = r[e] })), r }, Be = function (t) { return function (e) { return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2 } }, Ie = function t(e, i, n) { var s = i >= 1 ? i : 1, r = (n || (e ? .3 : .45)) / (i < 1 ? i : 1), o = r / T * (Math.asin(1 / s) || 0), a = function (t) { return 1 === t ? 1 : s * Math.pow(2, -10 * t) * L((t - o) * r) + 1 }, l = "out" === e ? a : "in" === e ? function (t) { return 1 - a(1 - t) } : Be(a); return r = T / r, l.config = function (i, n) { return t(e, i, n) }, l }, Ye = function t(e, i) { void 0 === i && (i = 1.70158); var n = function (t) { return t ? --t * t * ((i + 1) * t + i) + 1 : 0 }, s = "out" === e ? n : "in" === e ? function (t) { return 1 - n(1 - t) } : Be(n); return s.config = function (i) { return t(e, i) }, s }; gt("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) { var i = e < 5 ? e + 1 : e; He(t + ",Power" + (i - 1), e ? function (t) { return Math.pow(t, i) } : function (t) { return t }, (function (t) { return 1 - Math.pow(1 - t, i) }), (function (t) { return t < .5 ? Math.pow(2 * t, i) / 2 : 1 - Math.pow(2 * (1 - t), i) / 2 })) })), Le.Linear.easeNone = Le.none = Le.Linear.easeIn, He("Elastic", Ie("in"), Ie("out"), Ie()), g = 7.5625, y = 2 * (w = 1 / (v = 2.75)), _ = 2.5 * w, He("Bounce", (function (t) { return 1 - b(1 - t) }), b = function (t) { return t < w ? g * t * t : t < y ? g * Math.pow(t - 1.5 / v, 2) + .75 : t < _ ? g * (t -= 2.25 / v) * t + .9375 : g * Math.pow(t - 2.625 / v, 2) + .984375 }), He("Expo", (function (t) { return Math.pow(2, 10 * (t - 1)) * t + t * t * t * t * t * t * (1 - t) })), He("Circ", (function (t) { return -(P(1 - t * t) - 1) })), He("Sine", (function (t) { return 1 === t ? 1 : 1 - O(t * A) })), He("Back", Ye("in"), Ye("out"), Ye()), Le.SteppedEase = Le.steps = G.SteppedEase = { config: function (t, e) { void 0 === t && (t = 1); var i = 1 / t, n = t + (e ? 0 : 1), s = e ? 1 : 0; return function (t) { return ((n * te(0, .99999999, t) | 0) + s) * i } } }, k.ease = Le["quad.out"], gt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) { return dt += t + "," + t + "Params," })); var je = function (t, e) { this.id = C++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : mt, this.set = e ? e.getSetter : oi }, qe = function () { function t(t) { this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Xt(this, +t.duration, 1, 1), this.data = t.data, a && (this._ctx = a, a.data.push(this)), m || Pe.wake() } var e = t.prototype; return e.delay = function (t) { return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay }, e.duration = function (t) { return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur }, e.totalDuration = function (t) { return arguments.length ? (this._dirty = 0, Xt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, e.totalTime = function (t, e) { if (Oe(), !arguments.length) return this._tTime; var i = this._dp; if (i && i.smoothChildTiming && this._ts) { for (Yt(this, t), !i._dp || i.parent || jt(i, this); i && i.parent;)i.parent._time !== i._start + (i._ts >= 0 ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0), i = i.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && qt(this._dp, this, this._start - this._delay) } return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === E || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), kt(this, t, e)), this }, e.time = function (t, e) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Ft(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time }, e.totalProgress = function (t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0 }, e.progress = function (t, e) { return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Ft(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0 }, e.iteration = function (t, e) { var i = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (t - 1) * i, e) : this._repeat ? Ht(this._tTime, i) + 1 : 1 }, e.timeScale = function (t, e) { if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts; if (this._rts === t) return this; var i = this.parent && this._ts ? Bt(this.parent._time, this) : this._tTime; return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, this.totalTime(te(-Math.abs(this._delay), this.totalDuration(), i), !1 !== e), It(this), function (t) { for (var e = t.parent; e && e.parent;)e._dirty = 1, e.totalDuration(), e = e.parent; return t }(this) }, e.paused = function (t) { return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Oe(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== E && (this._tTime -= E)))), this) : this._ps }, e.startTime = function (t) { if (arguments.length) { this._start = t; var e = this.parent || this._dp; return e && (e._sort || !this.parent) && qt(e, this, t - this._delay), this } return this._start }, e.endTime = function (t) { return this._start + (F(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, e.rawTime = function (t) { var e = this.parent || this._dp; return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Bt(e.rawTime(t), this) : this._tTime : this._tTime }, e.revert = function (t) { void 0 === t && (t = st); var e = o; return o = t, St(this) && (this.timeline && this.timeline.revert(t), this.totalTime(-.01, t.suppressEvents)), "nested" !== this.data && !1 !== t.kill && this.kill(), o = e, this }, e.globalTime = function (t) { for (var e = this, i = arguments.length ? t : e.rawTime(); e;)i = e._start + i / (Math.abs(e._ts) || 1), e = e._dp; return !this.parent && this._sat ? this._sat.globalTime(t) : i }, e.repeat = function (t) { return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, Gt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat }, e.repeatDelay = function (t) { if (arguments.length) { var e = this._time; return this._rDelay = t, Gt(this), e ? this.time(e) : this } return this._rDelay }, e.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, e.seek = function (t, e) { return this.totalTime(Kt(this, t), F(e)) }, e.restart = function (t, e) { return this.play().totalTime(t ? -this._delay : 0, F(e)), this._dur || (this._zTime = -1e-8), this }, e.play = function (t, e) { return null != t && this.seek(t, e), this.reversed(!1).paused(!1) }, e.reverse = function (t, e) { return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, e.pause = function (t, e) { return null != t && this.seek(t, e), this.paused(!0) }, e.resume = function () { return this.paused(!1) }, e.reversed = function (t) { return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0 }, e.invalidate = function () { return this._initted = this._act = 0, this._zTime = -1e-8, this }, e.isActive = function () { var t, e = this.parent || this._dp, i = this._start; return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= i && t < this.endTime(!0) - E)) }, e.eventCallback = function (t, e, i) { var n = this.vars; return arguments.length > 1 ? (e ? (n[t] = e, i && (n[t + "Params"] = i), "onUpdate" === t && (this._onUpdate = e)) : delete n[t], this) : n[t] }, e.then = function (t) { var e = this; return new Promise((function (i) { var n = D(t) ? t : Et, s = function () { var t = e.then; e.then = null, D(n) && (n = n(e)) && (n.then || n === e) && (e.then = t), i(n), e.then = t }; e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? s() : e._prom = s })) }, e.kill = function () { ve(this) }, t }(); Tt(qe.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: !1, _rts: 1 }); var Ue = function (t) { function e(e, i) { var s; return void 0 === e && (e = {}), (s = t.call(this, e) || this).labels = {}, s.smoothChildTiming = !!e.smoothChildTiming, s.autoRemoveChildren = !!e.autoRemoveChildren, s._sort = F(e.sortChildren), l && qt(e.parent || l, n(s), i), e.reversed && s.reverse(), e.paused && s.paused(!0), e.scrollTrigger && Ut(n(s), e.scrollTrigger), s } s(e, t); var i = e.prototype; return i.to = function (t, e, i) { return Zt(0, arguments, this), this }, i.from = function (t, e, i) { return Zt(1, arguments, this), this }, i.fromTo = function (t, e, i, n) { return Zt(2, arguments, this), this }, i.set = function (t, e, i) { return e.duration = 0, e.parent = this, Ot(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new ei(t, e, Kt(this, i), 1), this }, i.call = function (t, e, i) { return qt(this, ei.delayedCall(0, t, e), i) }, i.staggerTo = function (t, e, i, n, s, r, o) { return i.duration = e, i.stagger = i.stagger || n, i.onComplete = r, i.onCompleteParams = o, i.parent = this, new ei(t, i, Kt(this, s)), this }, i.staggerFrom = function (t, e, i, n, s, r, o) { return i.runBackwards = 1, Ot(i).immediateRender = F(i.immediateRender), this.staggerTo(t, e, i, n, s, r, o) }, i.staggerFromTo = function (t, e, i, n, s, r, o, a) { return n.startAt = i, Ot(n).immediateRender = F(n.immediateRender), this.staggerTo(t, e, n, s, r, o, a) }, i.render = function (t, e, i) { var n, s, r, a, c, h, u, d, p, f, m, g, v = this._time, w = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, _ = t <= 0 ? 0 : wt(t), b = this._zTime < 0 != t < 0 && (this._initted || !y); if (this !== l && _ > w && t >= 0 && (_ = w), _ !== this._tTime || i || b) { if (v !== this._time && y && (_ += this._time - v, t += this._time - v), n = _, p = this._start, h = !(d = this._ts), b && (y || (v = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) { if (m = this._yoyo, c = y + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * c + t, e, i); if (n = wt(_ % c), _ === w ? (a = this._repeat, n = y) : ((a = ~~(f = wt(_ / c))) && a === f && (n = y, a--), n > y && (n = y)), f = Ht(this._tTime, c), !v && this._tTime && f !== a && this._tTime - f * c - this._dur <= 0 && (f = a), m && 1 & a && (n = y - n, g = 1), a !== f && !this._lock) { var S = m && 1 & f, k = S === (m && 1 & a); if (a < f && (S = !S), v = S ? 0 : _ % y ? y : _, this._lock = 1, this.render(v || (g ? 0 : wt(a * c)), e, !y)._lock = 0, this._tTime = _, !e && this.parent && ge(this, "onRepeat"), this.vars.repeatRefresh && !g && (this.invalidate()._lock = 1), v && v !== this._time || h !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (y = this._dur, w = this._tDur, k && (this._lock = 2, v = S ? y : -1e-4, this.render(v, !0), this.vars.repeatRefresh && !g && this.invalidate()), this._lock = 0, !this._ts && !h) return this; Ne(this, g) } } if (this._hasPause && !this._forcing && this._lock < 2 && (u = function (t, e, i) { var n; if (i > e) for (n = t._first; n && n._start <= i;) { if ("isPause" === n.data && n._start > e) return n; n = n._next } else for (n = t._last; n && n._start >= i;) { if ("isPause" === n.data && n._start < e) return n; n = n._prev } }(this, wt(v), wt(n)), u && (_ -= n - (n = u._start))), this._tTime = _, this._time = n, this._act = !d, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, v = 0), !v && _ && !e && !f && (ge(this, "onStart"), this._tTime !== _)) return this; if (n >= v && t >= 0) for (s = this._first; s;) { if (r = s._next, (s._act || n >= s._start) && s._ts && u !== s) { if (s.parent !== this) return this.render(t, e, i); if (s.render(s._ts > 0 ? (n - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (n - s._start) * s._ts, e, i), n !== this._time || !this._ts && !h) { u = 0, r && (_ += this._zTime = -1e-8); break } } s = r } else { s = this._last; for (var x = t < 0 ? t : n; s;) { if (r = s._prev, (s._act || x <= s._end) && s._ts && u !== s) { if (s.parent !== this) return this.render(t, e, i); if (s.render(s._ts > 0 ? (x - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (x - s._start) * s._ts, e, i || o && St(s)), n !== this._time || !this._ts && !h) { u = 0, r && (_ += this._zTime = x ? -1e-8 : E); break } } s = r } } if (u && !e && (this.pause(), u.render(n >= v ? 0 : -1e-8)._zTime = n >= v ? 1 : -1, this._ts)) return this._start = p, It(this), this.render(t, e, i); this._onUpdate && !e && ge(this, "onUpdate", !0), (_ === w && this._tTime >= this.totalDuration() || !_ && v) && (p !== this._start && Math.abs(d) === Math.abs(this._ts) || this._lock || ((t || !y) && (_ === w && this._ts > 0 || !_ && this._ts < 0) && Dt(this, 1), e || t < 0 && !v || !_ && !v && w || (ge(this, _ === w && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(_ < w && this.timeScale() > 0) && this._prom()))) } return this }, i.add = function (t, e) { var i = this; if (R(e) || (e = Kt(this, e, t)), !(t instanceof qe)) { if (Y(t)) return t.forEach((function (t) { return i.add(t, e) })), this; if (M(t)) return this.addLabel(t, e); if (!D(t)) return this; t = ei.delayedCall(0, t) } return this !== t ? qt(this, t, e) : this }, i.getChildren = function (t, e, i, n) { void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = -x); for (var s = [], r = this._first; r;)r._start >= n && (r instanceof ei ? e && s.push(r) : (i && s.push(r), t && s.push.apply(s, r.getChildren(!0, e, i)))), r = r._next; return s }, i.getById = function (t) { for (var e = this.getChildren(1, 1, 1), i = e.length; i--;)if (e[i].vars.id === t) return e[i] }, i.remove = function (t) { return M(t) ? this.removeLabel(t) : D(t) ? this.killTweensOf(t) : (t.parent === this && Mt(this, t), t === this._recent && (this._recent = this._last), Rt(this)) }, i.totalTime = function (e, i) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = wt(Pe.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, i), this._forcing = 0, this) : this._tTime }, i.addLabel = function (t, e) { return this.labels[t] = Kt(this, e), this }, i.removeLabel = function (t) { return delete this.labels[t], this }, i.addPause = function (t, e, i) { var n = ei.delayedCall(0, e || et, i); return n.data = "isPause", this._hasPause = 1, qt(this, n, Kt(this, t)) }, i.removePause = function (t) { var e = this._first; for (t = Kt(this, t); e;)e._start === t && "isPause" === e.data && Dt(e), e = e._next }, i.killTweensOf = function (t, e, i) { for (var n = this.getTweensOf(t, i), s = n.length; s--;)We !== n[s] && n[s].kill(t, e); return this }, i.getTweensOf = function (t, e) { for (var i, n = [], s = re(t), r = this._first, o = R(e); r;)r instanceof ei ? _t(r._targets, s) && (o ? (!We || r._initted && r._ts) && r.globalTime(0) <= e && r.globalTime(r.totalDuration()) > e : !e || r.isActive()) && n.push(r) : (i = r.getTweensOf(s, e)).length && n.push.apply(n, i), r = r._next; return n }, i.tweenTo = function (t, e) { e = e || {}; var i, n = this, s = Kt(n, t), r = e, o = r.startAt, a = r.onStart, l = r.onStartParams, c = r.immediateRender, h = ei.to(n, Tt({ ease: e.ease || "none", lazy: !1, immediateRender: !1, time: s, overwrite: "auto", duration: e.duration || Math.abs((s - (o && "time" in o ? o.time : n._time)) / n.timeScale()) || E, onStart: function () { if (n.pause(), !i) { var t = e.duration || Math.abs((s - (o && "time" in o ? o.time : n._time)) / n.timeScale()); h._dur !== t && Xt(h, t, 0, 1).render(h._time, !0, !0), i = 1 } a && a.apply(h, l || []) } }, e)); return c ? h.render(0) : h }, i.tweenFromTo = function (t, e, i) { return this.tweenTo(e, Tt({ startAt: { time: Kt(this, t) } }, i)) }, i.recent = function () { return this._recent }, i.nextLabel = function (t) { return void 0 === t && (t = this._time), me(this, Kt(this, t)) }, i.previousLabel = function (t) { return void 0 === t && (t = this._time), me(this, Kt(this, t), 1) }, i.currentLabel = function (t) { return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + E) }, i.shiftChildren = function (t, e, i) { void 0 === i && (i = 0); for (var n, s = this._first, r = this.labels; s;)s._start >= i && (s._start += t, s._end += t), s = s._next; if (e) for (n in r) r[n] >= i && (r[n] += t); return Rt(this) }, i.invalidate = function (e) { var i = this._first; for (this._lock = 0; i;)i.invalidate(e), i = i._next; return t.prototype.invalidate.call(this, e) }, i.clear = function (t) { void 0 === t && (t = !0); for (var e, i = this._first; i;)e = i._next, this.remove(i), i = e; return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Rt(this) }, i.totalDuration = function (t) { var e, i, n, s = 0, r = this, o = r._last, a = x; if (arguments.length) return r.timeScale((r._repeat < 0 ? r.duration() : r.totalDuration()) / (r.reversed() ? -t : t)); if (r._dirty) { for (n = r.parent; o;)e = o._prev, o._dirty && o.totalDuration(), (i = o._start) > a && r._sort && o._ts && !r._lock ? (r._lock = 1, qt(r, o, i - o._delay, 1)._lock = 0) : a = i, i < 0 && o._ts && (s -= i, (!n && !r._dp || n && n.smoothChildTiming) && (r._start += i / r._ts, r._time -= i, r._tTime -= i), r.shiftChildren(-i, !1, -Infinity), a = 0), o._end > s && o._ts && (s = o._end), o = e; Xt(r, r === l && r._time > s ? r._time : s, 1, 1), r._dirty = 0 } return r._tDur }, e.updateRoot = function (t) { if (l._ts && (kt(l, Bt(t, l)), p = Pe.frame), Pe.frame >= ht) { ht += S.autoSleep || 120; var e = l._first; if ((!e || !e._ts) && S.autoSleep && Pe._listeners.length < 2) { for (; e && !e._ts;)e = e._next; e || Pe.sleep() } } }, e }(qe); Tt(Ue.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var We, Ve, $e = function (t, e, i, n, s, r, o) { var a, l, c, h, u, d, p, f, m = new mi(this._pt, t, e, 0, 1, ci, null, s), g = 0, v = 0; for (m.b = i, m.e = n, i += "", (p = ~(n += "").indexOf("random(")) && (n = pe(n)), r && (r(f = [i, n], t, e), i = f[0], n = f[1]), l = i.match(W) || []; a = W.exec(n);)h = a[0], u = n.substring(g, a.index), c ? c = (c + 1) % 5 : "rgba(" === u.substr(-5) && (c = 1), h !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = { _next: m._pt, p: u || 1 === v ? u : ",", s: d, c: "=" === h.charAt(1) ? yt(d, h) - d : parseFloat(h) - d, m: c && c < 4 ? Math.round : 0 }, g = W.lastIndex); return m.c = g < n.length ? n.substring(g, n.length) : "", m.fp = o, (V.test(n) || p) && (m.e = 0), this._pt = m, m }, Xe = function (t, e, i, n, s, r, o, a, l, c) { D(n) && (n = n(s || 0, t, r)); var h, u = t[e], d = "get" !== i ? i : D(u) ? l ? t[e.indexOf("set") || !D(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u, p = D(u) ? l ? si : ni : ii; if (M(n) && (~n.indexOf("random(") && (n = pe(n)), "=" === n.charAt(1) && ((h = yt(d, n) + (ee(d) || 0)) || 0 === h) && (n = h)), !c || d !== n || Ve) return isNaN(d * n) || "" === n ? (!u && !(e in t) && Z(e, n), $e.call(this, t, e, d, n, p, a || S.stringFilter, l)) : (h = new mi(this._pt, t, e, +d || 0, n - (d || 0), "boolean" == typeof u ? li : ai, 0, p), l && (h.fp = l), o && h.modifier(o, this, t), this._pt = h) }, Ge = function (t, e, i, n, s, r) { var o, a, l, c; if (lt[t] && !1 !== (o = new lt[t]).init(s, o.rawVars ? e[t] : function (t, e, i, n, s) { if (D(t) && (t = Ze(t, s, e, i, n)), !N(t) || t.style && t.nodeType || Y(t) || I(t)) return M(t) ? Ze(t, s, e, i, n) : t; var r, o = {}; for (r in t) o[r] = Ze(t[r], s, e, i, n); return o }(e[t], n, s, r, i), i, n, r) && (i._pt = a = new mi(i._pt, s, t, 0, 1, o.render, o, 0, o.priority), i !== f)) for (l = i._ptLookup[i._targets.indexOf(s)], c = o._props.length; c--;)l[o._props[c]] = a; return o }, Je = function t(e, i, n) { var s, a, c, h, u, d, p, f, m, g, v, w, y, _ = e.vars, b = _.ease, S = _.startAt, T = _.immediateRender, A = _.lazy, C = _.onUpdate, P = _.runBackwards, O = _.yoyoEase, L = _.keyframes, M = _.autoRevert, D = e._dur, R = e._startAt, z = e._targets, N = e.parent, H = N && "nested" === N.data ? N.vars.targets : z, B = "auto" === e._overwrite && !r, I = e.timeline; if (I && (!L || !b) && (b = "none"), e._ease = Fe(b, k.ease), e._yEase = O ? ze(Fe(!0 === O ? b : O, k.ease)) : 0, O && e._yoyo && !e._repeat && (O = e._yEase, e._yEase = e._ease, e._ease = O), e._from = !I && !!_.runBackwards, !I || L && !_.stagger) { if (w = (f = z[0] ? ft(z[0]).harness : 0) && _[f.prop], s = Pt(_, rt), R && (R._zTime < 0 && R.progress(1), i < 0 && P && T && !M ? R.render(-1, !0) : R.revert(P && D ? nt : it), R._lazy = 0), S) { if (Dt(e._startAt = ei.set(z, Tt({ data: "isStart", overwrite: !1, parent: N, immediateRender: !0, lazy: !R && F(A), startAt: null, delay: 0, onUpdate: C && function () { return ge(e, "onUpdate") }, stagger: 0 }, S))), e._startAt._dp = 0, e._startAt._sat = e, i < 0 && (o || !T && !M) && e._startAt.revert(nt), T && D && i <= 0 && n <= 0) return void (i && (e._zTime = i)) } else if (P && D && !R) if (i && (T = !1), c = Tt({ overwrite: !1, data: "isFromStart", lazy: T && !R && F(A), immediateRender: T, stagger: 0, parent: N }, s), w && (c[f.prop] = w), Dt(e._startAt = ei.set(z, c)), e._startAt._dp = 0, e._startAt._sat = e, i < 0 && (o ? e._startAt.revert(nt) : e._startAt.render(-1, !0)), e._zTime = i, T) { if (!i) return } else t(e._startAt, E, E); for (e._pt = e._ptCache = 0, A = D && F(A) || A && !D, a = 0; a < z.length; a++) { if (p = (u = z[a])._gsap || pt(z)[a]._gsap, e._ptLookup[a] = g = {}, at[p.id] && ot.length && bt(), v = H === z ? a : H.indexOf(u), f && !1 !== (m = new f).init(u, w || s, e, v, H) && (e._pt = h = new mi(e._pt, u, m.name, 0, 1, m.render, m, 0, m.priority), m._props.forEach((function (t) { g[t] = h })), m.priority && (d = 1)), !f || w) for (c in s) lt[c] && (m = Ge(c, s, e, v, u, H)) ? m.priority && (d = 1) : g[c] = h = Xe.call(e, u, c, "get", s[c], v, H, 0, _.stringFilter); e._op && e._op[a] && e.kill(u, e._op[a]), B && e._pt && (We = e, l.killTweensOf(u, g, e.globalTime(i)), y = !e.parent, We = 0), e._pt && A && (at[p.id] = 1) } d && fi(e), e._onInit && e._onInit(e) } e._onUpdate = C, e._initted = (!e._op || e._pt) && !y, L && i <= 0 && I.render(x, !0, !0) }, Ke = function (t, e, i, n) { var s, r, o = e.ease || n || "power1.inOut"; if (Y(e)) r = i[t] || (i[t] = []), e.forEach((function (t, i) { return r.push({ t: i / (e.length - 1) * 100, v: t, e: o }) })); else for (s in e) r = i[s] || (i[s] = []), "ease" === s || r.push({ t: parseFloat(t), v: e[s], e: o }) }, Ze = function (t, e, i, n, s) { return D(t) ? t.call(e, i, n, s) : M(t) && ~t.indexOf("random(") ? pe(t) : t }, Qe = dt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", ti = {}; gt(Qe + ",id,stagger,delay,duration,paused,scrollTrigger", (function (t) { return ti[t] = 1 })); var ei = function (t) { function e(e, i, s, o) { var a; "number" == typeof i && (s.duration = i, i = s, s = null); var c, h, u, d, p, f, m, g, v = (a = t.call(this, o ? i : Ot(i)) || this).vars, w = v.duration, y = v.delay, _ = v.immediateRender, b = v.stagger, k = v.overwrite, x = v.keyframes, E = v.defaults, T = v.scrollTrigger, A = v.yoyoEase, C = i.parent || l, P = (Y(e) || I(e) ? R(e[0]) : "length" in i) ? [e] : re(e); if (a._targets = P.length ? pt(P) : Q("GSAP target " + e + " not found. https://gsap.com", !S.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = k, x || b || B(w) || B(y)) { if (i = a.vars, (c = a.timeline = new Ue({ data: "nested", defaults: E || {}, targets: C && "nested" === C.data ? C.vars.targets : P })).kill(), c.parent = c._dp = n(a), c._start = 0, b || B(w) || B(y)) { if (d = P.length, m = b && le(b), N(b)) for (p in b) ~Qe.indexOf(p) && (g || (g = {}), g[p] = b[p]); for (h = 0; h < d; h++)(u = Pt(i, ti)).stagger = 0, A && (u.yoyoEase = A), g && At(u, g), f = P[h], u.duration = +Ze(w, n(a), h, f, P), u.delay = (+Ze(y, n(a), h, f, P) || 0) - a._delay, !b && 1 === d && u.delay && (a._delay = y = u.delay, a._start += y, u.delay = 0), c.to(f, u, m ? m(h, f, P) : 0), c._ease = Le.none; c.duration() ? w = y = 0 : a.timeline = 0 } else if (x) { Ot(Tt(c.vars.defaults, { ease: "none" })), c._ease = Fe(x.ease || i.ease || "none"); var O, L, M, D = 0; if (Y(x)) x.forEach((function (t) { return c.to(P, t, ">") })), c.duration(); else { for (p in u = {}, x) "ease" === p || "easeEach" === p || Ke(p, x[p], u, x.easeEach); for (p in u) for (O = u[p].sort((function (t, e) { return t.t - e.t })), D = 0, h = 0; h < O.length; h++)(M = { ease: (L = O[h]).e, duration: (L.t - (h ? O[h - 1].t : 0)) / 100 * w })[p] = L.v, c.to(P, M, D), D += M.duration; c.duration() < w && c.to({}, { duration: w - c.duration() }) } } w || a.duration(w = c.duration()) } else a.timeline = 0; return !0 !== k || r || (We = n(a), l.killTweensOf(P), We = 0), qt(C, n(a), s), i.reversed && a.reverse(), i.paused && a.paused(!0), (_ || !w && !x && a._start === wt(C._time) && F(_) && Nt(n(a)) && "nested" !== C.data) && (a._tTime = -1e-8, a.render(Math.max(0, -y) || 0)), T && Ut(n(a), T), a } s(e, t); var i = e.prototype; return i.render = function (t, e, i) { var n, s, r, a, l, c, h, u, d, p = this._time, f = this._tDur, m = this._dur, g = t < 0, v = t > f - E && !g ? f : t < E ? 0 : t; if (m) { if (v !== this._tTime || !t || i || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g || this._lazy) { if (n = v, u = this.timeline, this._repeat) { if (a = m + this._rDelay, this._repeat < -1 && g) return this.totalTime(100 * a + t, e, i); if (n = wt(v % a), v === f ? (r = this._repeat, n = m) : (r = ~~(l = wt(v / a))) && r === l ? (n = m, r--) : n > m && (n = m), (c = this._yoyo && 1 & r) && (d = this._yEase, n = m - n), l = Ht(this._tTime, a), n === p && !i && this._initted && r === l) return this._tTime = v, this; r !== l && (u && this._yEase && Ne(u, c), this.vars.repeatRefresh && !c && !this._lock && n !== a && this._initted && (this._lock = i = 1, this.render(wt(a * r), !0).invalidate()._lock = 0)) } if (!this._initted) { if (Wt(this, g ? t : n, i, e, v)) return this._tTime = 0, this; if (!(p === this._time || i && this.vars.repeatRefresh && r !== l)) return this; if (m !== this._dur) return this.render(t, e, i) } if (this._tTime = v, this._time = n, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = h = (d || this._ease)(n / m), this._from && (this.ratio = h = 1 - h), !p && v && !e && !l && (ge(this, "onStart"), this._tTime !== v)) return this; for (s = this._pt; s;)s.r(h, s.d), s = s._next; u && u.render(t < 0 ? t : u._dur * u._ease(n / this._dur), e, i) || this._startAt && (this._zTime = t), this._onUpdate && !e && (g && zt(this, t, 0, i), ge(this, "onUpdate")), this._repeat && r !== l && this.vars.onRepeat && !e && this.parent && ge(this, "onRepeat"), v !== this._tDur && v || this._tTime !== v || (g && !this._onUpdate && zt(this, t, 0, !0), (t || !m) && (v === this._tDur && this._ts > 0 || !v && this._ts < 0) && Dt(this, 1), e || g && !p || !(v || p || c) || (ge(this, v === f ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < f && this.timeScale() > 0) && this._prom())) } } else !function (t, e, i, n) { var s, r, a, l = t.ratio, c = e < 0 || !e && (!t._start && Vt(t) && (t._initted || !$t(t)) || (t._ts < 0 || t._dp._ts < 0) && !$t(t)) ? 0 : 1, h = t._rDelay, u = 0; if (h && t._repeat && (u = te(0, t._tDur, e), r = Ht(u, h), t._yoyo && 1 & r && (c = 1 - c), r !== Ht(t._tTime, h) && (l = 1 - c, t.vars.repeatRefresh && t._initted && t.invalidate())), c !== l || o || n || t._zTime === E || !e && t._zTime) { if (!t._initted && Wt(t, e, n, i, u)) return; for (a = t._zTime, t._zTime = e || (i ? E : 0), i || (i = e && !a), t.ratio = c, t._from && (c = 1 - c), t._time = 0, t._tTime = u, s = t._pt; s;)s.r(c, s.d), s = s._next; e < 0 && zt(t, e, 0, !0), t._onUpdate && !i && ge(t, "onUpdate"), u && t._repeat && !i && t.parent && ge(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === c && (c && Dt(t, 1), i || o || (ge(t, c ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom())) } else t._zTime || (t._zTime = e) }(this, t, e, i); return this }, i.targets = function () { return this._targets }, i.invalidate = function (e) { return (!e || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(e), t.prototype.invalidate.call(this, e) }, i.resetTo = function (t, e, i, n, s) { m || Pe.wake(), this._ts || this.play(); var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts); return this._initted || Je(this, r), function (t, e, i, n, s, r, o, a) { var l, c, h, u, d = (t._pt && t._ptCache || (t._ptCache = {}))[e]; if (!d) for (d = t._ptCache[e] = [], h = t._ptLookup, u = t._targets.length; u--;) { if ((l = h[u][e]) && l.d && l.d._pt) for (l = l.d._pt; l && l.p !== e && l.fp !== e;)l = l._next; if (!l) return Ve = 1, t.vars[e] = "+=0", Je(t, o), Ve = 0, a ? Q(e + " not eligible for reset") : 1; d.push(l) } for (u = d.length; u--;)(l = (c = d[u])._pt || c).s = !n && 0 !== n || s ? l.s + (n || 0) + r * l.c : n, l.c = i - l.s, c.e && (c.e = vt(i) + ee(c.e)), c.b && (c.b = l.s + ee(c.b)) }(this, t, e, i, n, this._ease(r / this._dur), r, s) ? this.resetTo(t, e, i, n, 1) : (Yt(this, 0), this.parent || Lt(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, i.kill = function (t, e) { if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? ve(this) : this.scrollTrigger && this.scrollTrigger.kill(!!o), this; if (this.timeline) { var i = this.timeline.totalDuration(); return this.timeline.killTweensOf(t, e, We && !0 !== We.vars.overwrite)._first || ve(this), this.parent && i !== this.timeline.totalDuration() && Xt(this, this._dur * this.timeline._tDur / i, 0, 1), this } var n, s, r, a, l, c, h, u = this._targets, d = t ? re(t) : u, p = this._ptLookup, f = this._pt; if ((!e || "all" === e) && function (t, e) { for (var i = t.length, n = i === e.length; n && i-- && t[i] === e[i];); return i < 0 }(u, d)) return "all" === e && (this._pt = 0), ve(this); for (n = this._op = this._op || [], "all" !== e && (M(e) && (l = {}, gt(e, (function (t) { return l[t] = 1 })), e = l), e = function (t, e) { var i, n, s, r, o = t[0] ? ft(t[0]).harness : 0, a = o && o.aliases; if (!a) return e; for (n in i = At({}, e), a) if (n in i) for (s = (r = a[n].split(",")).length; s--;)i[r[s]] = i[n]; return i }(u, e)), h = u.length; h--;)if (~d.indexOf(u[h])) for (l in s = p[h], "all" === e ? (n[h] = e, a = s, r = {}) : (r = n[h] = n[h] || {}, a = e), a) (c = s && s[l]) && ("kill" in c.d && !0 !== c.d.kill(l) || Mt(this, c, "_pt"), delete s[l]), "all" !== r && (r[l] = 1); return this._initted && !this._pt && f && ve(this), this }, e.to = function (t, i) { return new e(t, i, arguments[2]) }, e.from = function (t, e) { return Zt(1, arguments) }, e.delayedCall = function (t, i, n, s) { return new e(i, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: t, onComplete: i, onReverseComplete: i, onCompleteParams: n, onReverseCompleteParams: n, callbackScope: s }) }, e.fromTo = function (t, e, i) { return Zt(2, arguments) }, e.set = function (t, i) { return i.duration = 0, i.repeatDelay || (i.repeat = 0), new e(t, i) }, e.killTweensOf = function (t, e, i) { return l.killTweensOf(t, e, i) }, e }(qe); Tt(ei.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), gt("staggerTo,staggerFrom,staggerFromTo", (function (t) { ei[t] = function () { var e = new Ue, i = ie.call(arguments, 0); return i.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, i) } })); var ii = function (t, e, i) { return t[e] = i }, ni = function (t, e, i) { return t[e](i) }, si = function (t, e, i, n) { return t[e](n.fp, i) }, ri = function (t, e, i) { return t.setAttribute(e, i) }, oi = function (t, e) { return D(t[e]) ? ni : z(t[e]) && t.setAttribute ? ri : ii }, ai = function (t, e) { return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e) }, li = function (t, e) { return e.set(e.t, e.p, !!(e.s + e.c * t), e) }, ci = function (t, e) { var i = e._pt, n = ""; if (!t && e.b) n = e.b; else if (1 === t && e.e) n = e.e; else { for (; i;)n = i.p + (i.m ? i.m(i.s + i.c * t) : Math.round(1e4 * (i.s + i.c * t)) / 1e4) + n, i = i._next; n += e.c } e.set(e.t, e.p, n, e) }, hi = function (t, e) { for (var i = e._pt; i;)i.r(t, i.d), i = i._next }, ui = function (t, e, i, n) { for (var s, r = this._pt; r;)s = r._next, r.p === n && r.modifier(t, e, i), r = s }, di = function (t) { for (var e, i, n = this._pt; n;)i = n._next, n.p === t && !n.op || n.op === t ? Mt(this, n, "_pt") : n.dep || (e = 1), n = i; return !e }, pi = function (t, e, i, n) { n.mSet(t, e, n.m.call(n.tween, i, n.mt), n) }, fi = function (t) { for (var e, i, n, s, r = t._pt; r;) { for (e = r._next, i = n; i && i.pr > r.pr;)i = i._next; (r._prev = i ? i._prev : s) ? r._prev._next = r : n = r, (r._next = i) ? i._prev = r : s = r, r = e } t._pt = n }, mi = function () { function t(t, e, i, n, s, r, o, a, l) { this.t = e, this.s = n, this.c = s, this.p = i, this.r = r || ai, this.d = o || this, this.set = a || ii, this.pr = l || 0, this._next = t, t && (t._prev = this) } return t.prototype.modifier = function (t, e, i) { this.mSet = this.mSet || this.set, this.set = pi, this.m = t, this.mt = i, this.tween = e }, t }(); gt(dt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) { return rt[t] = 1 })), G.TweenMax = G.TweenLite = ei, G.TimelineLite = G.TimelineMax = Ue, l = new Ue({ sortChildren: !1, defaults: k, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }), S.stringFilter = Ce; var gi = [], vi = {}, wi = [], yi = 0, _i = 0, bi = function (t) { return (vi[t] || wi).map((function (t) { return t() })) }, Si = function () { var t = Date.now(), e = []; t - yi > 2 && (bi("matchMediaInit"), gi.forEach((function (t) { var i, n, s, r, o = t.queries, a = t.conditions; for (n in o) (i = c.matchMedia(o[n]).matches) && (s = 1), i !== a[n] && (a[n] = i, r = 1); r && (t.revert(), s && e.push(t)) })), bi("matchMediaRevert"), e.forEach((function (t) { return t.onMatch(t, (function (e) { return t.add(null, e) })) })), yi = t, bi("matchMedia")) }, ki = function () { function t(t, e) { this.selector = e && oe(e), this.data = [], this._r = [], this.isReverted = !1, this.id = _i++, t && this.add(t) } var e = t.prototype; return e.add = function (t, e, i) { D(t) && (i = e, e = t, t = D); var n = this, s = function () { var t, s = a, r = n.selector; return s && s !== n && s.data.push(n), i && (n.selector = oe(i)), a = n, t = e.apply(n, arguments), D(t) && n._r.push(t), a = s, n.selector = r, n.isReverted = !1, t }; return n.last = s, t === D ? s(n, (function (t) { return n.add(null, t) })) : t ? n[t] = s : s }, e.ignore = function (t) { var e = a; a = null, t(this), a = e }, e.getTweens = function () { var e = []; return this.data.forEach((function (i) { return i instanceof t ? e.push.apply(e, i.getTweens()) : i instanceof ei && !(i.parent && "nested" === i.parent.data) && e.push(i) })), e }, e.clear = function () { this._r.length = this.data.length = 0 }, e.kill = function (t, e) { var i = this; if (t ? function () { for (var e, n = i.getTweens(), s = i.data.length; s--;)"isFlip" === (e = i.data[s]).data && (e.revert(), e.getChildren(!0, !0, !1).forEach((function (t) { return n.splice(n.indexOf(t), 1) }))); for (n.map((function (t) { return { g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -1 / 0, t: t } })).sort((function (t, e) { return e.g - t.g || -1 / 0 })).forEach((function (e) { return e.t.revert(t) })), s = i.data.length; s--;)(e = i.data[s]) instanceof Ue ? "nested" !== e.data && (e.scrollTrigger && e.scrollTrigger.revert(), e.kill()) : !(e instanceof ei) && e.revert && e.revert(t); i._r.forEach((function (e) { return e(t, i) })), i.isReverted = !0 }() : this.data.forEach((function (t) { return t.kill && t.kill() })), this.clear(), e) for (var n = gi.length; n--;)gi[n].id === this.id && gi.splice(n, 1) }, e.revert = function (t) { this.kill(t || {}) }, t }(), xi = function () { function t(t) { this.contexts = [], this.scope = t, a && a.data.push(this) } var e = t.prototype; return e.add = function (t, e, i) { N(t) || (t = { matches: t }); var n, s, r, o = new ki(0, i || this.scope), l = o.conditions = {}; for (s in a && !o.selector && (o.selector = a.selector), this.contexts.push(o), e = o.add("onMatch", e), o.queries = t, t) "all" === s ? r = 1 : (n = c.matchMedia(t[s])) && (gi.indexOf(o) < 0 && gi.push(o), (l[s] = n.matches) && (r = 1), n.addListener ? n.addListener(Si) : n.addEventListener("change", Si)); return r && e(o, (function (t) { return o.add(null, t) })), this }, e.revert = function (t) { this.kill(t || {}) }, e.kill = function (t) { this.contexts.forEach((function (e) { return e.kill(t, !0) })) }, t }(), Ei = { registerPlugin: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; e.forEach((function (t) { return ye(t) })) }, timeline: function (t) { return new Ue(t) }, getTweensOf: function (t, e) { return l.getTweensOf(t, e) }, getProperty: function (t, e, i, n) { M(t) && (t = re(t)[0]); var s = ft(t || {}).get, r = i ? Et : xt; return "native" === i && (i = ""), t ? e ? r((lt[e] && lt[e].get || s)(t, e, i, n)) : function (e, i, n) { return r((lt[e] && lt[e].get || s)(t, e, i, n)) } : t }, quickSetter: function (t, e, i) { if ((t = re(t)).length > 1) { var n = t.map((function (t) { return Ci.quickSetter(t, e, i) })), s = n.length; return function (t) { for (var e = s; e--;)n[e](t) } } t = t[0] || {}; var r = lt[e], o = ft(t), a = o.harness && (o.harness.aliases || {})[e] || e, l = r ? function (e) { var n = new r; f._pt = 0, n.init(t, i ? e + i : e, f, 0, [t]), n.render(1, n), f._pt && hi(1, f) } : o.set(t, a); return r ? l : function (e) { return l(t, a, i ? e + i : e, o, 1) } }, quickTo: function (t, e, i) { var n, s = Ci.to(t, Tt(((n = {})[e] = "+=0.1", n.paused = !0, n.stagger = 0, n), i || {})), r = function (t, i, n) { return s.resetTo(e, t, i, n) }; return r.tween = s, r }, isTweening: function (t) { return l.getTweensOf(t, !0).length > 0 }, defaults: function (t) { return t && t.ease && (t.ease = Fe(t.ease, k.ease)), Ct(k, t || {}) }, config: function (t) { return Ct(S, t || {}) }, registerEffect: function (t) { var e = t.name, i = t.effect, n = t.plugins, s = t.defaults, r = t.extendTimeline; (n || "").split(",").forEach((function (t) { return t && !lt[t] && !G[t] && Q(e + " effect requires " + t + " plugin.") })), ct[e] = function (t, e, n) { return i(re(t), Tt(e || {}, s), n) }, r && (Ue.prototype[e] = function (t, i, n) { return this.add(ct[e](t, N(i) ? i : (n = i) && {}, this), n) }) }, registerEase: function (t, e) { Le[t] = Fe(e) }, parseEase: function (t, e) { return arguments.length ? Fe(t, e) : Le }, getById: function (t) { return l.getById(t) }, exportRoot: function (t, e) { void 0 === t && (t = {}); var i, n, s = new Ue(t); for (s.smoothChildTiming = F(t.smoothChildTiming), l.remove(s), s._dp = 0, s._time = s._tTime = l._time, i = l._first; i;)n = i._next, !e && !i._dur && i instanceof ei && i.vars.onComplete === i._targets[0] || qt(s, i, i._start - i._delay), i = n; return qt(l, s, 0), s }, context: function (t, e) { return t ? new ki(t, e) : a }, matchMedia: function (t) { return new xi(t) }, matchMediaRefresh: function () { return gi.forEach((function (t) { var e, i, n = t.conditions; for (i in n) n[i] && (n[i] = !1, e = 1); e && t.revert() })) || Si() }, addEventListener: function (t, e) { var i = vi[t] || (vi[t] = []); ~i.indexOf(e) || i.push(e) }, removeEventListener: function (t, e) { var i = vi[t], n = i && i.indexOf(e); n >= 0 && i.splice(n, 1) }, utils: { wrap: function t(e, i, n) { var s = i - e; return Y(e) ? de(e, t(0, e.length), i) : Qt(n, (function (t) { return (s + (t - e) % s) % s + e })) }, wrapYoyo: function t(e, i, n) { var s = i - e, r = 2 * s; return Y(e) ? de(e, t(0, e.length - 1), i) : Qt(n, (function (t) { return e + ((t = (r + (t - e) % r) % r || 0) > s ? r - t : t) })) }, distribute: le, random: ue, snap: he, normalize: function (t, e, i) { return fe(t, e, 0, 1, i) }, getUnit: ee, clamp: function (t, e, i) { return Qt(i, (function (i) { return te(t, e, i) })) }, splitColor: ke, toArray: re, selector: oe, mapRange: fe, pipe: function () { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i]; return function (t) { return e.reduce((function (t, e) { return e(t) }), t) } }, unitize: function (t, e) { return function (i) { return t(parseFloat(i)) + (e || ee(i)) } }, interpolate: function t(e, i, n, s) { var r = isNaN(e + i) ? 0 : function (t) { return (1 - t) * e + t * i }; if (!r) { var o, a, l, c, h, u = M(e), d = {}; if (!0 === n && (s = 1) && (n = null), u) e = { p: e }, i = { p: i }; else if (Y(e) && !Y(i)) { for (l = [], c = e.length, h = c - 2, a = 1; a < c; a++)l.push(t(e[a - 1], e[a])); c--, r = function (t) { t *= c; var e = Math.min(h, ~~t); return l[e](t - e) }, n = i } else s || (e = At(Y(e) ? [] : {}, e)); if (!l) { for (o in i) Xe.call(d, e, o, "get", i[o]); r = function (t) { return hi(t, d) || (u ? e.p : e) } } } return Qt(n, r) }, shuffle: ae }, install: K, effects: ct, ticker: Pe, updateRoot: Ue.updateRoot, plugins: lt, globalTimeline: l, core: { PropTween: mi, globals: tt, Tween: ei, Timeline: Ue, Animation: qe, getCache: ft, _removeLinkedListItem: Mt, reverting: function () { return o }, context: function (t) { return t && a && (a.data.push(t), t._ctx = a), a }, suppressOverwrites: function (t) { return r = t } } }; gt("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) { return Ei[t] = ei[t] })), Pe.add(Ue.updateRoot), f = Ei.to({}, { duration: 0 }); var Ti = function (t, e) { for (var i = t._pt; i && i.p !== e && i.op !== e && i.fp !== e;)i = i._next; return i }, Ai = function (t, e) { return { name: t, headless: 1, rawVars: 1, init: function (t, i, n) { n._onInit = function (t) { var n, s; if (M(i) && (n = {}, gt(i, (function (t) { return n[t] = 1 })), i = n), e) { for (s in n = {}, i) n[s] = e(i[s]); i = n } !function (t, e) { var i, n, s, r = t._targets; for (i in e) for (n = r.length; n--;)(s = t._ptLookup[n][i]) && (s = s.d) && (s._pt && (s = Ti(s, i)), s && s.modifier && s.modifier(e[i], t, r[n], i)) }(t, i) } } } }, Ci = Ei.registerPlugin({ name: "attr", init: function (t, e, i, n, s) { var r, o, a; for (r in this.tween = i, e) a = t.getAttribute(r) || "", (o = this.add(t, "setAttribute", (a || 0) + "", e[r], n, s, 0, 0, r)).op = r, o.b = a, this._props.push(r) }, render: function (t, e) { for (var i = e._pt; i;)o ? i.set(i.t, i.p, i.b, i) : i.r(t, i.d), i = i._next } }, { name: "endArray", headless: 1, init: function (t, e) { for (var i = e.length; i--;)this.add(t, i, t[i] || 0, e[i], 0, 0, 0, 0, 0, 1) } }, Ai("roundProps", ce), Ai("modifiers"), Ai("snap", he)) || Ei; ei.version = Ue.version = Ci.version = "3.13.0", d = 1, H() && Oe(); Le.Power0, Le.Power1, Le.Power2, Le.Power3, Le.Power4, Le.Linear, Le.Quad, Le.Cubic, Le.Quart, Le.Quint, Le.Strong, Le.Elastic, Le.Back, Le.SteppedEase, Le.Bounce, Le.Sine, Le.Expo, Le.Circ; var Pi, Oi, Li, Mi, Di, Ri, zi, Ni, Fi = {}, Hi = 180 / Math.PI, Bi = Math.PI / 180, Ii = Math.atan2, Yi = /([A-Z])/g, ji = /(left|right|width|margin|padding|x)/i, qi = /[\s,\(]\S/, Ui = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, Wi = function (t, e) { return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e) }, Vi = function (t, e) { return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e) }, $i = function (t, e) { return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e) }, Xi = function (t, e) { var i = e.s + e.c * t; e.set(e.t, e.p, ~~(i + (i < 0 ? -.5 : .5)) + e.u, e) }, Gi = function (t, e) { return e.set(e.t, e.p, t ? e.e : e.b, e) }, Ji = function (t, e) { return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e) }, Ki = function (t, e, i) { return t.style[e] = i }, Zi = function (t, e, i) { return t.style.setProperty(e, i) }, Qi = function (t, e, i) { return t._gsap[e] = i }, tn = function (t, e, i) { return t._gsap.scaleX = t._gsap.scaleY = i }, en = function (t, e, i, n, s) { var r = t._gsap; r.scaleX = r.scaleY = i, r.renderTransform(s, r) }, nn = function (t, e, i, n, s) { var r = t._gsap; r[e] = i, r.renderTransform(s, r) }, sn = "transform", rn = sn + "Origin", on = function t(e, i) { var n = this, s = this.target, r = s.style, o = s._gsap; if (e in Fi && r) { if (this.tfm = this.tfm || {}, "transform" === e) return Ui.transform.split(",").forEach((function (e) { return t.call(n, e, i) })); if (~(e = Ui[e] || e).indexOf(",") ? e.split(",").forEach((function (t) { return n.tfm[t] = xn(s, t) })) : this.tfm[e] = o.x ? o[e] : xn(s, e), e === rn && (this.tfm.zOrigin = o.zOrigin), this.props.indexOf(sn) >= 0) return; o.svg && (this.svgo = s.getAttribute("data-svg-origin"), this.props.push(rn, i, "")), e = sn } (r || i) && this.props.push(e, i, r[e]) }, an = function (t) { t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate")) }, ln = function () { var t, e, i = this.props, n = this.target, s = n.style, r = n._gsap; for (t = 0; t < i.length; t += 3)i[t + 1] ? 2 === i[t + 1] ? n[i[t]](i[t + 2]) : n[i[t]] = i[t + 2] : i[t + 2] ? s[i[t]] = i[t + 2] : s.removeProperty("--" === i[t].substr(0, 2) ? i[t] : i[t].replace(Yi, "-$1").toLowerCase()); if (this.tfm) { for (e in this.tfm) r[e] = this.tfm[e]; r.svg && (r.renderTransform(), n.setAttribute("data-svg-origin", this.svgo || "")), (t = zi()) && t.isStart || s[sn] || (an(s), r.zOrigin && s[rn] && (s[rn] += " " + r.zOrigin + "px", r.zOrigin = 0, r.renderTransform()), r.uncache = 1) } }, cn = function (t, e) { var i = { target: t, props: [], revert: ln, save: on }; return t._gsap || Ci.core.getCache(t), e && t.style && t.nodeType && e.split(",").forEach((function (t) { return i.save(t) })), i }, hn = function (t, e) { var i = Oi.createElementNS ? Oi.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Oi.createElement(t); return i && i.style ? i : Oi.createElement(t) }, un = function t(e, i, n) { var s = getComputedStyle(e); return s[i] || s.getPropertyValue(i.replace(Yi, "-$1").toLowerCase()) || s.getPropertyValue(i) || !n && t(e, pn(i) || i, 1) || "" }, dn = "O,Moz,ms,Ms,Webkit".split(","), pn = function (t, e, i) { var n = (e || Di).style, s = 5; if (t in n && !i) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1); s-- && !(dn[s] + t in n);); return s < 0 ? null : (3 === s ? "ms" : s >= 0 ? dn[s] : "") + t }, fn = function () { "undefined" != typeof window && window.document && (Pi = window, Oi = Pi.document, Li = Oi.documentElement, Di = hn("div") || { style: {} }, hn("div"), sn = pn(sn), rn = sn + "Origin", Di.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Ni = !!pn("perspective"), zi = Ci.core.reverting, Mi = 1) }, mn = function (t) { var e, i = t.ownerSVGElement, n = hn("svg", i && i.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), s = t.cloneNode(!0); s.style.display = "block", n.appendChild(s), Li.appendChild(n); try { e = s.getBBox() } catch (t) { } return n.removeChild(s), Li.removeChild(n), e }, gn = function (t, e) { for (var i = e.length; i--;)if (t.hasAttribute(e[i])) return t.getAttribute(e[i]) }, vn = function (t) { var e, i; try { e = t.getBBox() } catch (n) { e = mn(t), i = 1 } return e && (e.width || e.height) || i || (e = mn(t)), !e || e.width || e.x || e.y ? e : { x: +gn(t, ["x", "cx", "x1"]) || 0, y: +gn(t, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } }, wn = function (t) { return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !vn(t)) }, yn = function (t, e) { if (e) { var i, n = t.style; e in Fi && e !== rn && (e = sn), n.removeProperty ? ("ms" !== (i = e.substr(0, 2)) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty("--" === i ? e : e.replace(Yi, "-$1").toLowerCase())) : n.removeAttribute(e) } }, _n = function (t, e, i, n, s, r) { var o = new mi(t._pt, e, i, 0, 1, r ? Ji : Gi); return t._pt = o, o.b = n, o.e = s, t._props.push(i), o }, bn = { deg: 1, rad: 1, turn: 1 }, Sn = { grid: 1, flex: 1 }, kn = function t(e, i, n, s) { var r, o, a, l, c = parseFloat(n) || 0, h = (n + "").trim().substr((c + "").length) || "px", u = Di.style, d = ji.test(i), p = "svg" === e.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === s, v = "%" === s; if (s === h || !c || bn[s] || bn[h]) return c; if ("px" !== h && !g && (c = t(e, i, n, "px")), l = e.getCTM && wn(e), (v || "%" === h) && (Fi[i] || ~i.indexOf("adius"))) return r = l ? e.getBBox()[d ? "width" : "height"] : e[f], vt(v ? c / r * m : c / 100 * r); if (u[d ? "width" : "height"] = m + (g ? h : s), o = "rem" !== s && ~i.indexOf("adius") || "em" === s && e.appendChild && !p ? e : e.parentNode, l && (o = (e.ownerSVGElement || {}).parentNode), o && o !== Oi && o.appendChild || (o = Oi.body), (a = o._gsap) && v && a.width && d && a.time === Pe.time && !a.uncache) return vt(c / a.width * m); if (!v || "height" !== i && "width" !== i) (v || "%" === h) && !Sn[un(o, "display")] && (u.position = un(e, "position")), o === e && (u.position = "static"), o.appendChild(Di), r = Di[f], o.removeChild(Di), u.position = "absolute"; else { var w = e.style[i]; e.style[i] = m + s, r = e[f], w ? e.style[i] = w : yn(e, i) } return d && v && ((a = ft(o)).time = Pe.time, a.width = o[f]), vt(g ? r * c / m : r && c ? m / r * c : 0) }, xn = function (t, e, i, n) { var s; return Mi || fn(), e in Ui && "transform" !== e && ~(e = Ui[e]).indexOf(",") && (e = e.split(",")[0]), Fi[e] && "transform" !== e ? (s = zn(t, n), s = "transformOrigin" !== e ? s[e] : s.svg ? s.origin : Nn(un(t, rn)) + " " + s.zOrigin + "px") : (!(s = t.style[e]) || "auto" === s || n || ~(s + "").indexOf("calc(")) && (s = Cn[e] && Cn[e](t, e, i) || un(t, e) || mt(t, e) || ("opacity" === e ? 1 : 0)), i && !~(s + "").trim().indexOf(" ") ? kn(t, e, s, i) + i : s }, En = function (t, e, i, n) { if (!i || "none" === i) { var s = pn(e, t, 1), r = s && un(t, s, 1); r && r !== i ? (e = s, i = r) : "borderColor" === e && (i = un(t, "borderTopColor")) } var o, a, l, c, h, u, d, p, f, m, g, v = new mi(this._pt, t.style, e, 0, 1, ci), w = 0, y = 0; if (v.b = i, v.e = n, i += "", "var(--" === (n += "").substring(0, 6) && (n = un(t, n.substring(4, n.indexOf(")")))), "auto" === n && (u = t.style[e], t.style[e] = n, n = un(t, e) || n, u ? t.style[e] = u : yn(t, e)), Ce(o = [i, n]), n = o[1], l = (i = o[0]).match(U) || [], (n.match(U) || []).length) { for (; a = U.exec(n);)d = a[0], f = n.substring(w, a.index), h ? h = (h + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (h = 1), d !== (u = l[y++] || "") && (c = parseFloat(u) || 0, g = u.substr((c + "").length), "=" === d.charAt(1) && (d = yt(c, d) + g), p = parseFloat(d), m = d.substr((p + "").length), w = U.lastIndex - m.length, m || (m = m || S.units[e] || g, w === n.length && (n += m, v.e += m)), g !== m && (c = kn(t, e, u, m) || 0), v._pt = { _next: v._pt, p: f || 1 === y ? f : ",", s: c, c: p - c, m: h && h < 4 || "zIndex" === e ? Math.round : 0 }); v.c = w < n.length ? n.substring(w, n.length) : "" } else v.r = "display" === e && "none" === n ? Ji : Gi; return V.test(n) && (v.e = 0), this._pt = v, v }, Tn = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, An = function (t, e) { if (e.tween && e.tween._time === e.tween._dur) { var i, n, s, r = e.t, o = r.style, a = e.u, l = r._gsap; if ("all" === a || !0 === a) o.cssText = "", n = 1; else for (s = (a = a.split(",")).length; --s > -1;)i = a[s], Fi[i] && (n = 1, i = "transformOrigin" === i ? rn : sn), yn(r, i); n && (yn(r, sn), l && (l.svg && r.removeAttribute("transform"), o.scale = o.rotate = o.translate = "none", zn(r, 1), l.uncache = 1, an(o))) } }, Cn = { clearProps: function (t, e, i, n, s) { if ("isFromStart" !== s.data) { var r = t._pt = new mi(t._pt, e, i, 0, 0, An); return r.u = n, r.pr = -10, r.tween = s, t._props.push(i), 1 } } }, Pn = [1, 0, 0, 1, 0, 0], On = {}, Ln = function (t) { return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t }, Mn = function (t) { var e = un(t, sn); return Ln(e) ? Pn : e.substr(7).match(q).map(vt) }, Dn = function (t, e) { var i, n, s, r, o = t._gsap || ft(t), a = t.style, l = Mn(t); return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(s = t.transform.baseVal.consolidate().matrix).a, s.b, s.c, s.d, s.e, s.f]).join(",") ? Pn : l : (l !== Pn || t.offsetParent || t === Li || o.svg || (s = a.display, a.display = "block", (i = t.parentNode) && (t.offsetParent || t.getBoundingClientRect().width) || (r = 1, n = t.nextElementSibling, Li.appendChild(t)), l = Mn(t), s ? a.display = s : yn(t, "display"), r && (n ? i.insertBefore(t, n) : i ? i.appendChild(t) : Li.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l) }, Rn = function (t, e, i, n, s, r) { var o, a, l, c = t._gsap, h = s || Dn(t, !0), u = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, m = h[0], g = h[1], v = h[2], w = h[3], y = h[4], _ = h[5], b = e.split(" "), S = parseFloat(b[0]) || 0, k = parseFloat(b[1]) || 0; i ? h !== Pn && (a = m * w - g * v) && (l = S * (-g / a) + k * (m / a) - (m * _ - g * y) / a, S = S * (w / a) + k * (-v / a) + (v * _ - w * y) / a, k = l) : (S = (o = vn(t)).x + (~b[0].indexOf("%") ? S / 100 * o.width : S), k = o.y + (~(b[1] || b[0]).indexOf("%") ? k / 100 * o.height : k)), n || !1 !== n && c.smooth ? (y = S - u, _ = k - d, c.xOffset = p + (y * m + _ * v) - y, c.yOffset = f + (y * g + _ * w) - _) : c.xOffset = c.yOffset = 0, c.xOrigin = S, c.yOrigin = k, c.smooth = !!n, c.origin = e, c.originIsAbsolute = !!i, t.style[rn] = "0px 0px", r && (_n(r, c, "xOrigin", u, S), _n(r, c, "yOrigin", d, k), _n(r, c, "xOffset", p, c.xOffset), _n(r, c, "yOffset", f, c.yOffset)), t.setAttribute("data-svg-origin", S + " " + k) }, zn = function (t, e) { var i = t._gsap || new je(t); if ("x" in i && !e && !i.uncache) return i; var n, s, r, o, a, l, c, h, u, d, p, f, m, g, v, w, y, _, b, k, x, E, T, A, C, P, O, L, M, D, R, z, N = t.style, F = i.scaleX < 0, H = "px", B = "deg", I = getComputedStyle(t), Y = un(t, rn) || "0"; return n = s = r = l = c = h = u = d = p = 0, o = a = 1, i.svg = !(!t.getCTM || !wn(t)), I.translate && ("none" === I.translate && "none" === I.scale && "none" === I.rotate || (N[sn] = ("none" !== I.translate ? "translate3d(" + (I.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== I.rotate ? "rotate(" + I.rotate + ") " : "") + ("none" !== I.scale ? "scale(" + I.scale.split(" ").join(",") + ") " : "") + ("none" !== I[sn] ? I[sn] : "")), N.scale = N.rotate = N.translate = "none"), g = Dn(t, i.svg), i.svg && (i.uncache ? (C = t.getBBox(), Y = i.xOrigin - C.x + "px " + (i.yOrigin - C.y) + "px", A = "") : A = !e && t.getAttribute("data-svg-origin"), Rn(t, A || Y, !!A || i.originIsAbsolute, !1 !== i.smooth, g)), f = i.xOrigin || 0, m = i.yOrigin || 0, g !== Pn && (_ = g[0], b = g[1], k = g[2], x = g[3], n = E = g[4], s = T = g[5], 6 === g.length ? (o = Math.sqrt(_ * _ + b * b), a = Math.sqrt(x * x + k * k), l = _ || b ? Ii(b, _) * Hi : 0, (u = k || x ? Ii(k, x) * Hi + l : 0) && (a *= Math.abs(Math.cos(u * Bi))), i.svg && (n -= f - (f * _ + m * k), s -= m - (f * b + m * x))) : (z = g[6], D = g[7], O = g[8], L = g[9], M = g[10], R = g[11], n = g[12], s = g[13], r = g[14], c = (v = Ii(z, M)) * Hi, v && (A = E * (w = Math.cos(-v)) + O * (y = Math.sin(-v)), C = T * w + L * y, P = z * w + M * y, O = E * -y + O * w, L = T * -y + L * w, M = z * -y + M * w, R = D * -y + R * w, E = A, T = C, z = P), h = (v = Ii(-k, M)) * Hi, v && (w = Math.cos(-v), R = x * (y = Math.sin(-v)) + R * w, _ = A = _ * w - O * y, b = C = b * w - L * y, k = P = k * w - M * y), l = (v = Ii(b, _)) * Hi, v && (A = _ * (w = Math.cos(v)) + b * (y = Math.sin(v)), C = E * w + T * y, b = b * w - _ * y, T = T * w - E * y, _ = A, E = C), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, h = 180 - h), o = vt(Math.sqrt(_ * _ + b * b + k * k)), a = vt(Math.sqrt(T * T + z * z)), v = Ii(E, T), u = Math.abs(v) > 2e-4 ? v * Hi : 0, p = R ? 1 / (R < 0 ? -R : R) : 0), i.svg && (A = t.getAttribute("transform"), i.forceCSS = t.setAttribute("transform", "") || !Ln(un(t, sn)), A && t.setAttribute("transform", A))), Math.abs(u) > 90 && Math.abs(u) < 270 && (F ? (o *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (a *= -1, u += u <= 0 ? 180 : -180)), e = e || i.uncache, i.x = n - ((i.xPercent = n && (!e && i.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? t.offsetWidth * i.xPercent / 100 : 0) + H, i.y = s - ((i.yPercent = s && (!e && i.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-s) ? -50 : 0))) ? t.offsetHeight * i.yPercent / 100 : 0) + H, i.z = r + H, i.scaleX = vt(o), i.scaleY = vt(a), i.rotation = vt(l) + B, i.rotationX = vt(c) + B, i.rotationY = vt(h) + B, i.skewX = u + B, i.skewY = d + B, i.transformPerspective = p + H, (i.zOrigin = parseFloat(Y.split(" ")[2]) || !e && i.zOrigin || 0) && (N[rn] = Nn(Y)), i.xOffset = i.yOffset = 0, i.force3D = S.force3D, i.renderTransform = i.svg ? qn : Ni ? jn : Hn, i.uncache = 0, i }, Nn = function (t) { return (t = t.split(" "))[0] + " " + t[1] }, Fn = function (t, e, i) { var n = ee(e); return vt(parseFloat(e) + parseFloat(kn(t, "x", i + "px", n))) + n }, Hn = function (t, e) { e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, jn(t, e) }, Bn = "0deg", In = "0px", Yn = ") ", jn = function (t, e) { var i = e || this, n = i.xPercent, s = i.yPercent, r = i.x, o = i.y, a = i.z, l = i.rotation, c = i.rotationY, h = i.rotationX, u = i.skewX, d = i.skewY, p = i.scaleX, f = i.scaleY, m = i.transformPerspective, g = i.force3D, v = i.target, w = i.zOrigin, y = "", _ = "auto" === g && t && 1 !== t || !0 === g; if (w && (h !== Bn || c !== Bn)) { var b, S = parseFloat(c) * Bi, k = Math.sin(S), x = Math.cos(S); S = parseFloat(h) * Bi, b = Math.cos(S), r = Fn(v, r, k * b * -w), o = Fn(v, o, -Math.sin(S) * -w), a = Fn(v, a, x * b * -w + w) } m !== In && (y += "perspective(" + m + Yn), (n || s) && (y += "translate(" + n + "%, " + s + "%) "), (_ || r !== In || o !== In || a !== In) && (y += a !== In || _ ? "translate3d(" + r + ", " + o + ", " + a + ") " : "translate(" + r + ", " + o + Yn), l !== Bn && (y += "rotate(" + l + Yn), c !== Bn && (y += "rotateY(" + c + Yn), h !== Bn && (y += "rotateX(" + h + Yn), u === Bn && d === Bn || (y += "skew(" + u + ", " + d + Yn), 1 === p && 1 === f || (y += "scale(" + p + ", " + f + Yn), v.style[sn] = y || "translate(0, 0)" }, qn = function (t, e) { var i, n, s, r, o, a = e || this, l = a.xPercent, c = a.yPercent, h = a.x, u = a.y, d = a.rotation, p = a.skewX, f = a.skewY, m = a.scaleX, g = a.scaleY, v = a.target, w = a.xOrigin, y = a.yOrigin, _ = a.xOffset, b = a.yOffset, S = a.forceCSS, k = parseFloat(h), x = parseFloat(u); d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= Bi, p *= Bi, i = Math.cos(d) * m, n = Math.sin(d) * m, s = Math.sin(d - p) * -g, r = Math.cos(d - p) * g, p && (f *= Bi, o = Math.tan(p - f), s *= o = Math.sqrt(1 + o * o), r *= o, f && (o = Math.tan(f), i *= o = Math.sqrt(1 + o * o), n *= o)), i = vt(i), n = vt(n), s = vt(s), r = vt(r)) : (i = m, r = g, n = s = 0), (k && !~(h + "").indexOf("px") || x && !~(u + "").indexOf("px")) && (k = kn(v, "x", h, "px"), x = kn(v, "y", u, "px")), (w || y || _ || b) && (k = vt(k + w - (w * i + y * s) + _), x = vt(x + y - (w * n + y * r) + b)), (l || c) && (o = v.getBBox(), k = vt(k + l / 100 * o.width), x = vt(x + c / 100 * o.height)), o = "matrix(" + i + "," + n + "," + s + "," + r + "," + k + "," + x + ")", v.setAttribute("transform", o), S && (v.style[sn] = o) }, Un = function (t, e, i, n, s) { var r, o, a = 360, l = M(s), c = parseFloat(s) * (l && ~s.indexOf("rad") ? Hi : 1) - n, h = n + c + "deg"; return l && ("short" === (r = s.split("_")[1]) && (c %= a) !== c % 180 && (c += c < 0 ? a : -360), "cw" === r && c < 0 ? c = (c + 36e9) % a - ~~(c / a) * a : "ccw" === r && c > 0 && (c = (c - 36e9) % a - ~~(c / a) * a)), t._pt = o = new mi(t._pt, e, i, n, c, Vi), o.e = h, o.u = "deg", t._props.push(i), o }, Wn = function (t, e) { for (var i in e) t[i] = e[i]; return t }, Vn = function (t, e, i) { var n, s, r, o, a, l, c, h = Wn({}, i._gsap), u = i.style; for (s in h.svg ? (r = i.getAttribute("transform"), i.setAttribute("transform", ""), u[sn] = e, n = zn(i, 1), yn(i, sn), i.setAttribute("transform", r)) : (r = getComputedStyle(i)[sn], u[sn] = e, n = zn(i, 1), u[sn] = r), Fi) (r = h[s]) !== (o = n[s]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(s) < 0 && (a = ee(r) !== (c = ee(o)) ? kn(i, s, r, c) : parseFloat(r), l = parseFloat(o), t._pt = new mi(t._pt, n, s, a, l - a, Wi), t._pt.u = c || 0, t._props.push(s)); Wn(n, h) }; gt("padding,margin,Width,Radius", (function (t, e) { var i = "Top", n = "Right", s = "Bottom", r = "Left", o = (e < 3 ? [i, n, s, r] : [i + r, i + n, s + n, s + r]).map((function (i) { return e < 2 ? t + i : "border" + i + t })); Cn[e > 1 ? "border" + t : t] = function (t, e, i, n, s) { var r, a; if (arguments.length < 4) return r = o.map((function (e) { return xn(t, e, i) })), 5 === (a = r.join(" ")).split(r[0]).length ? r[0] : a; r = (n + "").split(" "), a = {}, o.forEach((function (t, e) { return a[t] = r[e] = r[e] || r[(e - 1) / 2 | 0] })), t.init(e, a, s) } })); var $n, Xn, Gn, Jn = { name: "css", register: fn, targetTest: function (t) { return t.style && t.nodeType }, init: function (t, e, i, n, s) { var r, o, a, l, c, h, u, d, p, f, m, g, v, w, y, _, b, k, x, E, T = this._props, A = t.style, C = i.vars.startAt; for (u in Mi || fn(), this.styles = this.styles || cn(t), _ = this.styles.props, this.tween = i, e) if ("autoRound" !== u && (o = e[u], !lt[u] || !Ge(u, e, i, n, t, s))) if (c = typeof o, h = Cn[u], "function" === c && (c = typeof (o = o.call(i, n, t, s))), "string" === c && ~o.indexOf("random(") && (o = pe(o)), h) h(this, t, u, o, i) && (y = 1); else if ("--" === u.substr(0, 2)) r = (getComputedStyle(t).getPropertyValue(u) + "").trim(), o += "", Te.lastIndex = 0, Te.test(r) || (d = ee(r), p = ee(o)), p ? d !== p && (r = kn(t, u, r, p) + p) : d && (o += d), this.add(A, "setProperty", r, o, n, s, 0, 0, u), T.push(u), _.push(u, 0, A[u]); else if ("undefined" !== c) { if (C && u in C ? (r = "function" == typeof C[u] ? C[u].call(i, n, t, s) : C[u], M(r) && ~r.indexOf("random(") && (r = pe(r)), ee(r + "") || "auto" === r || (r += S.units[u] || ee(xn(t, u)) || ""), "=" === (r + "").charAt(1) && (r = xn(t, u))) : r = xn(t, u), l = parseFloat(r), (f = "string" === c && "=" === o.charAt(1) && o.substr(0, 2)) && (o = o.substr(2)), a = parseFloat(o), u in Ui && ("autoAlpha" === u && (1 === l && "hidden" === xn(t, "visibility") && a && (l = 0), _.push("visibility", 0, A.visibility), _n(this, A, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== u && "transform" !== u && ~(u = Ui[u]).indexOf(",") && (u = u.split(",")[0])), m = u in Fi) if (this.styles.save(u), "string" === c && "var(--" === o.substring(0, 6) && (o = un(t, o.substring(4, o.indexOf(")"))), a = parseFloat(o)), g || ((v = t._gsap).renderTransform && !e.parseTransform || zn(t, e.parseTransform), w = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new mi(this._pt, A, sn, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === u) this._pt = new mi(this._pt, v, "scaleY", v.scaleY, (f ? yt(v.scaleY, f + a) : a) - v.scaleY || 0, Wi), this._pt.u = 0, T.push("scaleY", u), u += "X"; else { if ("transformOrigin" === u) { _.push(rn, 0, A[rn]), k = void 0, x = void 0, E = void 0, k = (b = o).split(" "), x = k[0], E = k[1] || "50%", "top" !== x && "bottom" !== x && "left" !== E && "right" !== E || (b = x, x = E, E = b), k[0] = Tn[x] || x, k[1] = Tn[E] || E, o = k.join(" "), v.svg ? Rn(t, o, 0, w, 0, this) : ((p = parseFloat(o.split(" ")[2]) || 0) !== v.zOrigin && _n(this, v, "zOrigin", v.zOrigin, p), _n(this, A, u, Nn(r), Nn(o))); continue } if ("svgOrigin" === u) { Rn(t, o, 1, w, 0, this); continue } if (u in On) { Un(this, v, u, l, f ? yt(l, f + o) : o); continue } if ("smoothOrigin" === u) { _n(this, v, "smooth", v.smooth, o); continue } if ("force3D" === u) { v[u] = o; continue } if ("transform" === u) { Vn(this, o, t); continue } } else u in A || (u = pn(u) || u); if (m || (a || 0 === a) && (l || 0 === l) && !qi.test(o) && u in A) a || (a = 0), (d = (r + "").substr((l + "").length)) !== (p = ee(o) || (u in S.units ? S.units[u] : d)) && (l = kn(t, u, r, p)), this._pt = new mi(this._pt, m ? v : A, u, l, (f ? yt(l, f + a) : a) - l, m || "px" !== p && "zIndex" !== u || !1 === e.autoRound ? Wi : Xi), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = r, this._pt.r = $i); else if (u in A) En.call(this, t, u, r, f ? f + o : o); else if (u in t) this.add(t, u, r || t[u], f ? f + o : o, n, s); else if ("parseTransform" !== u) { Z(u, o); continue } m || (u in A ? _.push(u, 0, A[u]) : "function" == typeof t[u] ? _.push(u, 2, t[u]()) : _.push(u, 1, r || t[u])), T.push(u) } y && fi(this) }, render: function (t, e) { if (e.tween._time || !zi()) for (var i = e._pt; i;)i.r(t, i.d), i = i._next; else e.styles.revert() }, get: xn, aliases: Ui, getSetter: function (t, e, i) { var n = Ui[e]; return n && n.indexOf(",") < 0 && (e = n), e in Fi && e !== rn && (t._gsap.x || xn(t, "x")) ? i && Ri === i ? "scale" === e ? tn : Qi : (Ri = i || {}) && ("scale" === e ? en : nn) : t.style && !z(t.style[e]) ? Ki : ~e.indexOf("-") ? Zi : oi(t, e) }, core: { _removeProperty: yn, _getMatrix: Dn } }; Ci.utils.checkPrefix = pn, Ci.core.getStyleSaver = cn, Gn = gt(($n = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Xn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) { Fi[t] = 1 })), gt(Xn, (function (t) { S.units[t] = "deg", On[t] = 1 })), Ui[Gn[13]] = $n + "," + Xn, gt("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) { var e = t.split(":"); Ui[e[1]] = Gn[e[0]] })), gt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) { S.units[t] = "px" })), Ci.registerPlugin(Jn); var Kn = Ci.registerPlugin(Jn) || Ci; Kn.core.Tween } }, s = {}; function r(t) { var e = s[t]; if (void 0 !== e) return e.exports; var i = s[t] = { exports: {} }; return n[t].call(i.exports, i, i.exports, r), i.exports } r.m = n, t = [], r.O = function (e, i, n, s) { if (!i) { var o = 1 / 0; for (h = 0; h < t.length; h++) { i = t[h][0], n = t[h][1], s = t[h][2]; for (var a = !0, l = 0; l < i.length; l++)(!1 & s || o >= s) && Object.keys(r.O).every((function (t) { return r.O[t](i[l]) })) ? i.splice(l--, 1) : (a = !1, s < o && (o = s)); if (a) { t.splice(h--, 1); var c = n(); void 0 !== c && (e = c) } } return e } s = s || 0; for (var h = t.length; h > 0 && t[h - 1][2] > s; h--)t[h] = t[h - 1]; t[h] = [i, n, s] }, r.F = {}, r.E = function (t) { Object.keys(r.F).map((function (e) { r.F[e](t) })) }, r.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return r.d(e, { a: e }), e }, r.d = function (t, e) { for (var i in e) r.o(e, i) && !r.o(t, i) && Object.defineProperty(t, i, { enumerable: !0, get: e[i] }) }, r.f = {}, r.e = function (t) { return Promise.all(Object.keys(r.f).reduce((function (e, i) { return r.f[i](t, e), e }), [])) }, r.u = function (t) { return "js/" + ({ 2: "block_text-img-scatter-text-img-scatter-js", 4: "block_modal-media-form-modal-media-form-js", 20: "block_unit-list-unit-list-js", 26: "block_password-password-css", 70: "block_headlines-headlines-css", 82: "block_contact-scroller-contact-scroller-css", 88: "block_header-header-js", 106: "block_amenity-swiper-amenity-swiper-js", 138: "block_text-marquee-text-marquee-js", 192: "block_contact-scroller-contact-scroller-js", 228: "block_cta-banner-cta-banner-js", 340: "block_headlines-headlines-js", 414: "block_hgroup-media-hgroup-media-js", 480: "block_hgroup-media-hgroup-media-css", 542: "block_modal-media-form-modal-media-form-css", 578: "block_montage-reveal-montage-reveal-css", 676: "block_text-img-scatter-text-img-scatter-css", 678: "block_cta-banner-cta-banner-css", 702: "block_footer-footer-css", 712: "block_montage-reveal-montage-reveal-js", 726: "block_unit-list-unit-list-css", 790: "block_hero-hero-js", 794: "block_map-interactive-map-interactive-css", 814: "block_center-text-center-text-css", 972: "block_amenity-swiper-amenity-swiper-css", 976: "block_hero-hero-css", 978: "block_header-header-css", 992: "block_map-interactive-map-interactive-js", 996: "block_text-marquee-text-marquee-css" }[t] || t) + ".chunk.js" }, r.miniCssF = function (t) { return "css/" + ({ 26: "block_password-password-css", 70: "block_headlines-headlines-css", 82: "block_contact-scroller-contact-scroller-css", 106: "block_amenity-swiper-amenity-swiper-js", 414: "block_hgroup-media-hgroup-media-js", 480: "block_hgroup-media-hgroup-media-css", 542: "block_modal-media-form-modal-media-form-css", 578: "block_montage-reveal-montage-reveal-css", 676: "block_text-img-scatter-text-img-scatter-css", 678: "block_cta-banner-cta-banner-css", 702: "block_footer-footer-css", 726: "block_unit-list-unit-list-css", 794: "block_map-interactive-map-interactive-css", 814: "block_center-text-center-text-css", 972: "block_amenity-swiper-amenity-swiper-css", 976: "block_hero-hero-css", 978: "block_header-header-css", 996: "block_text-marquee-text-marquee-css" }[t] || t) + ".css" }, r.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, e = {}, i = "cdrs-wp-theme:", r.l = function (t, n, s, o) { if (e[t]) e[t].push(n); else { var a, l; if (void 0 !== s) for (var c = document.getElementsByTagName("script"), h = 0; h < c.length; h++) { var u = c[h]; if (u.getAttribute("src") == t || u.getAttribute("data-webpack") == i + s) { a = u; break } } a || (l = !0, (a = document.createElement("script")).charset = "utf-8", a.timeout = 120, r.nc && a.setAttribute("nonce", r.nc), a.setAttribute("data-webpack", i + s), a.src = t), e[t] = [n]; var d = function (i, n) { a.onerror = a.onload = null, clearTimeout(p); var s = e[t]; if (delete e[t], a.parentNode && a.parentNode.removeChild(a), s && s.forEach((function (t) { return t(n) })), i) return i(n) }, p = setTimeout(d.bind(null, void 0, { type: "timeout", target: a }), 12e4); a.onerror = d.bind(null, a.onerror), a.onload = d.bind(null, a.onload), l && document.head.appendChild(a) } }, r.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, r.p = "/wp-content/themes/eight80/dist/", function () { if ("undefined" != typeof document) { var t = function (t) { return new Promise((function (e, i) { var n = r.miniCssF(t), s = r.p + n; if (function (t, e) { for (var i = document.getElementsByTagName("link"), n = 0; n < i.length; n++) { var s = (o = i[n]).getAttribute("data-href") || o.getAttribute("href"); if ("stylesheet" === o.rel && (s === t || s === e)) return o } var r = document.getElementsByTagName("style"); for (n = 0; n < r.length; n++) { var o; if ((s = (o = r[n]).getAttribute("data-href")) === t || s === e) return o } }(n, s)) return e(); !function (t, e, i, n, s) { var o = document.createElement("link"); o.rel = "stylesheet", o.type = "text/css", r.nc && (o.nonce = r.nc), o.onerror = o.onload = function (i) { if (o.onerror = o.onload = null, "load" === i.type) n(); else { var r = i && i.type, a = i && i.target && i.target.href || e, l = new Error("Loading CSS chunk " + t + " failed.\n(" + r + ": " + a + ")"); l.name = "ChunkLoadError", l.code = "CSS_CHUNK_LOAD_FAILED", l.type = r, l.request = a, o.parentNode && o.parentNode.removeChild(o), s(l) } }, o.href = e, i ? i.parentNode.insertBefore(o, i.nextSibling) : document.head.appendChild(o) }(t, s, null, e, i) })) }, e = { 524: 0 }; r.f.miniCss = function (i, n) { e[i] ? n.push(e[i]) : 0 !== e[i] && { 26: 1, 70: 1, 82: 1, 106: 1, 414: 1, 480: 1, 542: 1, 578: 1, 676: 1, 678: 1, 702: 1, 726: 1, 770: 1, 794: 1, 814: 1, 972: 1, 976: 1, 978: 1, 996: 1 }[i] && n.push(e[i] = t(i).then((function () { e[i] = 0 }), (function (t) { throw delete e[i], t }))) }, r.F.miniCss = function (t) { if (!(r.o(e, t) && void 0 !== e[t] || /^(2(|0|28|80)|(19|71|99)2|(34|66|79)0|138|4|88)$/.test(t))) { e[t] = null; var i = document.createElement("link"); r.nc && i.setAttribute("nonce", r.nc), i.rel = "prefetch", i.as = "style", i.href = r.p + r.miniCssF(t), document.head.appendChild(i) } } } }(), function () { var t = { 524: 0 }; r.f.j = function (e, i) { var n = r.o(t, e) ? t[e] : void 0; if (0 !== n) if (n) i.push(n[2]); else { var s = new Promise((function (i, s) { n = t[e] = [i, s] })); i.push(n[2] = s); var o = r.p + r.u(e), a = new Error; r.l(o, (function (i) { if (r.o(t, e) && (0 !== (n = t[e]) && (t[e] = void 0), n)) { var s = i && ("load" === i.type ? "missing" : i.type), o = i && i.target && i.target.src; a.message = "Loading chunk " + e + " failed.\n(" + s + ": " + o + ")", a.name = "ChunkLoadError", a.type = s, a.request = o, n[1](a) } }), "chunk-" + e, e) } }, r.F.j = function (e) { if (!r.o(t, e) || void 0 === t[e]) { t[e] = null; var i = document.createElement("link"); i.charset = "utf-8", r.nc && i.setAttribute("nonce", r.nc), i.rel = "prefetch", i.as = "script", i.href = r.p + r.u(e), document.head.appendChild(i) } }, r.O.j = function (e) { return 0 === t[e] }; var e = function (e, i) { var n, s, o = i[0], a = i[1], l = i[2], c = 0; if (o.some((function (e) { return 0 !== t[e] }))) { for (n in a) r.o(a, n) && (r.m[n] = a[n]); if (l) var h = l(r) } for (e && e(i); c < o.length; c++)s = o[c], r.o(t, s) && t[s] && t[s][0](), t[s] = 0; return r.O(h) }, i = self.webpackChunkcdrs_wp_theme = self.webpackChunkcdrs_wp_theme || []; i.forEach(e.bind(null, 0)), i.push = e.bind(null, i.push.bind(i)) }(), r.O(0, [524], (function () { [660, 106, 192, 228, 88, 340, 790, 414, 770, 992, 4, 712, 2, 138, 20, 972, 814, 82, 678, 702, 978, 70, 976, 480, 794, 542, 578, 26, 676, 996, 726].map(r.E) }), 5); var o = {}; !function () { "use strict"; const t = new WeakMap; function e(e, i, n, s) { if (!e && !t.has(i)) return !1; const r = t.get(i) ?? new WeakMap; t.set(i, r); const o = r.get(n) ?? new Set; r.set(n, o); const a = o.has(s); return e ? o.add(s) : o.delete(s), a && e } var i = function (t, i, n, s = {}) { const { signal: r, base: o = document } = s; if (r?.aborted) return; const { once: a, ...l } = s, c = o instanceof Document ? o.documentElement : o, h = Boolean("object" == typeof s ? s.capture : s), u = s => { const r = function (t, e) { let i = t.target; if (i instanceof Text && (i = i.parentElement), i instanceof Element && t.currentTarget instanceof Element) { const n = i.closest(e); if (n && t.currentTarget.contains(n)) return n } }(s, String(t)); if (r) { const t = Object.assign(s, { delegateTarget: r }); n.call(c, t), a && (c.removeEventListener(i, u, l), e(!1, c, n, d)) } }, d = JSON.stringify({ selector: t, type: i, capture: h }); e(!0, c, n, d) || c.addEventListener(i, u, l), r?.addEventListener("abort", (() => { e(!1, c, n, d) })) }; function n() { return n = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var n in i) ({}).hasOwnProperty.call(i, n) && (t[n] = i[n]) } return t }, n.apply(null, arguments) } const s = (t, e) => String(t).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || e || "", o = ({ hash: t } = {}) => window.location.pathname + window.location.search + (t ? window.location.hash : ""), a = (t, e = {}) => { const i = n({ url: t = t || o({ hash: !0 }), random: Math.random(), source: "swup" }, e); window.history.pushState(i, "", t) }, l = (t = null, e = {}) => { t = t || o({ hash: !0 }); const i = n({}, window.history.state || {}, { url: t, random: Math.random(), source: "swup" }, e); window.history.replaceState(i, "", t) }, c = (t, e, s, r) => { const o = new AbortController; return r = n({}, r, { signal: o.signal }), i(t, e, s, r), { destroy: () => o.abort() } }; class h extends URL { constructor(t, e = document.baseURI) { super(t.toString(), e), Object.setPrototypeOf(this, h.prototype) } get url() { return this.pathname + this.search } static fromElement(t) { const e = t.getAttribute("href") || t.getAttribute("xlink:href") || ""; return new h(e) } static fromUrl(t) { return new h(t) } } class u extends Error { constructor(t, e) { super(t), this.url = void 0, this.status = void 0, this.aborted = void 0, this.timedOut = void 0, this.name = "FetchError", this.url = e.url, this.status = e.status, this.aborted = e.aborted || !1, this.timedOut = e.timedOut || !1 } } async function d(t, e = {}) { var i; t = h.fromUrl(t).url; const { visit: s = this.visit } = e, r = n({}, this.options.requestHeaders, e.headers), o = null != (i = e.timeout) ? i : this.options.timeout, a = new AbortController, { signal: l } = a; e = n({}, e, { headers: r, signal: l }); let c, d = !1, p = null; o && o > 0 && (p = setTimeout((() => { d = !0, a.abort("timeout") }), o)); try { c = await this.hooks.call("fetch:request", s, { url: t, options: e }, ((t, { url: e, options: i }) => fetch(e, i))), p && clearTimeout(p) } catch (e) { if (d) throw this.hooks.call("fetch:timeout", s, { url: t }), new u(`Request timed out: ${t}`, { url: t, timedOut: d }); if ("AbortError" === (null == e ? void 0 : e.name) || l.aborted) throw new u(`Request aborted: ${t}`, { url: t, aborted: !0 }); throw e } const { status: f, url: m } = c, g = await c.text(); if (500 === f) throw this.hooks.call("fetch:error", s, { status: f, response: c, url: m }), new u(`Server error: ${m}`, { status: f, url: m }); if (!g) throw new u(`Empty response: ${m}`, { status: f, url: m }); const { url: v } = h.fromUrl(m), w = { url: v, html: g }; return !s.cache.write || e.method && "GET" !== e.method || t !== v || this.cache.set(w.url, w), w } class p { constructor(t) { this.swup = void 0, this.pages = new Map, this.swup = t } get size() { return this.pages.size } get all() { const t = new Map; return this.pages.forEach(((e, i) => { t.set(i, n({}, e)) })), t } has(t) { return this.pages.has(this.resolve(t)) } get(t) { const e = this.pages.get(this.resolve(t)); return e ? n({}, e) : e } set(t, e) { e = n({}, e, { url: t = this.resolve(t) }), this.pages.set(t, e), this.swup.hooks.callSync("cache:set", void 0, { page: e }) } update(t, e) { t = this.resolve(t); const i = n({}, this.get(t), e, { url: t }); this.pages.set(t, i) } delete(t) { this.pages.delete(this.resolve(t)) } clear() { this.pages.clear(), this.swup.hooks.callSync("cache:clear", void 0, void 0) } prune(t) { this.pages.forEach(((e, i) => { t(i, e) && this.delete(i) })) } resolve(t) { const { url: e } = h.fromUrl(t); return this.swup.resolveUrl(e) } } const f = (t, e = document) => e.querySelector(t), m = (t, e = document) => Array.from(e.querySelectorAll(t)), g = () => new Promise((t => { requestAnimationFrame((() => { requestAnimationFrame((() => { t() })) })) })); function v(t) { return !!t && ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then } function w(t, e = []) { return new Promise(((i, n) => { const s = t(...e); v(s) ? s.then(i, n) : i(s) })) } function y(t, e) { const i = null == t ? void 0 : t.closest(`[${e}]`); return null != i && i.hasAttribute(e) ? (null == i ? void 0 : i.getAttribute(e)) || !0 : void 0 } class _ { constructor(t) { this.swup = void 0, this.swupClasses = ["to-", "is-changing", "is-rendering", "is-popstate", "is-animating", "is-leaving"], this.swup = t } get selectors() { const { scope: t } = this.swup.visit.animation; return "containers" === t ? this.swup.visit.containers : "html" === t ? ["html"] : Array.isArray(t) ? t : [] } get selector() { return this.selectors.join(",") } get targets() { return this.selector.trim() ? m(this.selector) : [] } add(...t) { this.targets.forEach((e => e.classList.add(...t))) } remove(...t) { this.targets.forEach((e => e.classList.remove(...t))) } clear() { this.targets.forEach((t => { const e = t.className.split(" ").filter((t => this.isSwupClass(t))); t.classList.remove(...e) })) } isSwupClass(t) { return this.swupClasses.some((e => t.startsWith(e))) } } class b { constructor(t, e) { this.id = void 0, this.state = void 0, this.from = void 0, this.to = void 0, this.containers = void 0, this.animation = void 0, this.trigger = void 0, this.cache = void 0, this.history = void 0, this.scroll = void 0, this.meta = void 0; const { to: i, from: n, hash: s, el: r, event: o } = e; this.id = Math.random(), this.state = 1, this.from = { url: null != n ? n : t.location.url, hash: t.location.hash }, this.to = { url: i, hash: s }, this.containers = t.options.containers, this.animation = { animate: !0, wait: !1, name: void 0, native: t.options.native, scope: t.options.animationScope, selector: t.options.animationSelector }, this.trigger = { el: r, event: o }, this.cache = { read: t.options.cache, write: t.options.cache }, this.history = { action: "push", popstate: !1, direction: void 0 }, this.scroll = { reset: !0, target: void 0 }, this.meta = {} } advance(t) { this.state < t && (this.state = t) } abort() { this.state = 8 } get done() { return this.state >= 7 } } function S(t) { return new b(this, t) } class k { constructor(t) { this.swup = void 0, this.registry = new Map, this.hooks = ["animation:out:start", "animation:out:await", "animation:out:end", "animation:in:start", "animation:in:await", "animation:in:end", "animation:skip", "cache:clear", "cache:set", "content:replace", "content:scroll", "enable", "disable", "fetch:request", "fetch:error", "fetch:timeout", "history:popstate", "link:click", "link:self", "link:anchor", "link:newtab", "page:load", "page:view", "scroll:top", "scroll:anchor", "visit:start", "visit:transition", "visit:abort", "visit:end"], this.swup = t, this.init() } init() { this.hooks.forEach((t => this.create(t))) } create(t) { this.registry.has(t) || this.registry.set(t, new Map) } exists(t) { return this.registry.has(t) } get(t) { const e = this.registry.get(t); if (e) return e; console.error(`Unknown hook '${t}'`) } clear() { this.registry.forEach((t => t.clear())) } on(t, e, i = {}) { const s = this.get(t); if (!s) return console.warn(`Hook '${t}' not found.`), () => { }; const r = n({}, i, { id: s.size + 1, hook: t, handler: e }); return s.set(e, r), () => this.off(t, e) } before(t, e, i = {}) { return this.on(t, e, n({}, i, { before: !0 })) } replace(t, e, i = {}) { return this.on(t, e, n({}, i, { replace: !0 })) } once(t, e, i = {}) { return this.on(t, e, n({}, i, { once: !0 })) } off(t, e) { const i = this.get(t); i && e ? i.delete(e) || console.warn(`Handler for hook '${t}' not found.`) : i && i.clear() } async call(t, e, i, n) { const [s, r, o] = this.parseCallArgs(t, e, i, n), { before: a, handler: l, after: c } = this.getHandlers(t, o); await this.run(a, s, r); const [h] = await this.run(l, s, r, !0); return await this.run(c, s, r), this.dispatchDomEvent(t, s, r), h } callSync(t, e, i, n) { const [s, r, o] = this.parseCallArgs(t, e, i, n), { before: a, handler: l, after: c } = this.getHandlers(t, o); this.runSync(a, s, r); const [h] = this.runSync(l, s, r, !0); return this.runSync(c, s, r), this.dispatchDomEvent(t, s, r), h } parseCallArgs(t, e, i, n) { return e instanceof b || "object" != typeof e && "function" != typeof i ? [e, i, n] : [void 0, e, i] } async run(t, e = this.swup.visit, i, n = !1) { const s = []; for (const { hook: r, handler: o, defaultHandler: a, once: l } of t) if (null == e || !e.done) { l && this.off(r, o); try { const t = await w(o, [e, i, a]); s.push(t) } catch (t) { if (n) throw t; console.error(`Error in hook '${r}':`, t) } } return s } runSync(t, e = this.swup.visit, i, n = !1) { const s = []; for (const { hook: r, handler: o, defaultHandler: a, once: l } of t) if (null == e || !e.done) { l && this.off(r, o); try { const t = o(e, i, a); s.push(t), v(t) && console.warn(`Swup will not await Promises in handler for synchronous hook '${r}'.`) } catch (t) { if (n) throw t; console.error(`Error in hook '${r}':`, t) } } return s } getHandlers(t, e) { const i = this.get(t); if (!i) return { found: !1, before: [], handler: [], after: [], replaced: !1 }; const n = Array.from(i.values()), s = this.sortRegistrations, r = n.filter((({ before: t, replace: e }) => t && !e)).sort(s), o = n.filter((({ replace: t }) => t)).filter((t => !0)).sort(s), a = n.filter((({ before: t, replace: e }) => !t && !e)).sort(s), l = o.length > 0; let c = []; if (e && (c = [{ id: 0, hook: t, handler: e }], l)) { const i = o.length - 1, { handler: n, once: s } = o[i], r = t => { const i = o[t - 1]; return i ? (e, n) => i.handler(e, n, r(t - 1)) : e }; c = [{ id: 0, hook: t, once: s, handler: n, defaultHandler: r(i) }] } return { found: !0, before: r, handler: c, after: a, replaced: l } } sortRegistrations(t, e) { var i, n; return (null != (i = t.priority) ? i : 0) - (null != (n = e.priority) ? n : 0) || t.id - e.id || 0 } dispatchDomEvent(t, e, i) { if (null != e && e.done) return; const n = { hook: t, args: i, visit: e || this.swup.visit }; document.dispatchEvent(new CustomEvent("swup:any", { detail: n, bubbles: !0 })), document.dispatchEvent(new CustomEvent(`swup:${t}`, { detail: n, bubbles: !0 })) } parseName(t) { const [e, ...i] = t.split("."); return [e, i.reduce(((t, e) => n({}, t, { [e]: !0 })), {})] } } const x = t => { if (t && "#" === t.charAt(0) && (t = t.substring(1)), !t) return null; const e = decodeURIComponent(t); let i = document.getElementById(t) || document.getElementById(e) || f(`a[name='${CSS.escape(t)}']`) || f(`a[name='${CSS.escape(e)}']`); return i || "top" !== t || (i = document.body), i }, E = "transition", T = "animation"; async function A({ selector: t, elements: e }) { if (!1 === t && !e) return; let i = []; if (e) i = Array.from(e); else if (t && (i = m(t, document.body), !i.length)) return void console.warn(`[swup] No elements found matching animationSelector \`${t}\``); const n = i.map((t => function (t) { const { type: e, timeout: i, propCount: n } = function (t) { const e = window.getComputedStyle(t), i = C(e, `${E}Delay`), n = C(e, `${E}Duration`), s = P(i, n), r = C(e, `${T}Delay`), o = C(e, `${T}Duration`), a = P(r, o), l = Math.max(s, a), c = l > 0 ? s > a ? E : T : null; return { type: c, timeout: l, propCount: c ? c === E ? n.length : o.length : 0 } }(t); return !(!e || !i) && new Promise((s => { const r = `${e}end`, o = performance.now(); let a = 0; const l = () => { t.removeEventListener(r, c), s() }, c = e => { e.target === t && ((performance.now() - o) / 1e3 < e.elapsedTime || ++a >= n && l()) }; setTimeout((() => { a < n && l() }), i + 1), t.addEventListener(r, c) })) }(t))); n.filter(Boolean).length > 0 ? await Promise.all(n) : t && console.warn(`[swup] No CSS animation duration defined on elements matching \`${t}\``) } function C(t, e) { return (t[e] || "").split(", ") } function P(t, e) { for (; t.length < e.length;)t = t.concat(t); return Math.max(...e.map(((e, i) => O(e) + O(t[i])))) } function O(t) { return 1e3 * parseFloat(t) } function L(t, e = {}, i = {}) { if ("string" != typeof t) throw new Error("swup.navigate() requires a URL parameter"); if (this.shouldIgnoreVisit(t, { el: i.el, event: i.event })) return void window.location.assign(t); const { url: s, hash: r } = h.fromUrl(t), o = this.createVisit(n({}, i, { to: s, hash: r })); this.performNavigation(o, e) } async function M(t, e = {}) { if (this.navigating) { if (this.visit.state >= 6) return t.state = 2, void (this.onVisitEnd = () => this.performNavigation(t, e)); await this.hooks.call("visit:abort", this.visit, void 0), delete this.visit.to.document, this.visit.state = 8 } this.navigating = !0, this.visit = t; const { el: i } = t.trigger; e.referrer = e.referrer || this.location.url, !1 === e.animate && (t.animation.animate = !1), t.animation.animate || this.classes.clear(); const n = e.history || y(i, "data-swup-history"); "string" == typeof n && ["push", "replace"].includes(n) && (t.history.action = n); const r = e.animation || y(i, "data-swup-animation"); var o, c; "string" == typeof r && (t.animation.name = r), t.meta = e.meta || {}, "object" == typeof e.cache ? (t.cache.read = null != (o = e.cache.read) ? o : t.cache.read, t.cache.write = null != (c = e.cache.write) ? c : t.cache.write) : void 0 !== e.cache && (t.cache = { read: !!e.cache, write: !!e.cache }), delete e.cache; try { await this.hooks.call("visit:start", t, void 0), t.state = 3; const i = this.hooks.call("page:load", t, { options: e }, (async (t, e) => { let i; return t.cache.read && (i = this.cache.get(t.to.url)), e.page = i || await this.fetchPage(t.to.url, e.options), e.cache = !!i, e.page })); i.then((({ html: e }) => { t.advance(5), t.to.html = e, t.to.document = (new DOMParser).parseFromString(e, "text/html") })); const n = t.to.url + t.to.hash; if (t.history.popstate || ("replace" === t.history.action || t.to.url === this.location.url ? l(n) : (this.currentHistoryIndex++, a(n, { index: this.currentHistoryIndex }))), this.location = h.fromUrl(n), t.history.popstate && this.classes.add("is-popstate"), t.animation.name && this.classes.add(`to-${s(t.animation.name)}`), t.animation.wait && await i, t.done) return; if (await this.hooks.call("visit:transition", t, void 0, (async () => { if (!t.animation.animate) return await this.hooks.call("animation:skip", void 0), void await this.renderPage(t, await i); t.advance(4), await this.animatePageOut(t), t.animation.native && document.startViewTransition ? await document.startViewTransition((async () => await this.renderPage(t, await i))).finished : await this.renderPage(t, await i), await this.animatePageIn(t) })), t.done) return; await this.hooks.call("visit:end", t, void 0, (() => this.classes.clear())), t.state = 7, this.navigating = !1, this.onVisitEnd && (this.onVisitEnd(), this.onVisitEnd = void 0) } catch (e) { if (!e || null != e && e.aborted) return void (t.state = 8); t.state = 9, console.error(e), this.options.skipPopStateHandling = () => (window.location.assign(t.to.url + t.to.hash), !0), window.history.back() } finally { delete t.to.document } } const D = async function (t) { await this.hooks.call("animation:out:start", t, void 0, (() => { this.classes.add("is-changing", "is-animating", "is-leaving") })), await this.hooks.call("animation:out:await", t, { skip: !1 }, ((t, { skip: e }) => { if (!e) return this.awaitAnimations({ selector: t.animation.selector }) })), await this.hooks.call("animation:out:end", t, void 0) }, R = function (t) { var e; const i = t.to.document; if (!i) return !1; const n = (null == (e = i.querySelector("title")) ? void 0 : e.innerText) || ""; document.title = n; const s = m('[data-swup-persist]:not([data-swup-persist=""])'), r = t.containers.map((t => { const e = document.querySelector(t), n = i.querySelector(t); return e && n ? (e.replaceWith(n.cloneNode(!0)), !0) : (e || console.warn(`[swup] Container missing in current document: ${t}`), n || console.warn(`[swup] Container missing in incoming document: ${t}`), !1) })).filter(Boolean); return s.forEach((t => { const e = t.getAttribute("data-swup-persist"), i = f(`[data-swup-persist="${e}"]`); i && i !== t && i.replaceWith(t) })), r.length === t.containers.length }, z = function (t) { const e = { behavior: "auto" }, { target: i, reset: s } = t.scroll, r = null != i ? i : t.to.hash; let o = !1; return r && (o = this.hooks.callSync("scroll:anchor", t, { hash: r, options: e }, ((t, { hash: e, options: i }) => { const n = this.getAnchorElement(e); return n && n.scrollIntoView(i), !!n }))), s && !o && (o = this.hooks.callSync("scroll:top", t, { options: e }, ((t, { options: e }) => (window.scrollTo(n({ top: 0, left: 0 }, e)), !0)))), o }, N = async function (t) { if (t.done) return; const e = this.hooks.call("animation:in:await", t, { skip: !1 }, ((t, { skip: e }) => { if (!e) return this.awaitAnimations({ selector: t.animation.selector }) })); await g(), await this.hooks.call("animation:in:start", t, void 0, (() => { this.classes.remove("is-animating") })), await e, await this.hooks.call("animation:in:end", t, void 0) }, F = async function (t, e) { if (t.done) return; t.advance(6); const { url: i } = e; this.isSameResolvedUrl(o(), i) || (l(i), this.location = h.fromUrl(i), t.to.url = this.location.url, t.to.hash = this.location.hash), await this.hooks.call("content:replace", t, { page: e }, ((t, { }) => { if (this.classes.remove("is-leaving"), t.animation.animate && this.classes.add("is-rendering"), !this.replaceContent(t)) throw new Error("[swup] Container mismatch, aborting"); t.animation.animate && (this.classes.add("is-changing", "is-animating", "is-rendering"), t.animation.name && this.classes.add(`to-${s(t.animation.name)}`)) })), await this.hooks.call("content:scroll", t, void 0, (() => this.scrollToContent(t))), await this.hooks.call("page:view", t, { url: this.location.url, title: document.title }) }, H = function (t) { var e; if (e = t, Boolean(null == e ? void 0 : e.isSwupPlugin)) { if (t.swup = this, !t._checkRequirements || t._checkRequirements()) return t._beforeMount && t._beforeMount(), t.mount(), this.plugins.push(t), this.plugins } else console.error("Not a swup plugin instance", t) }; function B(t) { const e = this.findPlugin(t); if (e) return e.unmount(), e._afterUnmount && e._afterUnmount(), this.plugins = this.plugins.filter((t => t !== e)), this.plugins; console.error("No such plugin", e) } function I(t) { return this.plugins.find((e => e === t || e.name === t || e.name === `Swup${String(t)}`)) } function Y(t) { if ("function" != typeof this.options.resolveUrl) return console.warn("[swup] options.resolveUrl expects a callback function."), t; const e = this.options.resolveUrl(t); return e && "string" == typeof e ? e.startsWith("//") || e.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), t) : e : (console.warn("[swup] options.resolveUrl needs to return a url"), t) } function j(t, e) { return this.resolveUrl(t) === this.resolveUrl(e) } const q = { animateHistoryBrowsing: !1, animationSelector: '[class*="transition-"]', animationScope: "html", cache: !0, containers: ["#swup"], hooks: {}, ignoreVisit: (t, { el: e } = {}) => !(null == e || !e.closest("[data-no-swup]")), linkSelector: "a[href]", linkToSelf: "scroll", native: !1, plugins: [], resolveUrl: t => t, requestHeaders: { "X-Requested-With": "swup", Accept: "text/html, application/xhtml+xml" }, skipPopStateHandling: t => { var e; return "swup" !== (null == (e = t.state) ? void 0 : e.source) }, timeout: 0 }; function U() { return U = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]) } return t }, U.apply(this, arguments) } const W = t => String(t).split(".").map((t => String(parseInt(t || "0", 10)))).concat(["0", "0"]).slice(0, 3).join("."); class V { constructor() { this.isSwupPlugin = !0, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = [] } mount() { } unmount() { this.handlersToUnregister.forEach((t => t())), this.handlersToUnregister = [] } _beforeMount() { if (!this.name) throw new Error("You must define a name of plugin when creating a class.") } _afterUnmount() { } _checkRequirements() { return "object" != typeof this.requires || Object.entries(this.requires).forEach((([t, e]) => { if (!function (t, e, i) { const n = function (t, e) { var i; if ("swup" === t) return null != (i = e.version) ? i : ""; { var n; const i = e.findPlugin(t); return null != (n = null == i ? void 0 : i.version) ? n : "" } }(t, i); return !!n && ((t, e) => e.every((e => { const [, i, n] = e.match(/^([\D]+)?(.*)$/) || []; var s, r; return ((t, e) => { const i = { "": t => 0 === t, ">": t => t > 0, ">=": t => t >= 0, "<": t => t < 0, "<=": t => t <= 0 }; return (i[e] || i[""])(t) })((r = n, s = W(s = t), r = W(r), s.localeCompare(r, void 0, { numeric: !0 })), i || ">=") })))(n, e) }(t, e = Array.isArray(e) ? e : [e], this.swup)) { const i = `${t} ${e.join(", ")}`; throw new Error(`Plugin version mismatch: ${this.name} requires ${i}`) } })), !0 } on(t, e, i = {}) { var n; e = !(n = e).name.startsWith("bound ") || n.hasOwnProperty("prototype") ? e.bind(this) : e; const s = this.swup.hooks.on(t, e, i); return this.handlersToUnregister.push(s), s } once(t, e, i = {}) { return this.on(t, e, U({}, i, { once: !0 })) } before(t, e, i = {}) { return this.on(t, e, U({}, i, { before: !0 })) } replace(t, e, i = {}) { return this.on(t, e, U({}, i, { replace: !0 })) } off(t, e) { return this.swup.hooks.off(t, e) } } function $() { return $ = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]) } return t }, $.apply(this, arguments) } function X(t, { prefix: e = "" } = {}) { return !!t && t.startsWith(e) } function G(t, e = []) { const i = Array.from(t.attributes); return e.length ? i.filter((({ name: t }) => e.some((e => e instanceof RegExp ? e.test(t) : t === e)))) : i } class J extends V { constructor(...t) { super(...t), this._originalAnimationSelectorOption = "", this._addedStyleElements = [], this._addedHTMLContent = [], this._classNameAddedToElements = [], this._addClassNameToElement = () => { this._classNameAddedToElements.forEach((t => { Array.from(document.querySelectorAll(t.selector)).forEach((e => { e.classList.add(`swup-transition-${t.name}`) })) })) } } _beforeMount() { this._originalAnimationSelectorOption = String(this.swup.options.animationSelector), this.swup.options.animationSelector = '[class*="swup-transition-"]', this.swup.hooks.on("content:replace", this._addClassNameToElement) } _afterUnmount() { this.swup.options.animationSelector = this._originalAnimationSelectorOption, this._addedStyleElements.forEach((t => { t.outerHTML = "" })), this._addedStyleElements = [], this._addedHTMLContent.forEach((t => { t.outerHTML = "" })), this._addedHTMLContent = [], this._classNameAddedToElements.forEach((t => { Array.from(document.querySelectorAll(t.selector)).forEach((t => { t.className.split(" ").forEach((e => { new RegExp("^swup-transition-").test(e) && t.classList.remove(e) })) })) })), this.swup.hooks.off("content:replace", this._addClassNameToElement) } applyStyles(t) { const e = document.createElement("style"); e.setAttribute("data-swup-theme", ""), e.appendChild(document.createTextNode(t)), document.head.prepend(e), this._addedStyleElements.push(e) } applyHTML(t) { const e = document.createElement("div"); e.innerHTML = t, document.body.appendChild(e), this._addedHTMLContent.push(e) } addClassName(t, e) { this._classNameAddedToElements.push({ selector: t, name: e }), this._addClassNameToElement() } } function K() { return K = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var n in i) ({}).hasOwnProperty.call(i, n) && (t[n] = i[n]) } return t }, K.apply(null, arguments) } function Z() { return Z = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var n in i) ({}).hasOwnProperty.call(i, n) && (t[n] = i[n]) } return t }, Z.apply(null, arguments) } function Q() { return window.matchMedia("(hover: hover)").matches } function tt(t) { return !!t && (t instanceof HTMLAnchorElement || t instanceof SVGAElement) } const et = window.requestIdleCallback || (t => setTimeout(t, 1)), it = ["preloadVisibleLinks"]; function nt() { return nt = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]) } return t }, nt.apply(this, arguments) } class st { constructor(t) { this._raf = null, this._positionY = 0, this._velocityY = 0, this._targetPositionY = 0, this._targetPositionYWithOffset = 0, this._direction = 0, this.scrollTo = t => { if (t && t.nodeType) this._targetPositionY = Math.round(t.getBoundingClientRect().top + window.pageYOffset); else { if (parseInt(this._targetPositionY) !== this._targetPositionY) return void console.error("Argument must be a number or an element."); this._targetPositionY = Math.round(t) } this._targetPositionY > document.documentElement.scrollHeight - window.innerHeight && (this._targetPositionY = document.documentElement.scrollHeight - window.innerHeight), this._positionY = document.body.scrollTop || document.documentElement.scrollTop, this._direction = this._positionY > this._targetPositionY ? -1 : 1, this._targetPositionYWithOffset = this._targetPositionY + this._direction, this._velocityY = 0, this._positionY !== this._targetPositionY ? (this.options.onStart(), this._animate()) : this.options.onAlreadyAtPositions() }, this._animate = () => { this._update(), this._render(), 1 === this._direction && this._targetPositionY > this._positionY || -1 === this._direction && this._targetPositionY < this._positionY ? (this._raf = requestAnimationFrame(this._animate), this.options.onTick()) : (this._positionY = this._targetPositionY, this._render(), this._raf = null, this.options.onTick(), this.options.onEnd()) }, this._update = () => { const t = this._targetPositionYWithOffset - this._positionY; return this._velocityY += t * this.options.acceleration, this._velocityY *= this.options.friction, this._positionY += this._velocityY, Math.abs(t) }, this._render = () => { window.scrollTo(0, this._positionY) }, this.options = nt({}, { onAlreadyAtPositions: () => { }, onCancel: () => { }, onEnd: () => { }, onStart: () => { }, onTick: () => { }, friction: .7, acceleration: .04 }, t), t && t.friction && (this.options.friction = 1 - t.friction), window.addEventListener("mousewheel", (t => { this._raf && (this.options.onCancel(), cancelAnimationFrame(this._raf), this._raf = null) }), { passive: !0 }) } } function rt() { return rt = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]) } return t }, rt.apply(this, arguments) } const ot = new class { get currentPageUrl() { return this.location.url } constructor(t = {}) { var e, i; this.version = "4.8.2", this.options = void 0, this.defaults = q, this.plugins = [], this.visit = void 0, this.cache = void 0, this.hooks = void 0, this.classes = void 0, this.location = h.fromUrl(window.location.href), this.currentHistoryIndex = void 0, this.clickDelegate = void 0, this.navigating = !1, this.onVisitEnd = void 0, this.use = H, this.unuse = B, this.findPlugin = I, this.log = () => { }, this.navigate = L, this.performNavigation = M, this.createVisit = S, this.delegateEvent = c, this.fetchPage = d, this.awaitAnimations = A, this.renderPage = F, this.replaceContent = R, this.animatePageIn = N, this.animatePageOut = D, this.scrollToContent = z, this.getAnchorElement = x, this.getCurrentUrl = o, this.resolveUrl = Y, this.isSameResolvedUrl = j, this.options = n({}, this.defaults, t), this.handleLinkClick = this.handleLinkClick.bind(this), this.handlePopState = this.handlePopState.bind(this), this.cache = new p(this), this.classes = new _(this), this.hooks = new k(this), this.visit = this.createVisit({ to: "" }), this.currentHistoryIndex = null != (e = null == (i = window.history.state) ? void 0 : i.index) ? e : 1, this.enable() } async enable() { var t; const { linkSelector: e } = this.options; this.clickDelegate = this.delegateEvent(e, "click", this.handleLinkClick), window.addEventListener("popstate", this.handlePopState), this.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.options.native = this.options.native && !!document.startViewTransition, this.options.plugins.forEach((t => this.use(t))); for (const [t, e] of Object.entries(this.options.hooks)) { const [i, n] = this.hooks.parseName(t); this.hooks.on(i, e, n) } "swup" !== (null == (t = window.history.state) ? void 0 : t.source) && l(null, { index: this.currentHistoryIndex }), await g(), await this.hooks.call("enable", void 0, void 0, (() => { const t = document.documentElement; t.classList.add("swup-enabled"), t.classList.toggle("swup-native", this.options.native) })) } async destroy() { this.clickDelegate.destroy(), window.removeEventListener("popstate", this.handlePopState), this.cache.clear(), this.options.plugins.forEach((t => this.unuse(t))), await this.hooks.call("disable", void 0, void 0, (() => { const t = document.documentElement; t.classList.remove("swup-enabled"), t.classList.remove("swup-native") })), this.hooks.clear() } shouldIgnoreVisit(t, { el: e, event: i } = {}) { const { origin: n, url: s, hash: r } = h.fromUrl(t); return n !== window.location.origin || !(!e || !this.triggerWillOpenNewWindow(e)) || !!this.options.ignoreVisit(s + r, { el: e, event: i }) } handleLinkClick(t) { const e = t.delegateTarget, { href: i, url: n, hash: s } = h.fromElement(e); if (this.shouldIgnoreVisit(i, { el: e, event: t })) return; if (this.navigating && n === this.visit.to.url) return void t.preventDefault(); const r = this.createVisit({ to: n, hash: s, el: e, event: t }); t.metaKey || t.ctrlKey || t.shiftKey || t.altKey ? this.hooks.callSync("link:newtab", r, { href: i }) : 0 === t.button && this.hooks.callSync("link:click", r, { el: e, event: t }, (() => { var e; const i = null != (e = r.from.url) ? e : ""; t.preventDefault(), n && n !== i ? this.isSameResolvedUrl(n, i) || this.performNavigation(r) : s ? this.hooks.callSync("link:anchor", r, { hash: s }, (() => { l(n + s), this.scrollToContent(r) })) : this.hooks.callSync("link:self", r, void 0, (() => { "navigate" === this.options.linkToSelf ? this.performNavigation(r) : (l(n), this.scrollToContent(r)) })) })) } handlePopState(t) { var e, i, n, s; const r = null != (e = null == (i = t.state) ? void 0 : i.url) ? e : window.location.href; if (this.options.skipPopStateHandling(t)) return; if (this.isSameResolvedUrl(o(), this.location.url)) return; const { url: a, hash: l } = h.fromUrl(r), c = this.createVisit({ to: a, hash: l, event: t }); c.history.popstate = !0; const u = null != (n = null == (s = t.state) ? void 0 : s.index) ? n : 0; u && u !== this.currentHistoryIndex && (c.history.direction = u - this.currentHistoryIndex > 0 ? "forwards" : "backwards", this.currentHistoryIndex = u), c.animation.animate = !1, c.scroll.reset = !1, c.scroll.target = !1, this.options.animateHistoryBrowsing && (c.animation.animate = !0, c.scroll.reset = !0), this.hooks.callSync("history:popstate", c, { event: t }, (() => { this.performNavigation(c) })) } triggerWillOpenNewWindow(t) { return !!t.matches('[download], [target="_blank"]') } }({ containers: ["#swup"], ignoreVisit: function (t) { let { el: e } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return e?.closest("[data-no-swup]") }, plugins: [new class extends V { constructor(t = {}) { super(), this.name = "SwupBodyClassPlugin", this.requires = { swup: ">=4.6" }, this.defaults = { prefix: "", attributes: [] }, this.options = void 0, this.update = t => { const { prefix: e, attributes: i } = this.options; !function (t, e, { prefix: i = "" } = {}) { const n = [...t.classList].filter((t => X(t, { prefix: i }))), s = [...e.classList].filter((t => X(t, { prefix: i }))); t.classList.remove(...n), t.classList.add(...s) }(document.body, t.to.document.body, { prefix: e }), null != i && i.length && function (t, e, i = []) { const n = new Set; for (const { name: s, value: r } of G(e, i)) t.setAttribute(s, r), n.add(s); for (const { name: e } of G(t, i)) n.has(e) || t.removeAttribute(e) }(document.body, t.to.document.body, i) }, this.options = $({}, this.defaults, t) } mount() { this.on("content:replace", this.update) } }, new class extends J { constructor(t = {}) { if (super(), this.name = "SwupOverlayTheme", this.defaults = { direction: "to-right", color: void 0, duration: void 0 }, this.directions = ["to-left", "to-right", "to-top", "to-bottom"], this.options = K({}, this.defaults, t), !this.directions.includes(this.options.direction)) throw new Error(`Invalid direction: ${direction}`) } mount() { this.applyStyles("html{--swup-overlay-theme-color:#2d2e82;--swup-overlay-theme-duration:.6s;--swup-overlay-theme-delay:.2s;--swup-overlay-theme-scale:1.2;--swup-overlay-theme-skew:5deg}.swup-transition-overlay{--swup-overlay-x-scale:1;--swup-overlay-y-scale:1;--swup-overlay-skew-direction:1;--swup-overlay-width-value:calc(100vw*var(--swup-overlay-x-scale));--swup-overlay-height-value:calc(100vh*var(--swup-overlay-y-scale));--swup-overlay-transform-x-value:calc(100%*var(--swup-overlay-x-scale));--swup-overlay-transform-y-value:calc(100%*var(--swup-overlay-y-scale));--swup-overlay-top-value:calc((1 - var(--swup-overlay-y-scale))*0.5*100vh);--swup-overlay-left-value:calc((1 - var(--swup-overlay-x-scale))*0.5*100vw);--swup-overlay-bottom-value:auto;--swup-overlay-right-value:auto;--swup-overlay-skew-value:calc(var(--swup-overlay-theme-skew)*var(--swup-overlay-skew-direction));background-color:var(--swup-overlay-theme-color);bottom:var(--swup-overlay-bottom-value);height:var(--swup-overlay-height-value);left:var(--swup-overlay-left-value);opacity:0;pointer-events:none;position:fixed;right:var(--swup-overlay-right-value);top:var(--swup-overlay-top-value);width:var(--swup-overlay-width-value);z-index:9999}html.is-changing .swup-transition-overlay{opacity:1;transition:transform var(--swup-overlay-theme-duration) var(--swup-overlay-theme-delay)}.swup-transition-overlay[data-direction=to-left],.swup-transition-overlay[data-direction=to-right]{--swup-overlay-x-scale:var(--swup-overlay-theme-scale)}.swup-transition-overlay[data-direction=to-right]{transform:translate3d(calc(var(--swup-overlay-transform-x-value)*-1),0,0) skewX(var(--swup-overlay-skew-value))}html.is-animating .swup-transition-overlay[data-direction=to-right]{transform:translateZ(0) skewX(var(--swup-overlay-skew-value))}.swup-transition-overlay[data-direction=to-left],html.is-rendering .swup-transition-overlay[data-direction=to-right]{transform:translate3d(var(--swup-overlay-transform-x-value),0,0) skewX(var(--swup-overlay-skew-value))}.swup-transition-overlay[data-direction=to-left]{--swup-overlay-skew-direction:-1}html.is-animating .swup-transition-overlay[data-direction=to-left]{transform:translateZ(0) skewX(var(--swup-overlay-skew-value))}html.is-rendering .swup-transition-overlay[data-direction=to-left]{transform:translate3d(calc(var(--swup-overlay-transform-x-value)*-1),0,0) skewX(var(--swup-overlay-skew-value))}.swup-transition-overlay[data-direction=to-bottom],.swup-transition-overlay[data-direction=to-top]{--swup-overlay-y-scale:var(--swup-overlay-theme-scale)}.swup-transition-overlay[data-direction=to-bottom]{transform:translate3d(0,calc(var(--swup-overlay-transform-y-value)*-1),0) skewY(var(--swup-overlay-skew-value))}html.is-animating .swup-transition-overlay[data-direction=to-bottom]{transform:translateZ(0) skewY(var(--swup-overlay-skew-value))}.swup-transition-overlay[data-direction=to-top],html.is-rendering .swup-transition-overlay[data-direction=to-bottom]{transform:translate3d(0,var(--swup-overlay-transform-y-value),0) skewY(var(--swup-overlay-skew-value))}.swup-transition-overlay[data-direction=to-top]{--swup-overlay-skew-direction:-1}html.is-animating .swup-transition-overlay[data-direction=to-top]{transform:translateZ(0) skewY(var(--swup-overlay-skew-value))}html.is-rendering .swup-transition-overlay[data-direction=to-top]{transform:translate3d(0,calc(var(--swup-overlay-transform-y-value)*-1),0) skewY(var(--swup-overlay-skew-value))}"), this.applyHTML(this.createOverlay()) } createOverlay() { const { direction: t } = this.options; return `\n\t\t\t<div\n\t\t\t\tclass="swup-transition-overlay"\n\t\t\t\tdata-direction="${t}"\n\t\t\t\tstyle="--swup-overlay-theme-color:${void 0 !== this.options.color ? this.options.color : "inherit"};--swup-overlay-theme-duration:${void 0 !== this.options.duration ? `${this.options.duration}ms` : "inherit"};"\n\t\t\t></div>\n\t\t` } }({ direction: "to-top" }), new class extends V { constructor(t = {}) { var e; super(), e = this, this.name = "SwupPreloadPlugin", this.requires = { swup: ">=4.5" }, this.defaults = { throttle: 5, preloadInitialPage: !0, preloadHoveredLinks: !0, preloadVisibleLinks: { enabled: !1, threshold: .2, delay: 500, containers: ["body"], ignore: () => !1 } }, this.options = void 0, this.queue = void 0, this.preloadObserver = void 0, this.preloadPromises = new Map, this.mouseEnterDelegate = void 0, this.touchStartDelegate = void 0, this.focusDelegate = void 0, this.onPageLoad = (t, e, i) => { const { url: n } = t.to; return n && this.preloadPromises.has(n) ? this.preloadPromises.get(n) : i(t, e) }, this.onMouseEnter = async function (t) { if (t.target !== t.delegateTarget) return; if (!Q()) return; const i = t.delegateTarget; if (!tt(i)) return; const { url: n, hash: s } = h.fromElement(i), r = e.swup.createVisit({ to: n, hash: s, el: i, event: t }); e.swup.hooks.callSync("link:hover", r, { el: i, event: t }), e.preload(i, { priority: !0 }) }, this.onTouchStart = t => { if (Q()) return; const e = t.delegateTarget; tt(e) && this.preload(e, { priority: !0 }) }, this.onFocus = t => { const e = t.delegateTarget; tt(e) && this.preload(e, { priority: !0 }) }; const { preloadVisibleLinks: i } = t, n = function (t, e) { if (null == t) return {}; var i = {}; for (var n in t) if ({}.hasOwnProperty.call(t, n)) { if (e.includes(n)) continue; i[n] = t[n] } return i }(t, it); this.options = Z({}, this.defaults, n), "object" == typeof i ? this.options.preloadVisibleLinks = Z({}, this.options.preloadVisibleLinks, { enabled: !0 }, i) : this.options.preloadVisibleLinks.enabled = Boolean(i), this.preload = this.preload.bind(this), this.queue = function (t = 1) { const e = [], i = []; let n = 0, s = 0; function r() { s < t && n > 0 && ((i.shift() || e.shift() || (() => { }))(), n--, s++) } return { add: function (t, s = !1) { if (t.__queued) { if (!s) return; { const i = e.indexOf(t); if (i >= 0) { const t = e.splice(i, 1); n -= t.length } } } t.__queued = !0, (s ? i : e).push(t), n++, n <= 1 && r() }, next: function () { s--, r() } } }(this.options.throttle) } mount() { const t = this.swup; t.options.cache ? (t.hooks.create("page:preload"), t.hooks.create("link:hover"), t.preload = this.preload, t.preloadLinks = this.preloadLinks, this.replace("page:load", this.onPageLoad), this.preloadLinks(), this.on("page:view", (() => this.preloadLinks())), this.options.preloadVisibleLinks.enabled && (this.preloadVisibleLinks(), this.on("page:view", (() => this.preloadVisibleLinks()))), this.options.preloadHoveredLinks && this.preloadLinksOnAttention(), this.options.preloadInitialPage && this.preload(o())) : console.warn("SwupPreloadPlugin: swup cache needs to be enabled for preloading") } unmount() { var t, e, i; this.swup.preload = void 0, this.swup.preloadLinks = void 0, this.preloadPromises.clear(), null == (t = this.mouseEnterDelegate) || t.destroy(), null == (e = this.touchStartDelegate) || e.destroy(), null == (i = this.focusDelegate) || i.destroy(), this.stopPreloadingVisibleLinks() } async preload(t, e = {}) { var i; let n, s; const r = null != (i = e.priority) && i; if (Array.isArray(t)) return Promise.all(t.map((t => this.preload(t)))); if (tt(t)) s = t, ({ href: n } = h.fromElement(t)); else { if ("string" != typeof t) return; n = t } if (!n) return; if (this.swup.cache.has(n)) return this.swup.cache.get(n); if (this.preloadPromises.has(n)) return this.preloadPromises.get(n); if (!this.shouldPreload(n, { el: s })) return; const o = new Promise((t => { this.queue.add((() => { this.performPreload(n).catch((() => { })).then((e => t(e))).finally((() => { this.queue.next(), this.preloadPromises.delete(n) })) }), r) })); return this.preloadPromises.set(n, o), o } preloadLinks() { et((() => { Array.from(document.querySelectorAll("a[data-swup-preload], [data-swup-preload-all] a")).forEach((t => this.preload(t))) })) } preloadLinksOnAttention() { const { swup: t } = this, { linkSelector: e } = t.options, i = { passive: !0, capture: !0 }; this.mouseEnterDelegate = t.delegateEvent(e, "mouseenter", this.onMouseEnter, i), this.touchStartDelegate = t.delegateEvent(e, "touchstart", this.onTouchStart, i), this.focusDelegate = t.delegateEvent(e, "focus", this.onFocus, i) } preloadVisibleLinks() { if (this.preloadObserver) return void this.preloadObserver.update(); const { threshold: t, delay: e, containers: i } = this.options.preloadVisibleLinks; this.preloadObserver = function ({ threshold: t, delay: e, containers: i, callback: n, filter: s }) { const r = new Map, o = new IntersectionObserver((t => { t.forEach((t => { t.isIntersecting ? a(t.target) : l(t.target) })) }), { threshold: t }), a = t => { var i; const { href: s } = h.fromElement(t), a = null != (i = r.get(s)) ? i : new Set; r.set(s, a), a.add(t), setTimeout((() => { const e = r.get(s); null != e && e.size && (n(t), o.unobserve(t), e.delete(t)) }), e) }, l = t => { var e; const { href: i } = h.fromElement(t); null == (e = r.get(i)) || e.delete(t) }, c = () => { et((() => { const t = i.map((t => `${t} a[*|href]`)).join(", "); Array.from(document.querySelectorAll(t)).filter((t => s(t))).forEach((t => o.observe(t))) })) }; return { start: () => c(), stop: () => o.disconnect(), update: () => (r.clear(), c()) } }({ threshold: t, delay: e, containers: i, callback: t => this.preload(t), filter: t => { if (this.options.preloadVisibleLinks.ignore(t)) return !1; if (!t.matches(this.swup.options.linkSelector)) return !1; const { href: e } = h.fromElement(t); return this.shouldPreload(e, { el: t }) } }), this.preloadObserver.start() } stopPreloadingVisibleLinks() { this.preloadObserver && this.preloadObserver.stop() } shouldPreload(t, { el: e } = {}) { const { url: i, href: n } = h.fromUrl(t); return !(!function () { if (navigator.connection) { var t; if (navigator.connection.saveData) return !1; if (null != (t = navigator.connection.effectiveType) && t.endsWith("2g")) return !1 } return !0 }() || this.swup.cache.has(i) || this.preloadPromises.has(i) || this.swup.shouldIgnoreVisit(n, { el: e }) || e && this.swup.resolveUrl(i) === this.swup.resolveUrl(o())) } async performPreload(t) { var e = this; const { url: i } = h.fromUrl(t), n = this.swup.createVisit({ to: i }), s = await this.swup.hooks.call("page:preload", n, { url: i }, (async function (i, n) { return n.page = await e.swup.fetchPage(t, { visit: i }), n.page })); return s } }, new class extends V { constructor(t = {}) { super(), this.name = "SwupScrollPlugin", this.requires = { swup: ">=4.2.0" }, this.scrl = void 0, this.defaults = { doScrollingRightAway: !1, animateScroll: { betweenPages: !0, samePageWithHash: !0, samePage: !0 }, scrollFriction: .3, scrollAcceleration: .04, getAnchorElement: void 0, offset: 0, scrollContainers: "[data-swup-scroll-container]", shouldResetScrollPosition: () => !0, markScrollTarget: !1 }, this.options = void 0, this.cachedScrollPositions = {}, this.previousScrollRestoration = void 0, this.currentCacheKey = void 0, this.getAnchorElement = (t = "") => "function" == typeof this.options.getAnchorElement ? this.options.getAnchorElement(t) : this.swup.getAnchorElement(t), this.getOffset = t => t ? "function" == typeof this.options.offset ? parseInt(String(this.options.offset(t)), 10) : parseInt(String(this.options.offset), 10) : 0, this.onBeforeLinkToSelf = t => { t.scroll.animate = this.shouldAnimate("samePage") }, this.handleScrollToTop = t => { var e, i; return null == (e = (i = this.swup).scrollTo) || e.call(i, 0, t.scroll.animate), !0 }, this.onBeforeLinkToAnchor = t => { t.scroll.animate = this.shouldAnimate("samePageWithHash") }, this.handleScrollToAnchor = (t, { hash: e }) => this.maybeScrollToAnchor(e, t.scroll.animate), this.onBeforeVisitStart = t => { t.scroll.scrolledToContent = !1, t.scroll.animate = this.shouldAnimate("betweenPages") }, this.onVisitStart = t => { var e; this.cacheScrollPositions(t.from.url), this.maybeResetScrollPositions(t); const i = null != (e = t.scroll.target) ? e : t.to.hash; t.scroll.animate && this.options.doScrollingRightAway && !i && this.doScrollingBetweenPages(t) }, this.handleScrollToContent = t => { t.scroll.scrolledToContent || this.doScrollingBetweenPages(t), this.restoreScrollContainers(t.to.url) }, this.doScrollingBetweenPages = t => { var e, i; if (t.history.popstate && !t.animation.animate) return; const n = null != (e = t.scroll.target) ? e : t.to.hash; if (n && this.maybeScrollToAnchor(n, t.scroll.animate)) return; if (!t.scroll.reset) return; const s = this.getCachedScrollPositions(t.to.url), r = (null == s || null == (i = s.window) ? void 0 : i.top) || 0; requestAnimationFrame((() => { var e, i; return null == (e = (i = this.swup).scrollTo) ? void 0 : e.call(i, r, t.scroll.animate) })), t.scroll.scrolledToContent = !0 }, this.maybeResetScrollPositions = t => { const { popstate: e } = t.history, { url: i } = t.to, { el: n } = t.trigger; e || n && !this.options.shouldResetScrollPosition(n) || this.resetScrollPositions(i) }, this.options = rt({}, this.defaults, t) } mount() { const t = this.swup; t.hooks.create("scroll:start"), t.hooks.create("scroll:end"); const e = this.swup.createVisit({ to: this.swup.currentPageUrl }); this.scrl = new st({ onStart: () => t.hooks.callSync("scroll:start", e, void 0), onEnd: () => t.hooks.callSync("scroll:end", e, void 0), onCancel: () => t.hooks.callSync("scroll:end", e, void 0), friction: this.options.scrollFriction, acceleration: this.options.scrollAcceleration }), t.scrollTo = (i, n = !0) => { n ? this.scrl.scrollTo(i) : (t.hooks.callSync("scroll:start", e, void 0), window.scrollTo(0, i), t.hooks.callSync("scroll:end", e, void 0)) }, this.previousScrollRestoration = window.history.scrollRestoration, t.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.updateScrollTarget = this.updateScrollTarget.bind(this), this.options.markScrollTarget && (window.addEventListener("popstate", this.updateScrollTarget), window.addEventListener("hashchange", this.updateScrollTarget), this.on("page:view", this.updateScrollTarget), this.on("link:anchor", this.updateScrollTarget), this.on("link:self", this.updateScrollTarget), this.updateScrollTarget()), this.before("visit:start", this.onBeforeVisitStart, { priority: -1 }), this.on("visit:start", this.onVisitStart, { priority: 1 }), this.replace("content:scroll", this.handleScrollToContent), this.before("link:self", this.onBeforeLinkToSelf, { priority: -1 }), this.replace("scroll:top", this.handleScrollToTop), this.before("link:anchor", this.onBeforeLinkToAnchor, { priority: -1 }), this.replace("scroll:anchor", this.handleScrollToAnchor) } unmount() { super.unmount(), this.previousScrollRestoration && (window.history.scrollRestoration = this.previousScrollRestoration), window.removeEventListener("popstate", this.updateScrollTarget), window.removeEventListener("hashchange", this.updateScrollTarget), this.cachedScrollPositions = {}, delete this.swup.scrollTo, delete this.scrl } shouldAnimate(t) { return "boolean" == typeof this.options.animateScroll ? this.options.animateScroll : this.options.animateScroll[t] } maybeScrollToAnchor(t, e = !1) { var i, n; if (!t) return !1; const s = this.getAnchorElement(t); if (!s) return console.warn(`Anchor target ${t} not found`), !1; if (!(s instanceof Element)) return console.warn(`Anchor target ${t} is not a DOM node`), !1; const { top: r } = s.getBoundingClientRect(), o = r + window.scrollY - this.getOffset(s); return null == (i = (n = this.swup).scrollTo) || i.call(n, o, e), !0 } cacheScrollPositions(t) { const e = this.swup.resolveUrl(t), i = m(this.options.scrollContainers).map((t => ({ top: t.scrollTop, left: t.scrollLeft }))), n = { window: { top: window.scrollY, left: window.scrollX }, containers: i }; this.cachedScrollPositions[e] = n } resetScrollPositions(t) { const e = this.swup.resolveUrl(t); delete this.cachedScrollPositions[e] } getCachedScrollPositions(t) { const e = this.swup.resolveUrl(t); return this.cachedScrollPositions[e] } restoreScrollContainers(t) { const e = this.getCachedScrollPositions(t); e && 0 !== e.containers.length && m(this.options.scrollContainers).forEach(((t, i) => { const n = e.containers[i]; null != n && (t.scrollTop = n.top, t.scrollLeft = n.left) })) } updateScrollTarget() { var t; const { hash: e } = window.location, i = document.querySelector("[data-swup-scroll-target]"); let n = this.getAnchorElement(e); n instanceof HTMLBodyElement && (n = null), i !== n && (null == i || i.removeAttribute("data-swup-scroll-target"), null == (t = n) || t.setAttribute("data-swup-scroll-target", "")) } }({ scrollAcceleration: .03, shouldResetScrollPosition: t => !0, offset: () => { const t = document.querySelector('a[href="' + window.location.hash + '"]'); if (t && t.dataset.offset) return parseInt(t.dataset.offset, 10); const e = document.querySelector(".c-header[data-cid] .header_inline"); return e ? e.offsetHeight : 0 }, animateScroll: !window.matchMedia("(prefers-reduced-motion: reduce)").matches && { betweenPages: !1, samePageWithHash: !0, samePage: !0 } })] }); var at = ot, lt = r(66); const ct = { events: {}, on(t, e) { this.events[t] || (this.events[t] = []), this.events[t].push(e) }, off(t) { this.events[t] && (this.events[t] = []) }, emit(t, e) { this.events[t] && this.events[t].forEach((t => t(e))) } }, ht = t => { const e = t.dataset.cid; if (!e) throw new Error("Path slug is missing for a component."); return { pathSlug: e, options: { refresh: void 0 !== t.dataset.refresh, critical: void 0 !== t.dataset.critical, lazyCss: void 0 !== t.dataset.lazyCss, js: void 0 !== t.dataset.js } } }, ut = (t, e, i) => { i && console.log(`%c${t}`, "font-weight: bold;", e) }, dt = (t, e) => function (i) { let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "log"; if (!0 === this.debug || e) { const e = `${""} [${t.dataset.cid}]: ${i}`; for (var s = arguments.length, r = new Array(s > 2 ? s - 2 : 0), o = 2; o < s; o++)r[o - 2] = arguments[o]; switch (n.toLowerCase()) { case "warn": console.warn(e, ...r); break; case "error": console.error(e, ...r); break; default: console.log(e, ...r) } } }, pt = async function (t, e) { let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3; try { return "js" === e ? await r(37)(`./${t}/${t}.js`) : await r(397)(`./${t}/${t}.css`) } catch (s) { if ("ChunkLoadError" === s.name && i > 0) return console.warn(`Chunk load error for ${t}.${e}. Retrying... (${i} attempts remaining)`), window.webpackChunkdiscardCached && window.webpackChunkdiscardCached([`block_${t}`]), await new Promise((t => setTimeout(t, n))), pt(t, e, i - 1, n); if ("js" === e) throw console.error(`Failed to load ${t}.${e} after multiple attempts:`, s), s; return null } }, ft = t => { t.comp = t; t.bindMethods = t => { Object.keys(t).forEach((e => { "function" == typeof t[e] && (t[e] = t[e].bind(t)) })) }; let e = []; t.unloadComponent = async function () { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; const { pathSlug: i, options: n } = ht(t), s = at.location.url, r = void 0 !== t.dataset.log || e, o = r ? { component: t, refresh: n.refresh, critical: n.critical, lazyCss: n.lazyCss, js: n.js } : null; "function" == typeof t.removeAllEventListeners ? t.removeAllEventListeners() : console.warn(`removeAllEventListeners is not a function for component '${i}'`); try { if (n.js) { const e = await pt(i, "js"); "function" == typeof e.default.unmount && "function" != typeof e.default.remount && (ut(`[]  Unmounting component '${i}'`, o, r), t.componentModule || (t.componentModule = Object.create(e.default), Object.keys(e.default).forEach((i => { "function" == typeof e.default[i] && (t.componentModule[i] = e.default[i].bind(t.componentModule)) })), t.componentModule.log = dt(t, r)), t.componentModule.unmount(t, n, s), t.dataset.jsState = "unloaded", ut(`[]  Unmounted component '${i}'`, o, r), ct.emit("unmount", { component: { name: i, el: t, options: n } })) } } catch (t) { console.error(`[] Failed to unmount component '${i}': `, t) } }, t.$ = e => t.querySelectorAll(e), t.$one = e => t.querySelector(e), t.ref = e => { const i = `[data-ref="${e}"]`; return t.querySelector(i) || null }, t.refs = e => { const i = `[data-ref="${e}"]`; return t.querySelectorAll(i) }, t.on = (t, i, n, s) => { const r = function (t) { for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)i[r - 1] = arguments[r]; n.call(undefined, t, ...i, s) }; (i instanceof NodeList ? Array.from(i) : [i]).forEach((i => { i ? (i.addEventListener(t, r), e.push({ type: t, el: i, originalFunc: n, boundFunc: r })) : console.error("Invalid element for event listener:", i) })) }, t.off = (t, i, n) => { const s = e.findIndex((e => e.type === t && e.originalFunc === n)); if (-1 !== s) { const n = e[s]; (i instanceof NodeList ? Array.from(i) : [i]).forEach((e => e.removeEventListener(t, n.boundFunc))), e.splice(s, 1) } }, t.removeAllEventListeners = () => { e.forEach((t => { (Array.isArray(t.el) ? t.el : [t.el]).forEach((e => { (e instanceof HTMLElement || e === window || e === document) && e.removeEventListener(t.type, t.boundFunc) })) })), e = [] }, t.logEvents = () => { const i = e.length; console.log(`Event listeners for component '${t.dataset.cid}' [${i}]:`), e.forEach((t => { console.log(`Event: ${t.type}, Elements:`, t.el, "Function:", t.boundFunc) })) } }, mt = async t => { try { return await pt(t, "css") ? (document.querySelectorAll(`[data-cid="${t}"]`).forEach((t => { t.classList.add("has-css-loaded") })), ut(`[] Loaded CSS for component '${t}' from blocks directory`, null, wt), !0) : (ut(`No CSS file found for component '${t}'`, null, wt), !1) } catch { return ut(`No CSS file found for component '${t}'`, null, wt), !1 } }, gt = async function (t) { let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const { pathSlug: i, options: n } = ht(t), s = at.location.url; let r = void 0 !== t.dataset.log || e; const o = { component: t, refresh: n.refresh, critical: n.critical, lazyCss: n.lazyCss, js: n.js }; try { if (n.js) { const a = await pt(i, "js"), l = Object.create(a.default); l.log = dt(t, r), Object.keys(a.default).forEach((t => { "function" == typeof a.default[t] && (l[t] = a.default[t].bind(l)) })), Object.assign(l, t), !0 === l.log && (r = !0, t.dataset.log = ""), t.componentModule = l, "function" == typeof l.render && await l.render(t, n, s, e), "loaded" === t.dataset.jsState ? "function" == typeof l.remount && (ut(`[]  Remounting component '${i}'`, o, r), l.remount(t, n, s), ut(`[]  Remounted component '${i}'`, o, r), ct.emit("remount", { component: { name: i, el: t, options: n } })) : "function" == typeof l.mount && (ut(`[]  Mounting component '${i}'`, o, r), l.mount(t, n, s), t.dataset.jsState = "loaded", ut(`[]  Mounted component '${i}'`, o, r), ct.emit("mount", { component: { name: i, el: t, options: n } }), n.lazyCss && await mt(i)), n.refresh && (lt.u.refresh(), ut(`[] ScrollTrigger refreshed by '${i}'`, t, r)) } } catch (t) { n.lazyCss || console.error(`[] Failed to initialise component '${i}': `, t) } }; let vt = null, wt = !1; const yt = () => { Array.from(document.querySelectorAll("[data-cid]")).forEach((t => { ft(t); const { pathSlug: e, options: i } = ht(t); i.lazyCss || mt(e) })) }, _t = { register: yt, init: async function () { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const { proximity: e = 200, debug: i = !1, critical: n = !1 } = t; wt = i, yt(); const s = [...Array.from(document.querySelectorAll("[data-js][data-cid]")), ...Array.from(document.querySelectorAll("[data-lazy-css]:not([data-js])"))]; if (ut("[]  Initializing components with settings:", { settings: t, components: s }, i), !s.length) return void ut("No components were found.", null, i); await (async t => { let e = 0; const i = t.filter((t => !t.hasAttribute("data-lazy-css"))); for (const t of i) { const { pathSlug: i } = ht(t); await mt(i) && e++ } e === i.length && (ut("All non-lazy CSS components loaded, emitting styles:loaded event.", null, wt), ct.emit("styles:loaded")) })(s); const r = (t, e) => { t.forEach((t => { if (t.isIntersecting) { const n = t.target; if (n.hasAttribute("data-js") && (ft(n), n.hasMounted || (gt(n, i), n.hasMounted = !0)), n.hasAttribute("data-lazy-css")) { const { pathSlug: t } = ht(n); mt(t) } e.unobserve(n) } })) }; if (n) { ut("Loading all component JS/CSS critically. Bypassing proximity setting.", null, i); for (const t of s) if (t.hasAttribute("data-js") && await gt(t, i), t.hasAttribute("data-lazy-css")) { const { pathSlug: e } = ht(t); await mt(e) } } else { vt = new IntersectionObserver(r, { threshold: 0, rootMargin: `0px 0px ${e}px 0px` }), s.forEach((t => { const e = void 0 !== t.dataset.critical, n = t.getBoundingClientRect().top < window.innerHeight; if (e || n) { if (t.hasAttribute("data-js") && gt(t, i), t.hasAttribute("data-lazy-css")) { const { pathSlug: e } = ht(t); mt(e) } } else vt.observe(t) })) } ut("[]  Initialized components with settings:", { settings: t, components: s }, i) }, cleanup: () => { Array.from(document.querySelectorAll('[data-js][data-js-state="loaded"]')).forEach((t => t.unloadComponent(wt))), vt && (vt.disconnect(), vt = null), ut("[] Cleaned up components and disconnected observer.", null, wt) }, hooks: ct }, bt = 250, St = (t, e) => { if ("function" != typeof t) throw new TypeError("Expected a function"); if ("number" != typeof e || e < 0) throw new TypeError("Wait must be a positive number") }, kt = function (t) { let e, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : bt, n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; St(t, i); return { debouncedFn: function () { for (var s = arguments.length, r = new Array(s), o = 0; o < s; o++)r[o] = arguments[o]; const a = this, l = n && !e; clearTimeout(e), e = setTimeout((() => { e = null, n || t.apply(a, r) }), i), l && t.apply(a, r) }, getTimeout: () => e } }, xt = function (t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : bt, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const { debouncedFn: n } = kt(t, e, i); return n }, Et = function (t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : bt, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const { debouncedFn: n, getTimeout: s } = kt(t, e, i); return { debouncedFn: n, cleanup: () => { const t = s(); t && clearTimeout(t) } } }, Tt = function (t) { let e, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : bt; return St(t, i), function () { const n = this; if (!e) { for (var s = arguments.length, r = new Array(s), o = 0; o < s; o++)r[o] = arguments[o]; t.apply(n, r), e = !0, setTimeout((() => { e = !1 }), i) } } }; const At = "--vw", Ct = "--svh", Pt = "--dvh", Ot = "--lvh", Lt = "--ivh"; class Mt { constructor() { this.handleResize = this.handleResize.bind(this), this.debouncedHandleResize = xt(this.handleResize, 200), this.prevWidth = 0, this.prevHeight = 0, this.documentStyles = document.documentElement.style, this.hasSetInitialHeight = !1 } handleResize() { const t = document.body.clientWidth, e = document.documentElement.clientHeight || window.innerHeight; if (t === this.prevWidth && e === this.prevHeight) return; this.prevWidth = t, this.prevHeight = e; const i = .01 * t; if (this.documentStyles.setProperty(At, `${i}px`), !this.hasSetInitialHeight) { const t = getComputedStyle(document.documentElement).getPropertyValue(Lt); if (!t || "1vh" === t) { const t = .01 * window.innerHeight; this.documentStyles.setProperty(Lt, `${t}px`) } this.hasSetInitialHeight = !0 } if (window.CSS && window.CSS.supports && window.CSS.supports("height", "100dvh")) return; const n = .01 * document.documentElement.clientHeight; this.documentStyles.setProperty(Ct, `${n}px`); const s = .01 * window.innerHeight; if (this.documentStyles.setProperty(Pt, `${s}px`), document.body) { const t = document.createElement("div"); t.style.cssText = "width:1px;height:100vh;position:fixed;left:0;top:0;bottom:0;visibility:hidden;", document.body.appendChild(t); const e = t.clientHeight; t.remove(); const i = .01 * e; this.documentStyles.setProperty(Ot, `${i}px`) } } async init() { this.handleResize(), window.addEventListener("resize", this.handleResize, { passive: !0 }); const t = new CustomEvent("resizeEnd"); window.addEventListener("resize", xt((() => { window.dispatchEvent(t) }), 200), { passive: !0 }), window.addEventListener("orientationchange", this.handleResize, { passive: !0 }) } cleanup() { window.removeEventListener("resize", this.handleResize), window.removeEventListener("orientationchange", this.handleResize) } } let Dt = -1, Rt = !1; function zt(t, e) { return t && 0 !== t.length ? t.nodeName ? [t] : [].slice.call(t[0].nodeName ? t : (e || document).querySelectorAll(t)) : [] } const Nt = [" ", String.fromCharCode(160), String.fromCharCode(8239)], Ft = ["DIV", "H1", "H2", "H3", "H4", "H5", "H6", "P", "UL", "OL", "LI"]; class Ht { isSplit = !1; chars = []; words = []; lines = []; originals = []; lineParents = []; elements = []; options = {}; constructor(t, e = { lineThreshold: .2, type: "lines", noAriaLabel: !1, noBalance: !1, balanceRatio: 1, minLines: 1, handleCJT: !1 }) { this.elements = zt(t), this.options = e, this.options.lineThreshold = "number" == typeof this.options.lineThreshold ? this.options.lineThreshold : .2, this.options.noAriaLabel = "boolean" == typeof this.options.noAriaLabel && this.options.noAriaLabel, this.options.noBalance = "boolean" == typeof this.options.noBalance && this.options.noBalance, this.options.minLines = "number" == typeof this.options.minLines ? this.options.minLines : 1, this.options.handleCJT = "boolean" == typeof this.options.handleCJT && this.options.handleCJT, this.options.type = "string" == typeof this.options.type ? this.options.type : "lines", this.split() } split() { this.isSplit && this.revert(); const t = (this.options.type || "lines").split(",").map((t => t.trim())), e = ~t.indexOf("lines"), i = ~t.indexOf("words"), n = ~t.indexOf("chars"); this.elements.forEach(((t, s) => { if (t.__isParent = !0, this.originals[s] = t.innerHTML.trim(), t.innerHTML = t.innerHTML.trim().split(/\u200b/).join("<wbr>"), this.balance(t), i || e || n) { if (this.words.push(...this.splitElement(t, "word", /\s+/, !0)), 1 === this.words.length && this.words[0].offsetWidth < t.parentElement.offsetWidth && this.lineParents.forEach((t => t.style.removeProperty("max-width"))), e) { this.detectLinesTop(t, this.words, this.options.lineThreshold); if (!this.checkMinLines(t, this.words)) return; t.style.removeProperty("width"), this.attachBr(t, this.words), this.splitBr(t), this.replaceWords(t, (e || i) && !n), this.lines.push(...this.splitLines(t)); if (!this.checkBalance(t, s)) return; this.safeCheckBalance = 0 } !e || i || n || (this.lines.forEach((t => { t.__words.forEach((t => { t.insertAdjacentHTML("beforebegin", t.textContent), t.remove() })), t.normalize() })), this.words.length = 0, this.chars.length = 0), n && (this.words.forEach((t => this.chars.push(...this.splitElement(t, "char", "", !1)))), i || (this.chars.forEach((t => { t.parentElement.insertAdjacentHTML("beforebegin", t.outerHTML), t.remove() })), this.chars = zt(t.getElementsByClassName("char")), this.words.forEach((t => t.remove())), this.words.length = 0)) } if (!this.options.noAriaLabel && (n || i)) { this.recursiveAriaLabel(t); zt(t.querySelectorAll("a, button")).forEach(this.createAriaLabel) } })), this.isSplit = !0 } recursiveAriaLabel(t) { const e = zt(t.childNodes).filter((t => Ft.includes(t.tagName))); e.length ? e.forEach((t => { this.recursiveAriaLabel(t) })) : this.createAriaLabel(t) } createAriaLabel(t) { const e = document.createElement("span"); e.classList.add("sr-only"), e.style.setProperty("position", "absolute"), e.style.setProperty("width", "1px"), e.style.setProperty("height", "1px"), e.style.setProperty("padding", "0"), e.style.setProperty("margin", "-1px"), e.style.setProperty("overflow", "hidden"), e.style.setProperty("clip", "rect(0, 0, 0, 0)"), e.style.setProperty("white-space", "nowrap"), e.style.setProperty("border", "0"), e.textContent = t.textContent, t.appendChild(e) } checkBalance(t, e) { if (this.options.noBalance) return !0; const i = this.lines.filter((t => t.scrollWidth > t.parentElement.offsetWidth)); for (let t = 0; t < i.length; t++) { const n = i[t], s = n.__words[0]?.textContent; if (1 === n.__wordCount && s.match(/\b\w+-\w+\b/) && this.safeCheckBalance <= 5) { const t = s.split("-").join("-&#8203;"); return this.originals[e] = this.originals[e].replace(s, t), this.safeCheckBalance++, this.revert(), this.split(), !1 } n.parentElement.style.removeProperty("max-width") } return !0 } revert() { 0 !== this.originals.length && (this.elements.forEach(((t, e) => t.innerHTML = this.originals[e])), [this.lines, this.words, this.chars, this.originals].forEach((t => t.length = 0)), this.isSplit = !1) } recursiveBalance(t) { t.normalize(), zt(t.childNodes).forEach((e => { e.normalize(), e.__lineParent = Boolean(e.tagName && e.hasChildNodes() && Ft.includes(e.tagName)), e.__lineParent && t?.__lineParent && !t.__isParent && (t.__lineParent = !1), this.recursiveBalance(e) })) } recursiveCheckLineParent(t, e) { zt(t.childNodes).forEach((t => { t.__lineParent && (t.__idx = null, t.textContent.replace(/\s+/g, " ").trim().length > 0 && (t.__lines = [this.createLine()], e.push(t))), this.recursiveCheckLineParent(t, e) })) } balance(t) { this.lineParents = [], this.recursiveBalance(t), this.recursiveCheckLineParent(t, this.lineParents); let e = !0; this.lineParents.length || (this.lineParents.push(t), t.__lines = [this.createLine()], t.__lineParent = !0, t.__idx = null, e = !1), t.__lineParent = !0, this.options.noBalance || this.lineParents.forEach((t => function ({ el: t, ratio: e = 1, useParent: i = !1, debug: n = !1 } = {}) { -1 === Dt && (Dt = "undefined" != typeof CSS && "function" == typeof CSS.supports && CSS.supports("text-wrap", "balance")); const s = i ? t.parentElement : t; if (!s) return; const r = window.getComputedStyle(t); if (Dt && "balance" === r.textWrap) return void (n && !Rt && (console.warn("`text-wrap: balance` is supported by this browser, no need to use `balanceText` here"), Rt = !0)); const o = e => t.style.maxWidth = `${Math.ceil(e)}px`; t.style.maxWidth = ""; const a = s.clientWidth, l = s.clientHeight; let c, h = a / 2 - .25, u = a + .5, d = 0; if (a) { for (; h + 1 < u && d < 2e3;)c = Math.round((h + u) / 2), o(c), s.clientHeight === l ? u = c : h = c, d++; o(u * e + a * (1 - e)) } }({ el: t, ratio: this.options.balanceRatio, useParent: e }))) } recursiveFindBr(t, e, i = !0) { t.normalize(), zt(t.childNodes).forEach((t => { "BR" !== t.tagName || i && t.__newBR ? this.recursiveFindBr(t, e, i) : e.push(t) })) } findAllBr(t, e = !0) { const i = []; return this.recursiveFindBr(t, i, e), i } splitBr(t) { let e = 0; const i = this.findAllBr(t); for (; e < i.length;) { let n = 0, s = i[e++].parentElement; if (!s) return this.splitBr(t); for (; !s.__lineParent;) { if (n++ >= 100) return; if (!s.parentElement) return this.splitBr(t); const e = s.innerHTML, i = s.cloneNode(), r = i.tagName.toLowerCase(), o = i.outerHTML.split(`</${r}>`).join(""), a = e.split(/<br\b[^>]*>/).join(`</${r}><br>${o.trim()}`); s = s.parentElement, s.innerHTML = s.innerHTML.replace(e.trim(), a.trim()), zt(s.childNodes).forEach((t => { "BR" === t.tagName ? t.__newBR = !0 : 3 !== t.nodeType && 0 === t.textContent.trim().length && t.remove() })) } } } isNextBr(t) { return "BR" === t.nextElementSibling?.tagName } isPrevBr(t) { return "BR" === t.previousElementSibling?.tagName } attachBr(t, e) { let i, n = e[0]?.__top || 0; e.forEach(((t, s) => { const r = e[s - 1]; if (n !== t.__top && r) { const e = this.findLineParent(t); e.__idx || (e.__idx = `l${t.__top}`), this.isPrevBr(t.parentElement) || this.isPrevBr(t) || this.isNextBr(r) || i && i?.__idx !== e.__idx || t.insertAdjacentHTML("beforebegin", "<br>"), i = e, n = t.__top } })) } findLineParent(t) { let e = t.parentElement, i = !1; for (; !i;)e.__lineParent && (i = e), e = e.parentElement; return i } replaceWords(t, e) { Array.from(t.getElementsByClassName("word")).forEach(((t, i) => { t.replaceWith(this.words[i]), t.__isCJT && e && (this.words[i].innerHTML = this.words[i].textContent) })) } isCJTChar(t) { return /[\u4E00-\u9FFF\u3400-\u4DBF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF\u0E00-\u0E7F]/.test(t) } handleRawElement(t, e, i, n, s, r, o) { const a = e.wholeText || ""; let l = a; if (l.trim().length) { if ("word" === i || "char" === i) { if (l = a.trim(), Nt.includes(a[0]) && o.push(document.createTextNode(a[0])), this.options.handleCJT && "word" === i) { const e = l.split(/(\s+)/).filter(Boolean); for (let n = 0; n < e.length; n++) { const s = e[n]; if (/^\s+$/.test(s)) { o.push(document.createTextNode(s)); continue } let a = "", l = !1; for (let e = 0; e < s.length; e++) { const n = s[e], c = this.isCJTChar(n); if (c !== l || e === s.length - 1) { if (e === s.length - 1 && (a += n), a) { const e = this.createElement(t, i, a); r.push(e), o.push(e), l && (e.__isCJT = !0, this.chars.push(...this.splitElement(e, "char", "", !1))) } a = e === s.length - 1 ? "" : n, l = c } else a += n } } } else if ("char" === i) { Array.from(l).forEach((e => { const n = this.createElement(t, i, e); r.push(n), o.push(n) })) } else { l.split(/([\s\u00A0\u202F]+)/).forEach(((e, n) => { if (n % 2 == 1) o.push(document.createTextNode(e)); else if (e) { const n = this.createElement(t, i, e); r.push(n), o.push(n) } })) } Nt.includes(a[a.length - 1]) && o.push(document.createTextNode(a[a.length - 1])) } } else o.push(document.createTextNode(a)) } splitElement(t, e, i, n) { t.normalize(); const s = [], r = document.createDocumentFragment(), o = []; return zt(t.childNodes).forEach((t => { if (t.tagName && !t.hasChildNodes()) return o.push(t); t.childNodes.length ? (o.push(t), s.push(...this.splitElement(t, e, i, n))) : this.handleRawElement(r, t, e, i, n, s, o) })), o.forEach((t => r.appendChild(t))), t.innerHTML = "", t.appendChild(r), s } offsetTop(t, e) { let i = e.offsetParent, n = 0, s = t; for (; s && s !== e && s !== i;)n += s.offsetTop, s = s.offsetParent; return n } detectLinesTop(t, e, i) { let n = -999; const s = window.getComputedStyle(t), r = parseFloat(s.fontSize || 0) * i, o = e.map((e => { const i = Math.round(this.offsetTop(e, t)); return Math.abs(i - n) > r && (n = i), e.__top = n, e.__top })); return [...new Set(o)] } splitLines(t) { const e = []; this.findAllBr(t, !1).forEach((t => { const e = this.findLineParent(t), i = this.createLine(); i.__isLine = !0, e?.__lines?.push(i) })); let i = 0; return this.lineParents.forEach(((t, n) => { let s = 0; n > 0 && i++, zt(t.childNodes).forEach((e => { "BR" === e.tagName ? (i++, s++, e.remove()) : (t.__lines[s].appendChild(e), zt(e.childNodes).forEach((t => t.__lineIndex = i)), e.__lineIndex = i) })), t.__lines.forEach((e => t.appendChild(e))), e.push(...t.__lines) })), e.forEach((t => { t.__words = zt(t.getElementsByClassName("word")), t.__wordCount = t.__words.length })), e } createLine(t) { const e = document.createElement("span"); return e.style.setProperty("display", "block"), e.className = "line", t ? t.appendChild(e) : e } createElement(t, e, i) { const n = document.createElement("span"); return "word" === e && n.style.setProperty("display", "inline-block"), n.className = e, n.textContent = i, n.setAttribute("aria-hidden", !0), t.appendChild(n) } checkMinLines(t, e) { if (this.options.minLines <= 1 || this.options.minLines > 1 && e.length <= 1) return !0; let i = e[0].__top, n = 1; e.forEach((t => { const e = t.__top; e > i && (i = e, n++) })); const s = this.options.minLines - n; s > 1 && !this.warned && (this.warned = !0, console.warn(`SplitText is ran ${s} times. Careful as this option might be expensive `.toUpperCase(), t)); const r = this.words[this.words.length - 1]; let o = r.offsetLeft + .9 * r.offsetWidth; return t.offsetWidth < o && (o = t.offsetWidth - .5 * r.offsetWidth), !(n < this.options.minLines && o > 0) || (t.style.width = `${o}px`, this.revert(), this.balance(t), this.split(), !1) } } class Bt { constructor() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.debug = t.debug || !1, this.elements = document.querySelectorAll(".js-split-animation, [data-split-animation]"), this.instances = new Map, this.media = lt.o.matchMedia(), this.scrollTriggers = new Map, this.init() } isDebugEnabled(t) { return this.debug || t.hasAttribute("data-split-debug") } init() { if (!this.elements.length) return void (this.debug && console.log("[SplitAnimation] No elements found")); this.debug && (console.log(`[SplitAnimation] Found ${this.elements.length} elements to animate`), this.elements.forEach(((t, e) => { this.isDebugEnabled(t) && console.log(`[SplitAnimation] Element ${e}:`, { element: t, text: t.textContent.trim(), position: t.getBoundingClientRect(), attributes: Array.from(t.attributes).map((t => ({ name: t.name, value: t.value }))) }) }))), this.elements.forEach((t => { this.createSplitInstance(t) })); const t = window.matchMedia("(min-width: 1025px) and (hover: hover) and (pointer: fine)"), e = xt((() => { t.matches && (this.debug && console.log("[SplitAnimation] Refreshing instances after resize"), this.refresh()) }), 250); window.addEventListener("resize", e, { passive: !0 }), this.cleanupResize = () => { window.removeEventListener("resize", e) } } getAnimationOptions(t) { const e = { stagger: parseFloat(t.dataset.splitStagger) || .05, duration: parseFloat(t.dataset.splitDuration) || .8, delay: parseFloat(t.dataset.splitDelay) || 0, start: t.dataset.splitStart || "top 80%", ease: t.dataset.splitEase || "power3.out" }; return this.isDebugEnabled(t) && console.log("[SplitAnimation] Options for element:", { element: t, text: t.textContent.trim(), options: e }), e } createSplitInstance(t) { let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const i = this.getAnimationOptions(t); this.media.add("(prefers-reduced-motion: reduce)", (() => { this.isDebugEnabled(t) && console.log("[SplitAnimation] Reduced motion - showing text normally:", { element: t, text: t.textContent.trim() }), lt.o.set(t, { opacity: 1 }) })).add("(prefers-reduced-motion: no-preference) and (min-width: 1025px)", (() => { const n = new Ht(t, { type: "words", noAriaLabel: !0 }); if (this.isDebugEnabled(t) && console.log("[SplitAnimation] Created split instance:", { element: t, text: t.textContent.trim(), wordCount: n.words.length, viewportPosition: t.getBoundingClientRect() }), this.instances.set(t, n), e) return void lt.o.set(n.words, { display: "inline-block", opacity: 1, y: 0 }); lt.o.set(n.words, { display: "inline-block", opacity: 0, y: "25%" }); const s = lt.u.create({ trigger: t, start: i.start, markers: this.isDebugEnabled(t), onEnter: () => { this.isDebugEnabled(t) && console.log("[SplitAnimation] Element entered viewport:", { element: t, text: t.textContent.trim(), viewportPosition: t.getBoundingClientRect(), scrollPosition: window.scrollY }), this.animateWords(n.words, i) } }); this.scrollTriggers.set(t, s) })).add("(prefers-reduced-motion: no-preference) and (max-width: 1024px)", (() => { this.isDebugEnabled(t) && console.log("[SplitAnimation] Small screen - showing text normally:", { element: t, text: t.textContent.trim() }), lt.o.set(t, { opacity: 1 }) })) } animateWords(t, e) { this.isDebugEnabled(t[0].parentElement) && console.log("[SplitAnimation] Animating words:", { wordCount: t.length, options: e, firstWord: t[0], lastWord: t[t.length - 1] }), lt.o.to(t, { ease: e.ease, duration: e.duration, delay: e.delay, opacity: 1, stagger: e.stagger, y: 0 }) } destroy() { this.scrollTriggers.forEach(((t, e) => { this.isDebugEnabled(e) && console.log("[SplitAnimation] Killing ScrollTrigger:", { element: e, text: e.textContent.trim() }), t.kill() })), this.scrollTriggers.clear(), this.instances.forEach(((t, e) => { this.isDebugEnabled(e) && console.log("[SplitAnimation] Reverting SplitText instance:", { element: e, text: e.textContent.trim() }), t.revert(), lt.o.set(e, { clearProps: "opacity,y,display" }) })), this.instances.clear(), this.media.revert(), this.cleanupResize && this.cleanupResize() } refresh() { this.debug && console.log("[SplitAnimation] Refreshing instances:", { instanceCount: this.instances.size, elements: Array.from(this.elements).map((t => ({ element: t, text: t.textContent.trim(), position: t.getBoundingClientRect() }))) }), this.destroy(), this.media = lt.o.matchMedia(), this.elements.forEach((t => { this.createSplitInstance(t, !0) })) } } const It = function () { return new Bt(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}) }; function Yt(t, e, i) { return Math.max(t, Math.min(e, i)) } var jt = class { isRunning = !1; value = 0; from = 0; to = 0; currentTime = 0; lerp; duration; easing; onUpdate; advance(t) { if (!this.isRunning) return; let e = !1; if (this.duration && this.easing) { this.currentTime += t; const i = Yt(0, this.currentTime / this.duration, 1); e = i >= 1; const n = e ? 1 : this.easing(i); this.value = this.from + (this.to - this.from) * n } else this.lerp ? (this.value = function (t, e, i, n) { return function (t, e, i) { return (1 - i) * t + i * e }(t, e, 1 - Math.exp(-i * n)) }(this.value, this.to, 60 * this.lerp, t), Math.round(this.value) === this.to && (this.value = this.to, e = !0)) : (this.value = this.to, e = !0); e && this.stop(), this.onUpdate?.(this.value, e) } stop() { this.isRunning = !1 } fromTo(t, e, { lerp: i, duration: n, easing: s, onStart: r, onUpdate: o }) { this.from = this.value = t, this.to = e, this.lerp = i, this.duration = n, this.easing = s, this.currentTime = 0, this.isRunning = !0, r?.(), this.onUpdate = o } }; var qt = class { constructor(t, e, { autoResize: i = !0, debounce: n = 250 } = {}) { this.wrapper = t, this.content = e, i && (this.debouncedResize = function (t, e) { let i; return function (...n) { let s = this; clearTimeout(i), i = setTimeout((() => { i = void 0, t.apply(s, n) }), e) } }(this.resize, n), this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize() } width = 0; height = 0; scrollHeight = 0; scrollWidth = 0; debouncedResize; wrapperResizeObserver; contentResizeObserver; destroy() { this.wrapperResizeObserver?.disconnect(), this.contentResizeObserver?.disconnect(), this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1) } resize = () => { this.onWrapperResize(), this.onContentResize() }; onWrapperResize = () => { this.wrapper instanceof Window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight) }; onContentResize = () => { this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth) }; get limit() { return { x: this.scrollWidth - this.width, y: this.scrollHeight - this.height } } }, Ut = class { events = {}; emit(t, ...e) { let i = this.events[t] || []; for (let t = 0, n = i.length; t < n; t++)i[t]?.(...e) } on(t, e) { return this.events[t]?.push(e) || (this.events[t] = [e]), () => { this.events[t] = this.events[t]?.filter((t => e !== t)) } } off(t, e) { this.events[t] = this.events[t]?.filter((t => e !== t)) } destroy() { this.events = {} } }, Wt = 100 / 6, Vt = { passive: !1 }, $t = class { constructor(t, e = { wheelMultiplier: 1, touchMultiplier: 1 }) { this.element = t, this.options = e, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, Vt), this.element.addEventListener("touchstart", this.onTouchStart, Vt), this.element.addEventListener("touchmove", this.onTouchMove, Vt), this.element.addEventListener("touchend", this.onTouchEnd, Vt) } touchStart = { x: 0, y: 0 }; lastDelta = { x: 0, y: 0 }; window = { width: 0, height: 0 }; emitter = new Ut; on(t, e) { return this.emitter.on(t, e) } destroy() { this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, Vt), this.element.removeEventListener("touchstart", this.onTouchStart, Vt), this.element.removeEventListener("touchmove", this.onTouchMove, Vt), this.element.removeEventListener("touchend", this.onTouchEnd, Vt) } onTouchStart = t => { const { clientX: e, clientY: i } = t.targetTouches ? t.targetTouches[0] : t; this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = { x: 0, y: 0 }, this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: t }) }; onTouchMove = t => { const { clientX: e, clientY: i } = t.targetTouches ? t.targetTouches[0] : t, n = -(e - this.touchStart.x) * this.options.touchMultiplier, s = -(i - this.touchStart.y) * this.options.touchMultiplier; this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = { x: n, y: s }, this.emitter.emit("scroll", { deltaX: n, deltaY: s, event: t }) }; onTouchEnd = t => { this.emitter.emit("scroll", { deltaX: this.lastDelta.x, deltaY: this.lastDelta.y, event: t }) }; onWheel = t => { let { deltaX: e, deltaY: i, deltaMode: n } = t; e *= 1 === n ? Wt : 2 === n ? this.window.width : 1, i *= 1 === n ? Wt : 2 === n ? this.window.height : 1, e *= this.options.wheelMultiplier, i *= this.options.wheelMultiplier, this.emitter.emit("scroll", { deltaX: e, deltaY: i, event: t }) }; onWindowResize = () => { this.window = { width: window.innerWidth, height: window.innerHeight } } }, Xt = class { _isScrolling = !1; _isStopped = !1; _isLocked = !1; _preventNextNativeScrollEvent = !1; _resetVelocityTimeout = null; __rafID = null; isTouching; time = 0; userData = {}; lastVelocity = 0; velocity = 0; direction = 0; options; targetScroll; animatedScroll; animate = new jt; emitter = new Ut; dimensions; virtualScroll; constructor({ wrapper: t = window, content: e = document.documentElement, eventsTarget: i = t, smoothWheel: n = !0, syncTouch: s = !1, syncTouchLerp: r = .075, touchInertiaMultiplier: o = 35, duration: a, easing: l = t => Math.min(1, 1.001 - Math.pow(2, -10 * t)), lerp: c = .1, infinite: h = !1, orientation: u = "vertical", gestureOrientation: d = "vertical", touchMultiplier: p = 1, wheelMultiplier: f = 1, autoResize: m = !0, prevent: g, virtualScroll: v, overscroll: w = !0, autoRaf: y = !1, anchors: _ = !1, autoToggle: b = !1, allowNestedScroll: S = !1, __experimental__naiveDimensions: k = !1 } = {}) { window.lenisVersion = "1.3.1", t && t !== document.documentElement || (t = window), this.options = { wrapper: t, content: e, eventsTarget: i, smoothWheel: n, syncTouch: s, syncTouchLerp: r, touchInertiaMultiplier: o, duration: a, easing: l, lerp: c, infinite: h, gestureOrientation: d, orientation: u, touchMultiplier: p, wheelMultiplier: f, autoResize: m, prevent: g, virtualScroll: v, overscroll: w, autoRaf: y, anchors: _, autoToggle: b, allowNestedScroll: S, __experimental__naiveDimensions: k }, this.dimensions = new qt(t, e, { autoResize: m }), this.updateClassName(), this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, { capture: !0 }), this.options.anchors && this.options.wrapper === window && this.options.wrapper.addEventListener("click", this.onClick, !1), this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1), this.virtualScroll = new $t(i, { touchMultiplier: p, wheelMultiplier: f }), this.virtualScroll.on("scroll", this.onVirtualScroll), this.options.autoToggle && this.rootElement.addEventListener("transitionend", this.onTransitionEnd, { passive: !0 }), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf)) } destroy() { this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, { capture: !0 }), this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1), this.options.anchors && this.options.wrapper === window && this.options.wrapper.removeEventListener("click", this.onClick, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName(), this.__rafID && cancelAnimationFrame(this.__rafID) } on(t, e) { return this.emitter.on(t, e) } off(t, e) { return this.emitter.off(t, e) } onScrollEnd = t => { t instanceof CustomEvent || "smooth" !== this.isScrolling && !1 !== this.isScrolling || t.stopPropagation() }; dispatchScrollendEvent = () => { this.options.wrapper.dispatchEvent(new CustomEvent("scrollend", { bubbles: this.options.wrapper === window, detail: { lenisScrollEnd: !0 } })) }; onTransitionEnd = t => { if (t.propertyName.includes("overflow")) { const t = this.isHorizontal ? "overflow-x" : "overflow-y", e = getComputedStyle(this.rootElement)[t];["hidden", "clip"].includes(e) ? this.stop() : this.start() } }; setScroll(t) { this.isHorizontal ? this.options.wrapper.scrollTo({ left: t, behavior: "instant" }) : this.options.wrapper.scrollTo({ top: t, behavior: "instant" }) } onClick = t => { const e = t.composedPath().find((t => t instanceof HTMLAnchorElement && (t.getAttribute("href")?.startsWith("#") || t.getAttribute("href")?.startsWith("/#") || t.getAttribute("href")?.startsWith("./#")))); if (e) { const t = e.getAttribute("href"); if (t) { const e = "object" == typeof this.options.anchors && this.options.anchors ? this.options.anchors : void 0; let i = `#${t.split("#")[1]}`;["#", "/#", "./#", "#top", "/#top", "./#top"].includes(t) && (i = 0), this.scrollTo(i, e) } } }; onPointerDown = t => { 1 === t.button && this.reset() }; onVirtualScroll = t => { if ("function" == typeof this.options.virtualScroll && !1 === this.options.virtualScroll(t)) return; const { deltaX: e, deltaY: i, event: n } = t; if (this.emitter.emit("virtual-scroll", { deltaX: e, deltaY: i, event: n }), n.ctrlKey) return; if (n.lenisStopPropagation) return; const s = n.type.includes("touch"), r = n.type.includes("wheel"); this.isTouching = "touchstart" === n.type || "touchmove" === n.type; const o = 0 === e && 0 === i; if (this.options.syncTouch && s && "touchstart" === n.type && o && !this.isStopped && !this.isLocked) return void this.reset(); const a = "vertical" === this.options.gestureOrientation && 0 === i || "horizontal" === this.options.gestureOrientation && 0 === e; if (o || a) return; let l = n.composedPath(); l = l.slice(0, l.indexOf(this.rootElement)); const c = this.options.prevent; if (l.find((t => t instanceof HTMLElement && ("function" == typeof c && c?.(t) || t.hasAttribute?.("data-lenis-prevent") || s && t.hasAttribute?.("data-lenis-prevent-touch") || r && t.hasAttribute?.("data-lenis-prevent-wheel") || this.options.allowNestedScroll && this.checkNestedScroll(t, { deltaX: e, deltaY: i }))))) return; if (this.isStopped || this.isLocked) return void n.preventDefault(); if (!(this.options.syncTouch && s || this.options.smoothWheel && r)) return this.isScrolling = "native", this.animate.stop(), void (n.lenisStopPropagation = !0); let h = i; "both" === this.options.gestureOrientation ? h = Math.abs(i) > Math.abs(e) ? i : e : "horizontal" === this.options.gestureOrientation && (h = e), (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || 0 === this.animatedScroll && i > 0 || this.animatedScroll === this.limit && i < 0)) && (n.lenisStopPropagation = !0), n.preventDefault(); const u = s && this.options.syncTouch, d = s && "touchend" === n.type && Math.abs(h) > 5; d && (h = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + h, { programmatic: !1, ...u ? { lerp: d ? this.options.syncTouchLerp : 1 } : { lerp: this.options.lerp, duration: this.options.duration, easing: this.options.easing } }) }; resize() { this.dimensions.resize(), this.animatedScroll = this.targetScroll = this.actualScroll, this.emit() } emit() { this.emitter.emit("scroll", this) } onNativeScroll = () => { if (null !== this._resetVelocityTimeout && (clearTimeout(this._resetVelocityTimeout), this._resetVelocityTimeout = null), this._preventNextNativeScrollEvent) this._preventNextNativeScrollEvent = !1; else if (!1 === this.isScrolling || "native" === this.isScrolling) { const t = this.animatedScroll; this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - t, this.direction = Math.sign(this.animatedScroll - t), this.isStopped || (this.isScrolling = "native"), this.emit(), 0 !== this.velocity && (this._resetVelocityTimeout = setTimeout((() => { this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = !1, this.emit() }), 400)) } }; reset() { this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop() } start() { this.isStopped && (this.reset(), this.isStopped = !1) } stop() { this.isStopped || (this.reset(), this.isStopped = !0) } raf = t => { const e = t - (this.time || t); this.time = t, this.animate.advance(.001 * e), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf)) }; scrollTo(t, { offset: e = 0, immediate: i = !1, lock: n = !1, duration: s = this.options.duration, easing: r = this.options.easing, lerp: o = this.options.lerp, onStart: a, onComplete: l, force: c = !1, programmatic: h = !0, userData: u } = {}) { if (!this.isStopped && !this.isLocked || c) { if ("string" == typeof t && ["top", "left", "start"].includes(t)) t = 0; else if ("string" == typeof t && ["bottom", "right", "end"].includes(t)) t = this.limit; else { let i; if ("string" == typeof t ? i = document.querySelector(t) : t instanceof HTMLElement && t?.nodeType && (i = t), i) { if (this.options.wrapper !== window) { const t = this.rootElement.getBoundingClientRect(); e -= this.isHorizontal ? t.left : t.top } const n = i.getBoundingClientRect(); t = (this.isHorizontal ? n.left : n.top) + this.animatedScroll } } if ("number" == typeof t) { if (t += e, t = Math.round(t), this.options.infinite) { if (h) { this.targetScroll = this.animatedScroll = this.scroll; const e = t - this.animatedScroll; e > this.limit / 2 ? t -= this.limit : e < -this.limit / 2 && (t += this.limit) } } else t = Yt(0, t, this.limit); if (t === this.targetScroll) return a?.(this), void l?.(this); if (this.userData = u ?? {}, i) return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), l?.(this), this.userData = {}, void requestAnimationFrame((() => { this.dispatchScrollendEvent() })); h || (this.targetScroll = t), this.animate.fromTo(this.animatedScroll, t, { duration: s, easing: r, lerp: o, onStart: () => { n && (this.isLocked = !0), this.isScrolling = "smooth", a?.(this) }, onUpdate: (t, e) => { this.isScrolling = "smooth", this.lastVelocity = this.velocity, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), h && (this.targetScroll = t), e || this.emit(), e && (this.reset(), this.emit(), l?.(this), this.userData = {}, requestAnimationFrame((() => { this.dispatchScrollendEvent() })), this.preventNextNativeScrollEvent()) } }) } } } preventNextNativeScrollEvent() { this._preventNextNativeScrollEvent = !0, requestAnimationFrame((() => { this._preventNextNativeScrollEvent = !1 })) } checkNestedScroll(t, { deltaX: e, deltaY: i }) { const n = Date.now(), s = t._lenis ??= {}; let r, o, a, l, c, h, u, d; const p = this.options.gestureOrientation; if (n - (s.time ?? 0) > 2e3) { s.time = Date.now(); const e = window.getComputedStyle(t); s.computedStyle = e; const i = e.overflowX, n = e.overflowY; if (r = ["auto", "overlay", "scroll"].includes(i), o = ["auto", "overlay", "scroll"].includes(n), s.hasOverflowX = r, s.hasOverflowY = o, !r && !o) return !1; if ("vertical" === p && !o) return !1; if ("horizontal" === p && !r) return !1; c = t.scrollWidth, h = t.scrollHeight, u = t.clientWidth, d = t.clientHeight, a = c > u, l = h > d, s.isScrollableX = a, s.isScrollableY = l, s.scrollWidth = c, s.scrollHeight = h, s.clientWidth = u, s.clientHeight = d } else a = s.isScrollableX, l = s.isScrollableY, r = s.hasOverflowX, o = s.hasOverflowY, c = s.scrollWidth, h = s.scrollHeight, u = s.clientWidth, d = s.clientHeight; if (!r && !o || !a && !l) return !1; if (!("vertical" !== p || o && l)) return !1; if (!("horizontal" !== p || r && a)) return !1; let f, m, g, v, w, y; if ("horizontal" === p) f = "x"; else if ("vertical" === p) f = "y"; else { 0 !== e && r && a && (f = "x"), 0 !== i && o && l && (f = "y") } if (!f) return !1; if ("x" === f) m = t.scrollLeft, g = c - u, v = e, w = r, y = a; else { if ("y" !== f) return !1; m = t.scrollTop, g = h - d, v = i, w = o, y = l } return (v > 0 ? m < g : m > 0) && w && y } get rootElement() { return this.options.wrapper === window ? document.documentElement : this.options.wrapper } get limit() { return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"] } get isHorizontal() { return "horizontal" === this.options.orientation } get actualScroll() { const t = this.options.wrapper; return this.isHorizontal ? t.scrollX ?? t.scrollLeft : t.scrollY ?? t.scrollTop } get scroll() { return this.options.infinite ? function (t, e) { return (t % e + e) % e }(this.animatedScroll, this.limit) : this.animatedScroll } get progress() { return 0 === this.limit ? 1 : this.scroll / this.limit } get isScrolling() { return this._isScrolling } set isScrolling(t) { this._isScrolling !== t && (this._isScrolling = t, this.updateClassName()) } get isStopped() { return this._isStopped } set isStopped(t) { this._isStopped !== t && (this._isStopped = t, this.updateClassName()) } get isLocked() { return this._isLocked } set isLocked(t) { this._isLocked !== t && (this._isLocked = t, this.updateClassName()) } get isSmooth() { return "smooth" === this.isScrolling } get className() { let t = "lenis"; return this.options.autoToggle && (t += " lenis-autoToggle"), this.isStopped && (t += " lenis-stopped"), this.isLocked && (t += " lenis-locked"), this.isScrolling && (t += " lenis-scrolling"), "smooth" === this.isScrolling && (t += " lenis-smooth"), t } updateClassName() { this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim() } cleanUpClassName() { this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim() } }; const Gt = { modalSelector: null, lerp: .1, duration: 1.2, prevent: t => null !== t.closest(".widget-container__main .main") }; let Jt, Kt, Zt = null, Qt = !1; const te = document.documentElement, ee = (t, e, i) => { i ? t.classList.add(e) : t.classList.remove(e) }, ie = t => { let { scroll: e } = t; const i = te.scrollHeight, n = te.clientHeight; !Qt && e > 0 && (ee(te, "has-scrolled", !0), Qt = !0), ee(te, "is-stopped-top", e <= 0), ee(te, "is-stopped-bottom", e + n >= i) }; function ne() { return !Zt && Gt.modalSelector && (Zt = document.querySelector(Gt.modalSelector)), Zt } function se() { const t = ne(); t && (Kt && Kt.stop(), Kt = new Xt({ wrapper: t, content: t, lerp: Gt.lerp, duration: Gt.duration }), lt.o.ticker.add((t => { Kt && Kt.raf(1e3 * t) }))) } const re = { main: () => Jt, modal: () => Kt, init: function () { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (Object.assign(Gt, t), 0 === window.scrollY && ee(te, "is-stopped-top", !0), window.matchMedia("(prefers-reduced-motion: reduce)").matches) { document.documentElement.classList.add("has-reduced-motion"); const t = { start: () => { }, stop: () => { }, on: () => { } }; Jt = t, Kt = t, console.log("Lenis is disabled due to reduced motion preference.") } else Jt || (Jt = new Xt({ lerp: Gt.lerp, duration: Gt.duration, wrapper: window, content: document.documentElement, prevent: t => { const e = ne(); return !!e && e.contains(t) || Gt.prevent(t) } }), Jt.on("scroll", lt.u.update), Jt.on("scroll", ie), lt.o.ticker.add((t => { Jt.raf(1e3 * t) }))), ne() && se(), lt.o.ticker.lagSmoothing(0) }, refreshModal: se, setModalSelector: function (t) { Gt.modalSelector = t, Zt = document.querySelector(Gt.modalSelector) }, config: Gt }; class oe { constructor() { this.el = null, this.track = null, this.thumb = null, this.arrowUp = null, this.arrowDown = null, this.isReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches, this.isInverted = !1, this.isDragging = !1, this.dragStartY = 0, this.startScrollTop = 0, this.boundUpdatePosition = this.updatePosition.bind(this), this.boundUpdateSize = this.updateSize.bind(this), this.boundStartDrag = this.startDrag.bind(this), this.boundDrag = this.drag.bind(this), this.boundStopDrag = this.stopDrag.bind(this), this.throttledUpdatePosition = Tt(this.updatePosition.bind(this), 100); const { debouncedFn: t, cleanup: e } = Et(this.updateSize.bind(this), 200); this.debouncedUpdateSize = t, this.cleanupUpdateSize = e; const { debouncedFn: i, cleanup: n } = Et(this.checkViewport.bind(this), 200); this.debouncedViewportCheck = i, this.cleanupViewportCheck = n } checkViewport() { window.innerWidth < 1025 && this.cleanup() } init() { this.isReducedMotion || window.innerWidth < 1025 || (this.createScrollbar(), this.addEventListeners(), this.updateScrollbar(), this.observer = new MutationObserver((() => { this.refresh() })), this.observer.observe(document.body, { childList: !0, subtree: !0 })) } createScrollbar() { this.el = document.createElement("div"), this.el.className = "scroller", this.el.setAttribute("role", "scrollbar"), this.el.setAttribute("aria-label", "Scrollbar"), this.el.setAttribute("aria-controls", "main-content"), this.el.setAttribute("aria-orientation", "vertical"), this.el.setAttribute("aria-valuenow", "0"), this.el.setAttribute("tabindex", "0"), this.track = document.createElement("div"), this.track.className = "scroller_track", this.thumb = document.createElement("div"), this.thumb.className = "scroller_thumb", this.arrowUp = document.createElement("button"), this.arrowUp.className = "scroller_arrow -up", this.arrowUp.setAttribute("aria-label", "Scroll up"), this.arrowDown = document.createElement("button"), this.arrowDown.className = "scroller_arrow -down", this.arrowDown.setAttribute("aria-label", "Scroll down"), this.el.append(this.arrowUp, this.track, this.arrowDown), this.track.append(this.thumb), document.body.append(this.el) } addEventListeners() { window.addEventListener("scroll", this.throttledUpdatePosition, { passive: !0 }), window.addEventListener("resize", this.debouncedUpdateSize, { passive: !0 }), window.addEventListener("resize", this.debouncedViewportCheck, { passive: !0 }), this.track.addEventListener("click", this.onClickScrollTo.bind(this)), this.arrowUp.addEventListener("click", (() => this.onClickArrowScrollTo(-1))), this.arrowDown.addEventListener("click", (() => this.onClickArrowScrollTo(1))), this.thumb.addEventListener("mousedown", this.boundStartDrag), this.el.addEventListener("keydown", this.onKeyDown.bind(this)) } updateSize() { const t = document.documentElement.scrollHeight, e = window.innerHeight / t * this.track.clientHeight; this.thumb.style.height = `${e}px` } updatePosition() { if (!this.el) return; const t = document.documentElement.scrollHeight, e = window.innerHeight, i = window.pageYOffset / (t - e) * 100; this.ariaValueNow = Math.round(i), this.ariaValueNow = Math.max(0, Math.min(this.ariaValueNow, 100)), this.el.setAttribute("aria-valuenow", this.ariaValueNow.toString()); const n = i / 100 * (this.track.clientHeight - this.thumb.clientHeight); this.thumb.style.transform = `translateY(${n}px)` } updateScrollbar() { this.updateSize(), this.updatePosition(), this.rafId = requestAnimationFrame(this.updateScrollbar.bind(this)) } onClickScrollTo(t) { if (!this.el) return; if (t.target === this.thumb) return; const e = (t.clientY - this.track.getBoundingClientRect().top) / this.track.clientHeight * (document.documentElement.scrollHeight - window.innerHeight); this.scrollTo(e) } onClickArrowScrollTo(t) { const e = window.pageYOffset, i = window.innerHeight * t; this.scrollTo(e + i) } scrollTo(t) { if (window.utils?.lenis?.main) { const e = window.utils.lenis.main(); e?.scrollTo && e.scrollTo(t, { duration: 1, easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)) }) } } startDrag(t) { this.isDragging = !0, this.dragStartY = t.clientY, this.startScrollTop = window.pageYOffset, window.addEventListener("mousemove", this.boundDrag), window.addEventListener("mouseup", this.boundStopDrag), this.thumb.classList.add("no-transition") } drag(t) { if (!this.isDragging) return; const e = (t.clientY - this.dragStartY) / this.track.clientHeight * document.documentElement.scrollHeight; this.scrollTo(this.startScrollTop + e) } stopDrag() { this.isDragging = !1, window.removeEventListener("mousemove", this.boundDrag), window.removeEventListener("mouseup", this.boundStopDrag), this.thumb.classList.remove("no-transition") } onKeyDown(t) { let e = 0; switch (t.key) { case "ArrowUp": e = -100; break; case "ArrowDown": e = 100; break; case "PageUp": e = -window.innerHeight; break; case "PageDown": e = window.innerHeight; break; case "Home": e = -window.pageYOffset; break; case "End": e = document.documentElement.scrollHeight - window.innerHeight - window.pageYOffset; break; default: return }t.preventDefault(), this.scrollTo(window.pageYOffset + e) } invert(t) { this.el && (this.el.classList.toggle("is-inverted", t), this.isInverted = t) } resume() { if (this.el && this.el.classList.remove("is-stopped"), window.utils?.lenis?.main) { const t = window.utils.lenis.main(); t?.start && t.start() } } pause() { if (this.el && this.el.classList.add("is-stopped"), window.utils?.lenis?.main) { const t = window.utils.lenis.main(); t?.stop && t.stop() } } refresh() { this.updateSize(), this.updatePosition() } cleanup() { window.removeEventListener("scroll", this.throttledUpdatePosition), window.removeEventListener("resize", this.debouncedUpdateSize), window.removeEventListener("resize", this.debouncedViewportCheck), this.cleanupUpdateSize && this.cleanupUpdateSize(), this.cleanupViewportCheck && this.cleanupViewportCheck(), this.observer && (this.observer.disconnect(), this.observer = null), this.rafId && (cancelAnimationFrame(this.rafId), this.rafId = null), this.el && (this.el.remove(), this.el = null) } } function ae() { return ae = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]) } return t }, ae.apply(this, arguments) } class le { constructor(t = {}, e = null, i = null) { this._gsap = e, this._ScrollTrigger = i, this.defaultOptions = { elements: "[data-inview]", duration: 1, delay: .1, start: "top 90%", ease: "power4", stagger: .08, animationFrom: { opacity: 0, "will-change": "transform", y: 20 }, animationTo: { opacity: 1, y: 0 }, screen: "(min-width: 1025px)", autoStart: !0, inviewClass: "is-inview", viewedClass: "has-viewed", debug: !1 }, this.options = ae({}, this.defaultOptions, t), this.triggers = [], this.animatedElementsList = [], this.eventListeners = {}, this.getOption("autoStart") && this.init() } register(t, e) { this._gsap = t, this._ScrollTrigger = e } getOption(t) { return this.options[t] } init() { if (null != this._gsap) if (null != this._ScrollTrigger) try { this._gsap.utils.toArray(this.getOption("elements")).forEach(((t, e) => { let i = []; t.hasAttribute("data-inview-scope") ? (this.addScopedElements(t, i), this.addChildElements(t, i)) : i.push({ el: t, order: t.dataset.inviewOrder }), this.sortAnimatedElements(i), this.animateElements(t, i, e) })) } catch (t) { console.error("Error initialising InviewDetection:", t) } else console.log("ScrollTrigger is not registered. Exiting"); else console.log("GSAP is not registered. Exiting") } on(t, e) { this.eventListeners[t] || (this.eventListeners[t] = []), this.eventListeners[t].push(e) } emit(t, e) { const i = this.eventListeners[t]; i && i.forEach((t => { t(e) })) } start() { this.init() } addScopedElements(t, e) { try { t.dataset.inviewScope && t.querySelectorAll(":scope " + t.dataset.inviewScope).forEach((t => { const i = parseFloat(t.dataset.inviewOrder); e.push({ el: t, order: i }), this.animatedElementsList.push(t) })) } catch (t) { console.error("Error adding scoped elements:", t) } } addChildElements(t, e) { try { t.querySelectorAll(":scope [data-inview-child]").forEach((t => { const i = parseFloat(t.dataset.inviewOrder); e.push({ el: t, order: i }), this.animatedElementsList.push(t) })) } catch (t) { console.error("Error adding child elements:", t) } } findClosestParentOrderAttr(t) { let e = t.parentElement, i = 0; for (; e && i <= 5;) { if (e.hasAttribute("data-inview-order")) return parseFloat(e.getAttribute("data-inview-order")); e = e.parentElement, i++ } if (t.hasAttribute("data-inview-order")) { const e = t.getAttribute("data-inview-order"); return !isNaN(+e) && +e } return !1 } sortAnimatedElements(t) { t.sort(((t, e) => { var i, n; return (null != (i = t.order) ? i : 1) - (null != (n = e.order) ? n : -1) })); for (let e = 0; e < t.length; e++)t[e] = t[e].el } animateElements(t, e, i) { var n = this; let s = [], r = []; const o = this._gsap.matchMedia(), a = t.dataset.inviewScreen || this.getOption("screen"); o.add(a, (() => { let i = this._gsap.timeline({ scrollTrigger: { trigger: t, start: t.dataset.inviewStart || this.getOption("start"), invalidateOnRefresh: !0, onEnter: async function () { if (i.play(), i.hasPlayed = !0, t.classList.add(n.getOption("viewedClass")), t.hasAttribute("data-inview-call")) { const e = t.getAttribute("data-inview-call"); window.dispatchEvent(new CustomEvent(e, { detail: { target: t } })) } n.eventListeners.onEnter && n.emit("onEnter", t) }, onLeave: () => { t.hasAttribute("data-inview-repeat") && i.restart().pause(), this.eventListeners.onLeave && this.emit("onLeave", t) }, onEnterBack: async function () { t.hasAttribute("data-inview-repeat") ? (i.restart(), i.hasPlayed = !0) : i.hasPlayed || (i.play(), i.hasPlayed = !0), n.eventListeners.onEnterBack && n.emit("onEnterBack", t) }, onLeaveBack: () => { t.hasAttribute("data-inview-repeat") && i.restart().pause(), this.eventListeners.onLeaveBack && this.emit("onLeaveBack", t) }, markers: !(!this.getOption("debug") && !t.hasAttribute("data-inview-debug")), toggleClass: { targets: t, className: this.getOption("inviewClass") } } }); i.hasPlayed = !1, this.triggers.push(i.scrollTrigger); let o = 0; e.forEach((e => { try { let n = this.getOption("animationFrom"), a = this.getOption("animationTo"); e.dataset.inviewFrom ? n = JSON.parse(e.dataset.inviewFrom) : t.dataset.inviewFrom && (n = JSON.parse(t.dataset.inviewFrom)), e.dataset.inviewTo ? a = JSON.parse(e.dataset.inviewTo) : t.dataset.inviewTo && (a = JSON.parse(t.dataset.inviewTo)), s.push(n), r.push(a), this._gsap.set(e, n); let l = t.dataset.inviewStagger || this.getOption("stagger"); i.to(e, ae({}, a, { duration: t.dataset.inviewDuration || this.getOption("duration"), delay: t.dataset.inviewDelay || this.getOption("delay"), ease: t.dataset.inviewEase || this.getOption("ease") }), o), o += parseFloat(l) } catch (t) { console.error(`An error occurred while animating the element: ${t}`) } })), i.pause() })), (this.getOption("debug") || t.hasAttribute("data-inview-debug")) && this.debugMode(t, e, s, r, i) } debugMode(t, e, i, n, s) { console.group(`InviewDetection() debug instance (#${s + 1})`), console.log({ parent: t, elements: e, screen: this.getOption("screen"), animationFrom: i, animationTo: n, duration: this.getOption("duration"), delay: this.getOption("delay"), start: this.getOption("start"), ease: this.getOption("ease"), stagger: this.getOption("stagger") }), console.groupEnd() } refresh() { this._ScrollTrigger.refresh(), this.eventListeners.refresh && this.emit("refresh", parent) } stop() { this.triggers.forEach((t => t.kill())), this.triggers = [], this._gsap.utils.toArray(this.getOption("elements")).concat(this.animatedElementsList).forEach((t => { this._gsap.killTweensOf(t) })), this.eventListeners.stop && this.emit("stop", parent) } restart() { this._gsap.utils.toArray(this.getOption("elements")).forEach((t => { this._gsap.killTweensOf(t) })), this.init(), this.eventListeners.restart && this.emit("restart", parent) } } window.InviewDetection = le; const ce = new le({ autoStart: !1, screen: "(prefers-reduced-motion: no-preference)", animationFrom: { opacity: 0, y: 20 }, animationTo: { opacity: 1, y: 0 } }); ce.register(lt.o, lt.u); var he = ce; function ue() { return ue = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]) } return t }, ue.apply(this, arguments) } class de { constructor(t = {}, e = null, i = null) { this._gsap = e, this._ScrollTrigger = i, this.elements = t.elements || "[data-onscroll]", this.screen = t.screen || "(min-width: 1025px)", this.triggers = new Map, this.debug = t.debug || !1, this.scrollingClass = t.scrollingClass || "is-scrolling", this.scrolledClass = t.scrolledClass || "has-scrolled", this.stickyClass = t.stickyClass || "is-sticky", this.stuckClass = t.stuckClass || "has-stuck", this.eventHandlers = {}, this.autoStart = void 0 === t.autoStart || t.autoStart, this.autoStart && this.init() } register(t, e) { this._gsap = t, this._ScrollTrigger = e } init() { if (null != this._gsap) if (null != this._ScrollTrigger) try { this._gsap.utils.toArray(this.elements).forEach(((t, e) => { const i = this.getTrigger(t), n = this.getScreen(t), s = this._gsap.matchMedia(), r = this.getFromProperties(t); r.startAt = { backgroundColor: "red" }, r.immediateRender = !0; const o = this.getToProperties(t, e, i); s.add(n, (() => { const e = this._gsap.fromTo(t, r, o); this.triggers.set(e.scrollTrigger, { element: t, fromProperties: r, toProperties: o, gsapAnimation: e }) })), this.debugMode(t, e) })) } catch (t) { console.error("Error initialising OnscrollDetection:", t) } else console.log("ScrollTrigger is not registered. Exiting"); else console.log("GSAP is not registered. Exiting") } start() { this.init() } on(t, e) { this.eventHandlers[t] || (this.eventHandlers[t] = []), this.eventHandlers[t].push(e) } emit(t, ...e) { this.eventHandlers[t] && this.eventHandlers[t].forEach((t => t(...e))) } getTrigger(t) { return this.hasAttributes(t, ["data-onscroll-auto"]) && !t.hasAttribute("data-onscroll-trigger") ? t.parentElement : t.hasAttribute("data-onscroll-trigger") ? document.querySelector(t.dataset.onscrollTrigger) || (console.error(`Element specified by data-onscroll-trigger not found: ${t.dataset.onscrollTrigger}`), t) : t } getScreen(t) { return t.hasAttribute("data-onscroll-screen") ? t.dataset.onscrollScreen : this.screen } getFromProperties(t) { const e = this.getAnimateFrom(t), { offset: i } = this.getOffsetAndDistance(t); return ue({}, e, { bottom: this.hasAttributes(t, ["data-onscroll-auto", "data-onscroll-reverse"]) ? "auto" : null, top: this.hasAttributes(t, ["data-onscroll-auto"]) && !this.hasAttributes(t, ["data-onscroll-reverse"]) ? "auto" : null, x: !this.hasAttributes(t, ["data-onscroll-direction"]) || "x" !== this.getDirection(t) && "xy" !== this.getDirection(t) ? null : i, y: !this.hasAttributes(t, ["data-onscroll-direction"]) || this.hasAttributes(t, ["data-onscroll-direction"]) && ("y" === this.getDirection(t) || "xy" === this.getDirection(t)) ? i : null }) } getToProperties(t, e, i) { const n = this.getAnimateTo(t), s = this.getStickyProperties(t), r = this.hasAttributes(t, ["data-onscroll-sticky"]), o = t.getAttribute("data-onscroll-call"), a = t.getAttribute("data-onscroll-progress"), l = (e, i) => { o && window.dispatchEvent(new CustomEvent(o, { detail: { target: t, direction: 1 === i ? "down" : "up", when: e } })) }; return ue({}, n, { x: this.getX(t), y: this.getY(t), ease: "none", scrollTrigger: { trigger: r ? t : i, start: this.getStart(t), end: this.getEnd(t), invalidateOnRefresh: !0, pin: s.pin, pinSpacing: s.pinSpacing, scrub: this.getScrub(t), markers: this.hasAttributes(t, ["data-onscroll-debug"]), onUpdate: e => { if (a) { let i = e.progress.toFixed(2); t.style.setProperty("--onscrollProgress", i), ((e, i) => { a && window.dispatchEvent(new CustomEvent(a, { detail: { element: t, progress: e, direction: 1 === i ? "down" : "up" } })) })(i, e.direction) } }, onToggle: e => { !e.isActive && a && t.style.setProperty("--onscrollProgress", 0) }, onEnter: ({ direction: e }) => { t.classList.add(this.scrollingClass, this.scrolledClass), r && t.classList.add(this.stickyClass, this.stuckClass), l("onEnter", e), this.emit("onEnter", t) }, onLeave: ({ direction: e }) => { t.classList.remove(this.scrollingClass), r && t.classList.remove(this.stickyClass), l("onLeave", e), this.emit("onLeave", t) }, onEnterBack: ({ direction: e }) => { t.classList.add(this.scrollingClass), r && t.classList.add(this.stickyClass), l("onEnterBack", e), this.emit("onEnterBack", t) }, onLeaveBack: ({ direction: e }) => { t.classList.remove(this.scrollingClass), r && t.classList.remove(this.stickyClass), l("onLeaveBack", e), this.emit("onLeaveBack", t) } } }) } getStickyProperties(t) { return t.hasAttribute("data-onscroll-sticky") ? { pin: !0, pinSpacing: !1 } : { pin: !1, pinSpacing: !0 } } hasAttributes(t, e) { return e.every((e => t.hasAttribute(e))) } getAnimateFrom(t) { return t.hasAttribute("data-onscroll-from") ? JSON.parse(t.dataset.onscrollFrom) : [] } getAnimateTo(t) { return t.hasAttribute("data-onscroll-to") ? JSON.parse(t.dataset.onscrollTo) : [] } getOffset(t) { return t.hasAttribute("data-onscroll-offset") ? parseInt(t.dataset.onscrollOffset) : null } getDirection(t) { return t.dataset.onscrollDirection ? t.dataset.onscrollDirection : "y" } getX(t) { return t.hasAttribute("data-onscroll-sticky") ? null : !this.hasAttributes(t, ["data-onscroll-direction"]) || "x" !== this.getDirection(t) && "xy" !== this.getDirection(t) ? void 0 : this.getDistanceOrSpeed(t) } getY(t) { return t.hasAttribute("data-onscroll-sticky") ? null : !this.hasAttributes(t, ["data-onscroll-direction"]) || this.hasAttributes(t, ["data-onscroll-direction"]) && ("y" === this.getDirection(t) || "xy" === this.getDirection(t)) ? this.getDistanceOrSpeed(t) : void 0 } getOffsetAndDistance(t) { if (t.hasAttribute("data-onscroll-sticky")) return { offset: null, distance: null }; let e = null, i = null; const n = this.getTrigger(t).offsetHeight; if (t.hasAttribute("data-onscroll-offset")) { const [s, r] = t.dataset.onscrollOffset.split(","); e = s.trim().endsWith("%") ? parseFloat(s) / 100 * n : parseFloat(s), i = r.trim().endsWith("%") ? parseFloat(r) / 100 * n : parseFloat(r) } return { offset: e, distance: i } } getDistanceOrSpeed(t) { const { distance: e } = this.getOffsetAndDistance(t), i = window.innerHeight; let n = t.dataset.onscrollSpeed, s = 0; if (n && n.includes(",")) { const [t, e] = n.split(",").map(parseFloat); n = t, s = e / 100 * i, n < 0 && (s *= -1) } else n = parseFloat(n || "0"); if (this.hasAttributes(t, ["data-onscroll-auto"])) { const e = this.getTrigger(t), i = Math.abs(e.offsetHeight - t.offsetHeight); return this.hasAttributes(t, ["data-onscroll-reverse"]) ? -i : i } return this.hasAttributes(t, ["data-onscroll-speed"]) ? n * t.offsetHeight + s : null !== e ? e : void 0 } getScrub(t) { return !this.hasAttributes(t, ["data-onscroll-delay"]) || parseInt(t.dataset.onscrollDelay) } getStart(t) { if (t.hasAttribute("data-onscroll-sticky")) { let e = 0; if (t.hasAttribute("data-onscroll-offset")) { const [i] = t.dataset.onscrollOffset.split(","); e = parseFloat(i) } return (t.dataset.onscrollStart ? t.dataset.onscrollStart : "top top") + "+=" + e } if (this.hasAttributes(t, ["data-onscroll-preset", "data-onscroll-offset"]) && "x" !== this.getDirection(t) && !this.hasAttributes(t, ["data-onscroll-start", "data-onscroll-sticky"])) { const [e] = t.dataset.onscrollOffset.split(","); return (parseFloat(e) < 0 ? "top+=" + e : "top+=0") + " bottom" } return t.dataset.onscrollStart ? t.dataset.onscrollStart : "top bottom" } getEnd(t) { if (t.hasAttribute("data-onscroll-sticky")) { const e = this.getTrigger(t); let i = 0; if (t.hasAttribute("data-onscroll-offset")) { const [, e] = t.dataset.onscrollOffset.split(","); i = parseFloat(e) } return t.dataset.onscrollEnd ? t.dataset.onscrollEnd : "+=" + (e.clientHeight - t.clientHeight - i) } if (this.hasAttributes(t, ["data-onscroll-speed"]) && !t.hasAttribute("data-onscroll-end")) { const e = this.getDistanceOrSpeed(t); return `bottom${e >= 0 ? "+=" : "-="}${Math.abs(e)} top` } if (this.hasAttributes(t, ["data-onscroll-preset", "data-onscroll-offset"]) && "x" !== this.getDirection(t) && !this.hasAttributes(t, ["data-onscroll-end", "data-onscroll-sticky"])) { const [, e] = t.dataset.onscrollOffset.split(","); return "bottom+=" + e + " top" } return t.dataset.onscrollEnd ? t.dataset.onscrollEnd : "bottom top" } debugMode(t, e) { if (!this.debug && !this.hasAttributes(t, ["data-onscroll-debug"])) return; const { offset: i } = this.getOffsetAndDistance(t); let n = 0, s = 0; if (this.hasAttributes(t, ["data-onscroll-speed"])) { const e = t.dataset.onscrollSpeed.split(","); n = parseFloat(e[0]), s = parseFloat(e[1]), n = isNaN(n) ? 0 : n, s = isNaN(s) ? 0 : s } const r = t.dataset, o = this.hasAttributes(t, ["data-onscroll-speed"]), a = this.hasAttributes(t, ["data-onscroll-preset"]), l = this.hasAttributes(t, ["data-onscroll-sticky"]), c = this.hasAttributes(t, ["data-onscroll-reverse"]); console.group(`OnscrollDetection() debug instance (#${e + 1})`), console.log({ element: t, trigger: this.getTrigger(t), triggerStart: this.getStart(t), triggerEnd: this.getEnd(t), auto: this.hasAttributes(t, ["data-onscroll-auto"]), offsetBefore: i, offsetAfter: this.getDistanceOrSpeed(t), delay: this.getScrub(t), screen: this.getScreen(t), speed: o ? `${parseFloat(n * t.clientHeight + s / 100 * window.innerHeight)} (${parseFloat(n)}x element height + ${parseFloat(s)}% of the viewport height)` : null, direction: this.hasAttributes(t, ["data-onscroll-direction"]) ? r.onscrollDirection : "y", preset: a, reverse: c, sticky: l, animateFrom: this.getAnimateFrom(t), animateTo: this.getAnimateTo(t), customEvent: this.hasAttributes(t, ["data-onscroll-call"]) ? r.onscrollCall : null }), [{ condition: this.hasAttributes(t, ["data-onscroll-offset"]) && o, message: "`offset` and `speed` should not be used together" }, { condition: a && (this.hasAttributes(t, ["data-onscroll-start"]) || this.hasAttributes(t, ["data-onscroll-end"])), message: "`preset` should not be used in conjunction with `start` or `end` settings" }, { condition: l && o, message: "`sticky` should not be used in conjunction with `speed`" }, { condition: l && this.hasAttributes(t, ["data-onscroll-offset"]) && this.hasAttributes(t, ["data-onscroll-end"]), message: "Your bottom `offset` will be ignored due to custom `end` on the `sticky` element" }, { condition: c && (!this.hasAttributes(t, ["data-onscroll-auto"]) || this.hasAttributes(t, ["data-onscroll-offset"]) || l || o), message: "`reverse` is not compatible with `offset`, `speed` or `sticky` and should only be used in conjunction with `auto`" }, { condition: o && a, message: "`preset` has no effect in conjunction with `speed` setting" }, { condition: "x" === this.getDirection(t) && a, message: "`preset` has no effect in conjunction with `x` direction" }].forEach((t => t.condition && console.warn(t.message))), console.groupEnd() } fetch(t) { if ("number" == typeof t) return Array.from(this.triggers.keys())[t]; { let e = null; return this.triggers.forEach(((i, n) => { i.element === t && (e = n) })), e } } refresh() { this._ScrollTrigger.refresh(), this.emit("refresh") } restart() { this.stop(), this._ScrollTrigger.getAll().forEach((t => t.kill())), this._ScrollTrigger.refresh(), this.init(), this.emit("restart") } stop(t = null) { if (t) { const e = this.triggers.get(t); e && (e.gsapAnimation.kill(), this.triggers.delete(t)) } else this.triggers.forEach((({ gsapAnimation: t }) => { t.kill() })), this.triggers.clear(); this.emit("stop", t) } update(t, e, i) { const n = this.triggers.get(t); if (n) { n.gsapAnimation.kill(); const s = this._gsap.fromTo(n.element, e, i), r = this._ScrollTrigger.create({ animation: s, trigger: this.getTrigger(n.element), start: this.getStart(n.element), end: this.getEnd(n.element), scrub: this.getScrub(n.element) }); this.triggers.set(t, ue({}, n, { fromProperties: e, toProperties: i, gsapAnimation: s, trigger: r })) } } destroy() { this.stop(), this.triggers = null } } window.OnscrollDetection = de; const pe = new de({ autoStart: !1, screen: "(min-width: 1025px) and (prefers-reduced-motion: no-preference)" }); pe.register(lt.o, lt.u); var fe = pe, me = function () { function t(e) { void 0 === e && (e = {}), this.options = Object.assign({}, { el: null, container: document.body, className: "mf-cursor", innerClassName: "mf-cursor-inner", textClassName: "mf-cursor-text", mediaClassName: "mf-cursor-media", mediaBoxClassName: "mf-cursor-media-box", iconSvgClassName: "mf-svgsprite", iconSvgNamePrefix: "-", iconSvgSrc: "", dataAttr: "cursor", hiddenState: "-hidden", textState: "-text", iconState: "-icon", activeState: "-active", mediaState: "-media", stateDetection: { "-pointer": "a,button" }, visible: !0, visibleOnState: !1, speed: .55, ease: "expo.out", overwrite: !0, skewing: 0, skewingText: 2, skewingIcon: 2, skewingMedia: 2, skewingDelta: .001, skewingDeltaMax: .15, stickDelta: .15, showTimeout: 0, hideOnLeave: !0, hideTimeout: 300, hideMediaTimeout: 300, initialPos: [-window.innerWidth, -window.innerHeight] }, e), this.options.visible && null == e.stateDetection && (this.options.stateDetection["-hidden"] = "iframe"), this.gsap = t.gsap || window.gsap, this.el = "string" == typeof this.options.el ? document.querySelector(this.options.el) : this.options.el, this.container = "string" == typeof this.options.container ? document.querySelector(this.options.container) : this.options.container, this.skewing = this.options.skewing, this.pos = { x: this.options.initialPos[0], y: this.options.initialPos[1] }, this.vel = { x: 0, y: 0 }, this.event = {}, this.events = [], this.init() } t.registerGSAP = function (e) { t.gsap = e }; var e = t.prototype; return e.init = function () { this.el || this.create(), this.createSetter(), this.bind(), this.render(!0), this.ticker = this.render.bind(this, !1), this.gsap.ticker.add(this.ticker) }, e.create = function () { this.el = document.createElement("div"), this.el.className = this.options.className, this.el.classList.add(this.options.hiddenState), this.inner = document.createElement("div"), this.inner.className = this.options.innerClassName, this.text = document.createElement("div"), this.text.className = this.options.textClassName, this.media = document.createElement("div"), this.media.className = this.options.mediaClassName, this.mediaBox = document.createElement("div"), this.mediaBox.className = this.options.mediaBoxClassName, this.media.appendChild(this.mediaBox), this.inner.appendChild(this.media), this.inner.appendChild(this.text), this.el.appendChild(this.inner), this.container.appendChild(this.el) }, e.createSetter = function () { this.setter = { x: this.gsap.quickSetter(this.el, "x", "px"), y: this.gsap.quickSetter(this.el, "y", "px"), rotation: this.gsap.quickSetter(this.el, "rotation", "deg"), scaleX: this.gsap.quickSetter(this.el, "scaleX"), scaleY: this.gsap.quickSetter(this.el, "scaleY"), wc: this.gsap.quickSetter(this.el, "willChange"), inner: { rotation: this.gsap.quickSetter(this.inner, "rotation", "deg") } } }, e.bind = function () { var t = this; this.event.mouseleave = function () { return t.hide() }, this.event.mouseenter = function () { return t.show() }, this.event.mousedown = function () { return t.addState(t.options.activeState) }, this.event.mouseup = function () { return t.removeState(t.options.activeState) }, this.event.mousemoveOnce = function () { return t.show() }, this.event.mousemove = function (e) { t.gsap.to(t.pos, { x: t.stick ? t.stick.x - (t.stick.x - e.clientX) * t.options.stickDelta : e.clientX, y: t.stick ? t.stick.y - (t.stick.y - e.clientY) * t.options.stickDelta : e.clientY, overwrite: t.options.overwrite, ease: t.options.ease, duration: t.visible ? t.options.speed : 0, onUpdate: function () { return t.vel = { x: e.clientX - t.pos.x, y: e.clientY - t.pos.y } } }) }, this.event.mouseover = function (e) { for (var i = e.target; i && i !== t.container && (!e.relatedTarget || !i.contains(e.relatedTarget)); i = i.parentNode) { for (var n in t.options.stateDetection) i.matches(t.options.stateDetection[n]) && t.addState(n); if (t.options.dataAttr) { var s = t.getFromDataset(i); s.state && t.addState(s.state), s.text && t.setText(s.text), s.icon && t.setIcon(s.icon), s.img && t.setImg(s.img), s.video && t.setVideo(s.video), void 0 !== s.show && t.show(), void 0 !== s.stick && t.setStick(s.stick || i) } } }, this.event.mouseout = function (e) { for (var i = e.target; i && i !== t.container && (!e.relatedTarget || !i.contains(e.relatedTarget)); i = i.parentNode) { for (var n in t.options.stateDetection) i.matches(t.options.stateDetection[n]) && t.removeState(n); if (t.options.dataAttr) { var s = t.getFromDataset(i); s.state && t.removeState(s.state), s.text && t.removeText(), s.icon && t.removeIcon(), s.img && t.removeImg(), s.video && t.removeVideo(), void 0 !== s.show && t.hide(), void 0 !== s.stick && t.removeStick() } } }, this.options.hideOnLeave && this.container.addEventListener("mouseleave", this.event.mouseleave, { passive: !0 }), this.options.visible && this.container.addEventListener("mouseenter", this.event.mouseenter, { passive: !0 }), this.options.activeState && (this.container.addEventListener("mousedown", this.event.mousedown, { passive: !0 }), this.container.addEventListener("mouseup", this.event.mouseup, { passive: !0 })), this.container.addEventListener("mousemove", this.event.mousemove, { passive: !0 }), this.options.visible && this.container.addEventListener("mousemove", this.event.mousemoveOnce, { passive: !0, once: !0 }), (this.options.stateDetection || this.options.dataAttr) && (this.container.addEventListener("mouseover", this.event.mouseover, { passive: !0 }), this.container.addEventListener("mouseout", this.event.mouseout, { passive: !0 })) }, e.render = function (t) { if (!0 === t || 0 !== this.vel.y && 0 !== this.vel.x) { if (this.trigger("render"), this.setter.wc("transform"), this.setter.x(this.pos.x), this.setter.y(this.pos.y), this.skewing) { var e = Math.sqrt(Math.pow(this.vel.x, 2) + Math.pow(this.vel.y, 2)), i = Math.min(e * this.options.skewingDelta, this.options.skewingDeltaMax) * this.skewing, n = 180 * Math.atan2(this.vel.y, this.vel.x) / Math.PI; this.setter.rotation(n), this.setter.scaleX(1 + i), this.setter.scaleY(1 - i), this.setter.inner.rotation(-n) } } else this.setter.wc("auto") }, e.show = function () { var t = this; this.trigger("show"), clearInterval(this.visibleInt), this.visibleInt = setTimeout((function () { t.el.classList.remove(t.options.hiddenState), t.visible = !0, t.render(!0) }), this.options.showTimeout) }, e.hide = function () { var t = this; this.trigger("hide"), clearInterval(this.visibleInt), this.el.classList.add(this.options.hiddenState), this.visibleInt = setTimeout((function () { return t.visible = !1 }), this.options.hideTimeout) }, e.toggle = function (t) { !0 === t || !1 !== t && !this.visible ? this.show() : this.hide() }, e.addState = function (t) { var e; if (this.trigger("addState", t), t === this.options.hiddenState) return this.hide(); (e = this.el.classList).add.apply(e, t.split(" ")), this.options.visibleOnState && this.show() }, e.removeState = function (t) { var e; if (this.trigger("removeState", t), t === this.options.hiddenState) return this.show(); (e = this.el.classList).remove.apply(e, t.split(" ")), this.options.visibleOnState && this.el.className === this.options.className && this.hide() }, e.toggleState = function (t, e) { !0 === e || !1 !== e && !this.el.classList.contains(t) ? this.addState(t) : this.removeState(t) }, e.setSkewing = function (t) { this.gsap.to(this, { skewing: t }) }, e.removeSkewing = function () { this.gsap.to(this, { skewing: this.options.skewing }) }, e.setStick = function (t) { var e = ("string" == typeof t ? document.querySelector(t) : t).getBoundingClientRect(); this.stick = { y: e.top + e.height / 2, x: e.left + e.width / 2 } }, e.removeStick = function () { this.stick = !1 }, e.setText = function (t) { this.text.innerHTML = t, this.addState(this.options.textState), this.setSkewing(this.options.skewingText) }, e.removeText = function () { this.removeState(this.options.textState), this.removeSkewing() }, e.setIcon = function (t, e) { void 0 === e && (e = ""), this.text.innerHTML = "<svg class='" + this.options.iconSvgClassName + " " + this.options.iconSvgNamePrefix + t + "' style='" + e + "'><use xlink:href='" + this.options.iconSvgSrc + "#" + t + "'></use></svg>", this.addState(this.options.iconState), this.setSkewing(this.options.skewingIcon) }, e.removeIcon = function () { this.removeState(this.options.iconState), this.removeSkewing() }, e.setMedia = function (t) { var e = this; clearTimeout(this.mediaInt), t && (this.mediaBox.innerHTML = "", this.mediaBox.appendChild(t)), this.mediaInt = setTimeout((function () { return e.addState(e.options.mediaState) }), 20), this.setSkewing(this.options.skewingMedia) }, e.removeMedia = function () { var t = this; clearTimeout(this.mediaInt), this.removeState(this.options.mediaState), this.mediaInt = setTimeout((function () { return t.mediaBox.innerHTML = "" }), this.options.hideMediaTimeout), this.removeSkewing() }, e.setImg = function (t) { this.mediaImg || (this.mediaImg = new Image), this.mediaImg.src !== t && (this.mediaImg.src = t), this.setMedia(this.mediaImg) }, e.removeImg = function () { this.removeMedia() }, e.setVideo = function (t) { this.mediaVideo || (this.mediaVideo = document.createElement("video"), this.mediaVideo.muted = !0, this.mediaVideo.loop = !0, this.mediaVideo.autoplay = !0), this.mediaVideo.src !== t && (this.mediaVideo.src = t, this.mediaVideo.load()), this.mediaVideo.play(), this.setMedia(this.mediaVideo) }, e.removeVideo = function () { this.mediaVideo && this.mediaVideo.readyState > 2 && this.mediaVideo.pause(), this.removeMedia() }, e.on = function (t, e) { this.events[t] instanceof Array || this.off(t), this.events[t].push(e) }, e.off = function (t, e) { this.events[t] = e ? this.events[t].filter((function (t) { return t !== e })) : [] }, e.trigger = function (t) { var e = arguments, i = this; this.events[t] && this.events[t].forEach((function (t) { return t.call.apply(t, [i, i].concat([].slice.call(e, 1))) })) }, e.getFromDataset = function (t) { var e = t.dataset; return { state: e[this.options.dataAttr], show: e[this.options.dataAttr + "Show"], text: e[this.options.dataAttr + "Text"], icon: e[this.options.dataAttr + "Icon"], img: e[this.options.dataAttr + "Img"], video: e[this.options.dataAttr + "Video"], stick: e[this.options.dataAttr + "Stick"] } }, e.destroy = function () { this.trigger("destroy"), this.gsap.ticker.remove(this.ticker), this.container.removeEventListener("mouseleave", this.event.mouseleave), this.container.removeEventListener("mouseenter", this.event.mouseenter), this.container.removeEventListener("mousedown", this.event.mousedown), this.container.removeEventListener("mouseup", this.event.mouseup), this.container.removeEventListener("mousemove", this.event.mousemove), this.container.removeEventListener("mousemove", this.event.mousemoveOnce), this.container.removeEventListener("mouseover", this.event.mouseover), this.container.removeEventListener("mouseout", this.event.mouseout), this.el && (this.container.removeChild(this.el), this.el = null, this.mediaImg = null, this.mediaVideo = null) }, t }(); me.registerGSAP(lt.o); let ge = { removeState: () => { }, destroy: () => { }, addState: () => { } }; const ve = () => { window.matchMedia("(prefers-reduced-motion: reduce)").matches ? console.log("MouseFollower is disabled due to reduced motion preference.") : ge = new me({ speed: 1, skewingText: 0 }) }; ve(), window.matchMedia("(prefers-reduced-motion: reduce)").addEventListener("change", ve); var we = ge; window.utils = window.utils || {}, window.isFirstPageLoad = !0; let ye = !0; const _e = document.querySelector(".c-preloader[data-cid]"), be = _e?.dataset.duration ?? 1e3; window.utils.preloader = { element: _e, duration: be }; const Se = async () => { const t = () => { document.documentElement.classList.remove("is-loading"), document.documentElement.classList.add("has-loaded"), window.utils.lenis || (window.utils.lenis = re, window.utils.lenis.init()), window.utils.scroller || (window.utils.scroller = new oe, window.utils.scroller.init()), (new Mt).init() }; window.utils.preloader.element ? setTimeout((() => { window.utils.preloader.element.classList.add("is-hidden"), t() }), window.utils.preloader.duration) : t() }, ke = async () => { _t.init({ debug: !1, critical: !1 }); let t = !1; _t.hooks.on("styles:loaded", (() => { t || (t = !0, lt.u.refresh(), he.start(), fe.start(), window.utils.splitAnimation = It({ debug: !1 }), window.addEventListener("resize", Ee)) })) }; "complete" === document.readyState ? (Se(), ke(), ye = !1) : document.addEventListener("DOMContentLoaded", (() => { Se(), ke(), ye = !1 })); const xe = async () => { console.clear(), _t.cleanup(), _t.hooks.off("styles:loaded"), window.utils.scrollTo && window.utils.scrollTo.cleanup(), he.stop(), fe.stop(), we && "function" == typeof we.removeState && we.removeState("-inverse -pointer -text -hidden -media -active"), window.utils.splitAnimation && (window.utils.splitAnimation.destroy(), window.utils.splitAnimation = null), Te(), window.removeEventListener("resize", Ee) }; at.hooks.before("content:replace", (() => { xe() })), at.hooks.before("content:scroll", (() => { at.hooks.once("scroll:end", (() => { ye || (ke(), (async () => { window.isFirstPageLoad = !1, "undefined" != typeof lazySizes ? lazySizes.init() : console.warn("lazysizes not found. Please check if the EWWW plugin is installed and enabled."), window.utils.lenis && "function" == typeof window.utils.lenis.refreshModal && window.utils.lenis.config.modalSelector && window.utils.lenis.refreshModal(), window.utils.scrollTo && window.utils.scrollTo.refresh() })()) })) })), at.hooks.on("visit:start", (t => { t.history.popstate && xe() })), at.hooks.on("visit:end", (t => { t.history.popstate && ke() })); at.hooks.on("animation:out:end", (t => { (async t => { try { const e = await fetch(t), i = await e.text(), n = document.createElement("div"); n.style.display = "none", n.innerHTML = i; const s = t => { const e = n.querySelector(`style#${t}`); let i = document.getElementById(t); e ? (i || (i = document.createElement("style"), i.id = t, document.head.appendChild(i)), i.textContent = e.textContent) : i && i.remove() }; s("wp-block-library-theme-inline-css"), s("global-styles-inline-css"), s("core-block-supports-inline-css"); const r = n.querySelector("link#wp-block-library-css"); let o = document.getElementById("wp-block-library-css"); r ? (o || (o = document.createElement("link"), o.id = "wp-block-library-css", o.rel = "stylesheet", document.head.appendChild(o)), o.href = r.href) : o && o.remove(), lt.u.refresh() } catch (t) { console.error("Error refreshing WordPress styles:", t) } })(t.to.url) })), window.onload = async () => { try { const [{ ScrollTo: t }] = await Promise.all([r.e(280).then(r.bind(r, 280))]); window.utils.scrollTo = new t, window.utils.scrollTo.init() } catch (t) { console.warn("Utilities failed to import.", t) } }; const { debouncedFn: Ee, cleanup: Te } = Et((() => { window.matchMedia("(min-width: 1025px) and (hover: hover) and (pointer: fine)").matches && lt.u.refresh() }), 500) }(), o = r.O(o) }();